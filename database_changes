
Procedure made my me
--------11-3-2024

f_get_state_by_id()
------------------------------------------------

-- FUNCTION: public.f_get_state_by_id(integer)

-- DROP FUNCTION IF EXISTS public.f_get_state_by_id(integer);

CREATE OR REPLACE FUNCTION public.f_get_state_by_id(
	par_state_id integer)
    RETURNS SETOF t_state_master 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN					  	      

RETURN QUERY

	SELECT * FROM public.t_state_master WHERE state_id=par_state_id;  

END;
$BODY$;




---------------------
Chnages in Procedure

add_web_application_exception_log()

------------------------------------------------------------

-- PROCEDURE: public.add_web_application_exception_log(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying)

-- DROP PROCEDURE IF EXISTS public.add_web_application_exception_log(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying);

CREATE OR REPLACE PROCEDURE public.add_web_application_exception_log(
	p_type character varying,
	p_message character varying,
	p_target_site character varying,
	p_request_url character varying,
	p_user_agent character varying,
	p_user_ip character varying,
	p_user_authentication character varying,
	p_login_id character varying)
LANGUAGE 'plpgsql'
AS $BODY$
  
BEGIN  
	INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(6,0,p_type,p_message || ' Target Site:' || p_target_site || ' Request URL:' || p_request_url || ' User Agent:' || p_user_agent || ' User Authentication:' || p_user_authentication,2,now(),p_login_id,p_user_ip);
END;
$BODY$;



------------------------------------------------------------------------------------------------------------------------------


f_list_device_manufacturer_cum_vendor_details_by_imei()


-- FUNCTION: enlistment.f_list_device_manufacturer_cum_vendor_details_by_imei(character)

-- DROP FUNCTION IF EXISTS enlistment.f_list_device_manufacturer_cum_vendor_details_by_imei(character);

CREATE OR REPLACE FUNCTION enlistment.f_list_device_manufacturer_cum_vendor_details_by_imei(
	par_imei character)
    RETURNS SETOF enlistment.t_device_manufacturer_cum_vendor 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN					  	      

RETURN QUERY

	Select * From enlistment.t_device_manufacturer_cum_vendor Where imei = par_imei;

END;
$BODY$;

----------------------------------------------------------------------------------------------------

---- New Table public.t_vendor_command_mapping Created


-- Table: public.t_vendor_command_mapping

-- DROP TABLE IF EXISTS public.t_vendor_command_mapping;

CREATE TABLE IF NOT EXISTS public.t_vendor_command_mapping
(
    vendor_id character varying COLLATE pg_catalog."default",
    command_id smallint,
    command_syntax character varying COLLATE pg_catalog."default",
    success_status character varying COLLATE pg_catalog."default",
    supported_mode character varying COLLATE pg_catalog."default",
    command_name character varying COLLATE pg_catalog."default",
    updated_by character varying COLLATE pg_catalog."default",
    updated_ip character varying COLLATE pg_catalog."default",
    updated_on timestamp without time zone,
    device_model character varying(300) COLLATE pg_catalog."default"
)

TABLESPACE pg_default;

--------------------------------------------------------------------------------------------------------------------

-- New Function

-- FUNCTION: public.f_get_vendor_command_mapping_by_vendorid_ndevice_model(character varying, character varying)

-- DROP FUNCTION IF EXISTS public.f_get_vendor_command_mapping_by_vendorid_ndevice_model(character varying, character varying);

CREATE OR REPLACE FUNCTION public.f_get_vendor_command_mapping_by_vendorid_ndevice_model(
	par_vendor_id character varying,
	par_device_model character varying)
    RETURNS SETOF t_vendor_command_mapping 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN				  	      
RETURN QUERY

	Select * From public.t_vendor_command_mapping Where vendor_id = par_vendor_id AND device_model= par_device_model;

END;
$BODY$;

ALTER FUNCTION public.f_get_vendor_command_mapping_by_vendorid_ndevice_model(character varying, character varying)
    OWNER TO postgres;


--------------------------------------------------------------------------------------------------------------------------


-- FUNCTION: public.f_get_esim_providers_by_id(integer)

-- DROP FUNCTION IF EXISTS public.f_get_esim_providers_by_id(integer);

CREATE OR REPLACE FUNCTION public.f_get_esim_providers_by_id(
	par_esimprovider_id integer)
    RETURNS SETOF t_esim_provider_master 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN				  	      
RETURN QUERY

	Select * From public.t_esim_provider_master Where esim_provider_id = par_esimprovider_id::smallint;

END;
$BODY$;

-------------------------------------------------------------------------------------------------------------------------

-- Alter Table Add Column id integer,terms_n_conditions integer,

-- ALTER Table enlistment.t_device_manufacturer_cum_vendor Add Column id serial

-----enlistment.t_device_manufacturer_cum_vendor

-- Table: enlistment.t_device_manufacturer_cum_vendor

-- DROP TABLE IF EXISTS enlistment.t_device_manufacturer_cum_vendor;

CREATE TABLE IF NOT EXISTS enlistment.t_device_manufacturer_cum_vendor
(
    state_id smallint NOT NULL,
    cin character(21) COLLATE pg_catalog."default",
    vendor_id character varying(20) COLLATE pg_catalog."default" NOT NULL,
    manufacturer_name character varying(200) COLLATE pg_catalog."default" NOT NULL,
    building_no character varying(100) COLLATE pg_catalog."default",
    street character varying(100) COLLATE pg_catalog."default",
    city character varying(50) COLLATE pg_catalog."default" NOT NULL,
    pin character(6) COLLATE pg_catalog."default" NOT NULL,
    manufacturer_state_id smallint NOT NULL,
    manufacturer_district_id smallint NOT NULL,
    landline character varying(12) COLLATE pg_catalog."default" NOT NULL,
    faxno character varying(12) COLLATE pg_catalog."default" NOT NULL,
    mobile_no_1 character(10) COLLATE pg_catalog."default" NOT NULL,
    mobile_no_2 character(10) COLLATE pg_catalog."default" NOT NULL,
    email_id_1 character varying(100) COLLATE pg_catalog."default",
    email_id_2 character varying(100) COLLATE pg_catalog."default",
    testing_agency_id character(1) COLLATE pg_catalog."default" NOT NULL,
    contact_person_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    device_modal character varying(50) COLLATE pg_catalog."default" NOT NULL,
    imei character(15) COLLATE pg_catalog."default" NOT NULL,
    vehicle_reg_no character varying(11) COLLATE pg_catalog."default" NOT NULL,
    primary_misdn character varying(13) COLLATE pg_catalog."default",
    fallback_misdn character varying(13) COLLATE pg_catalog."default",
    esim_provider character(1) COLLATE pg_catalog."default",
    icc_id character varying(23) COLLATE pg_catalog."default",
    tac_documents bytea,
    cop_date date,
    signed_reg_document bytea,
    registration_date timestamp(3) without time zone DEFAULT now(),
    approval_letter bytea,
    approval_letter_no character varying(50) COLLATE pg_catalog."default",
    approval_date date,
    is_approved character(1) COLLATE pg_catalog."default" NOT NULL,
    updation_date timestamp(3) without time zone,
    insert_or_update_by character varying(20) COLLATE pg_catalog."default",
    ip_address character varying(15) COLLATE pg_catalog."default",
    terms_n_conditions integer,
    id integer NOT NULL DEFAULT nextval('enlistment.t_device_manufacturer_cum_vendor_id_seq'::regclass),
    CONSTRAINT pk_devicemanufacturercumvendor_vendorid_devicemodel PRIMARY KEY (vendor_id, device_modal),
    CONSTRAINT fk_devicemanufacturercumvendor_manufacturerdistrictid FOREIGN KEY (manufacturer_district_id)
        REFERENCES public.t_district_master (district_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT fk_devicemanufacturercumvendor_manufacturerstateid FOREIGN KEY (manufacturer_state_id)
        REFERENCES public.t_state_master (state_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE,
    CONSTRAINT fk_devicemanufacturercumvendor_stateid FOREIGN KEY (state_id)
        REFERENCES public.t_state_master (state_id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_devicemanufacturercumvendor_testingagencyid FOREIGN KEY (testing_agency_id)
        REFERENCES public.t_testing_agency_master (testing_agency_id) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS enlistment.t_device_manufacturer_cum_vendor
    OWNER to postgres;





-----------------------------------------------------------------------------------------

-- Alter PROCEDURE


-- PROCEDURE: enlistment.add_manufacture_data_for_enlistment(bigint, smallint, character varying, character varying, character varying, character varying, character varying, smallint, smallint, character varying, character varying, character varying, character, character, character varying, character varying, character varying, character varying, character varying, character varying, character, date, character varying, character varying, character varying, character, character, character varying, integer, bytea, bytea, character varying, text)

-- DROP PROCEDURE IF EXISTS enlistment.add_manufacture_data_for_enlistment(bigint, smallint, character varying, character varying, character varying, character varying, character varying, smallint, smallint, character varying, character varying, character varying, character, character, character varying, character varying, character varying, character varying, character varying, character varying, character, date, character varying, character varying, character varying, character, character, character varying, integer, bytea, bytea, character varying, text);

CREATE OR REPLACE PROCEDURE enlistment.add_manufacture_data_for_enlistment(
	INOUT v_id bigint,
	p_state_id smallint,
	p_manufacturer_name character varying,
	p_building_no character varying,
	p_street character varying,
	p_city character varying,
	p_pin character varying,
	p_state smallint,
	p_district smallint,
	p_name_of_contact_person character varying,
	p_landline character varying,
	p_fax_no character varying,
	p_mobile_no1 character,
	p_mobile_no2 character,
	p_email_id1 character varying,
	p_email_id2 character varying,
	p_vendor_id character varying,
	p_device_modal character varying,
	p_imei character varying,
	p_vehicle_reg_no character varying,
	p_testing_agency character,
	p_cop_date date,
	p_insert_or_update_by character varying,
	p_primary_misdn character varying,
	p_fallback_misdn character varying,
	p_esim_provider character,
	p_cin character,
	p_icc_id character varying,
	p_terms_n_conditions integer,
	p_tac_documents bytea DEFAULT NULL::bytea,
	p_signed_reg_document bytea DEFAULT NULL::bytea,
	p_ip_address character varying DEFAULT ''::character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN
		IF NOT EXISTS(SELECT vendor_id AS vendor_id FROM enlistment.t_device_manufacturer_cum_vendor WHERE vendor_id=p_vendor_id and device_modal=p_device_modal)
		THEN
		IF Not Exists(SELECT imei FROM enlistment.t_device_manufacturer_cum_vendor WHERE imei=p_imei)
		THEN
		INSERT INTO enlistment.t_device_manufacturer_cum_vendor
           (
		   cin,
		   state_id,
           manufacturer_name,
           building_no,
           street,          
           city,
		   pin,
		   manufacturer_state_id,
		   manufacturer_district_id,
		   contact_person_name,
		   landline,
		   faxno,
		   mobile_no_1,
		   mobile_no_2,
		   email_id_1,
		   email_id_2,
		   vendor_id,
           device_modal,
		   imei,
		   vehicle_reg_no,
		   testing_agency_id,
		   tac_documents,
		   cop_date,
		   signed_reg_document,
           is_approved,
		   registration_date,
			ip_address,
			insert_or_update_by,
			primary_misdn,
			fallback_misdn,
			esim_provider,
			icc_id,terms_n_conditions)VALUES (upper(p_cin),p_state_id,upper(p_manufacturer_name),upper(p_building_no),upper(p_street),upper(p_city),p_pin,p_state,p_district,upper(p_name_of_contact_person),p_landline,p_fax_no,
	        p_mobile_no1,p_mobile_no2,lower(p_email_id1),lower(p_email_id2),upper(p_vendor_id),
	        upper(p_device_modal),p_imei,upper(p_vehicle_reg_no),p_testing_agency,p_tac_documents,p_cop_date,p_signed_reg_document,'n',now(),p_ip_address,p_insert_or_update_by,p_primary_misdn,p_fallback_misdn,
			p_esim_provider,p_icc_id,p_terms_n_conditions) RETURNING id INTO v_id;
	_response := 'Manufacturer Registred successfully for Enlistment.';
	ELSE
	_response := 'This IMEI already exist.';
	END IF;
	ELSE
	_response := 'This vendor Id already exist.';
	END IF;

			EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;
END;
$BODY$;

--------------------------------------------------------------------------------------

-- New Table

--- enlistment.t_enlist_related_docs

-- Table: enlistment.t_enlist_related_docs

-- DROP TABLE IF EXISTS enlistment.t_enlist_related_docs;

CREATE TABLE IF NOT EXISTS enlistment.t_enlist_related_docs
(
    id integer NOT NULL DEFAULT nextval('enlistment.t_enlist_related_docs_id_seq'::regclass),
    stateid smallint NOT NULL,
    oem_id integer NOT NULL,
    msme_certificate bytea,
    pan_card bytea,
    gst_certificate bytea,
    asi140_certificate bytea,
    product_brochure bytea,
    company_profile bytea,
    bank_guarantee bytea,
    insertiondatetime timestamp(0) without time zone NOT NULL,
    ipaddress character varying(25) COLLATE pg_catalog."default",
    CONSTRAINT enlist_related_docs_pkey PRIMARY KEY (id),
    CONSTRAINT enlist_related_docs_oem_id_key UNIQUE (oem_id)
)

---------------------------------------------------------------------------------------------------------------------------

-- New PROCEDURE

-- FUNCTION: enlistment.f_get_enlist_related_docs(integer)

-- DROP FUNCTION IF EXISTS enlistment.f_get_enlist_related_docs(integer);

CREATE OR REPLACE FUNCTION enlistment.f_get_enlist_related_docs(
	par_id integer)
    RETURNS TABLE(val_id integer, val_msme_certificate bytea, val_pan_card bytea, val_gst_certificate bytea, val_asi140_certificate bytea, val_product_brochure bytea, val_company_profile bytea, val_bank_guarantee bytea) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN
					  	
    RETURN QUERY

    SELECT ERD.id as enlist_related_docs_id,msme_certificate,pan_card,
		gst_certificate,asi140_certificate,product_brochure,
		company_profile,bank_guarantee 
        FROM enlistment.t_enlist_related_docs AS ERD
		LEFT JOIN enlistment.t_device_manufacturer_cum_vendor DMCV ON ERD.oem_id=DMCV.id 
        WHERE oem_id=par_id;

END;
$BODY$;

-- Done at localdatabse 12-3-2024

--------------------------------------------------------------------------------------------

-- Date : 13-3-2024

-- New PROCEDURE

-- FUNCTION: enlistment.f_get_enlist_related_docs_by_id(integer)

-- DROP FUNCTION IF EXISTS enlistment.f_get_enlist_related_docs_by_id(integer);

CREATE OR REPLACE FUNCTION enlistment.f_get_enlist_related_docs_by_id(
	par_id integer)
    RETURNS TABLE(val_msme_certificate bytea, val_pan_card bytea, val_gst_certificate bytea, val_asi140_certificate bytea, val_product_brochure bytea, val_company_profile bytea, val_bank_guarantee bytea) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN
					  	
    RETURN QUERY

    SELECT msme_certificate,pan_card,gst_certificate,asi140_certificate,
			product_brochure,company_profile,bank_guarantee 
			FROM enlistment.t_enlist_related_docs 		
			WHERE id=par_id;

END;
$BODY$;


----------------------------------------------------------------------------------------------------------------------------

-- New PROCEDURE

-- PROCEDURE: enlistment.add_enlist_related_docs(integer, integer, bytea, bytea, bytea, bytea, bytea, bytea, bytea, character varying, timestamp without time zone)

-- DROP PROCEDURE IF EXISTS enlistment.add_enlist_related_docs(integer, integer, bytea, bytea, bytea, bytea, bytea, bytea, bytea, character varying, timestamp without time zone);

CREATE OR REPLACE PROCEDURE enlistment.add_enlist_related_docs(
	p_stateid integer,
	p_oem_id integer,
	p_msme_certificate bytea,
	p_pan_card bytea,
	p_gst_certificate bytea,
	p_asi140_certificate bytea,
	p_product_brochure bytea,
	p_company_profile bytea,
	p_bank_guarantee bytea,
	p_ipaddress character varying,
	p_insertiondatetime timestamp without time zone)
LANGUAGE 'plpgsql'
AS $BODY$
Declare 
	v_roleid int;
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN	
		INSERT into enlistment.t_enlist_related_docs(stateid, oem_id, msme_certificate, pan_card, gst_certificate, 
				asi140_certificate, product_brochure, company_profile, bank_guarantee, 
				insertiondatetime, ipaddress)
		VALUES(p_stateid::smallint, p_oem_id, p_msme_certificate, p_pan_card, p_gst_certificate, 
				p_asi140_certificate, p_product_brochure, p_company_profile, p_bank_guarantee, 
				p_insertiondatetime, p_ipaddress);
	
		EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;

				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_stateid,0,v_state,v_msg || ' ' || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,1,now(),'NA','NA');	
				END;
	
END;
$BODY$;




-----------------------------------------------------------------------------------------------------------------------------------


-- New PROCEDURE

-- PROCEDURE: enlistment.update_enlist_related_docs(bytea, bytea, bytea, bytea, bytea, bytea, bytea, integer)

-- DROP PROCEDURE IF EXISTS enlistment.update_enlist_related_docs(bytea, bytea, bytea, bytea, bytea, bytea, bytea, integer);

CREATE OR REPLACE PROCEDURE enlistment.update_enlist_related_docs(
	p_msme_certificate bytea,
	p_pan_card bytea,
	p_gst_certificate bytea,
	p_asi140_certificate bytea,
	p_product_brochure bytea,
	p_company_profile bytea,
	p_bank_guarantee bytea,
	p_enlist_related_docs_id integer)
LANGUAGE 'plpgsql'
AS $BODY$
Declare 
	v_roleid int;
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_stateid smallint;
BEGIN
	BEGIN	
		
		UPDATE enlistment.t_enlist_related_docs SET msme_certificate=p_msme_certificate,
				pan_card=p_pan_card, gst_certificate=p_gst_certificate, 
				asi140_certificate=p_asi140_certificate, product_brochure=p_product_brochure, 
				company_profile=p_company_profile, bank_guarantee=p_bank_guarantee 
				WHERE id=p_enlist_related_docs_id;	
		
		v_stateid := (SELECT stateid FROM enlistment.t_enlist_related_docs WHERE id=p_enlist_related_docs_id);	
		
		EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;

				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(v_stateid,0,v_state,v_msg || ' ' || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,1,now(),'NA','NA');	
				END;
END;
$BODY$;

---------------------------------------------------------------------------------------------------------------------------------

-- New Procedure

-- FUNCTION: enlistment.f_device_manufacturer_cum_vendor_by_id(bigint)

-- DROP FUNCTION IF EXISTS enlistment.f_device_manufacturer_cum_vendor_by_id(bigint);

CREATE OR REPLACE FUNCTION enlistment.f_device_manufacturer_cum_vendor_by_id(
	par_id bigint)
    RETURNS SETOF enlistment.t_device_manufacturer_cum_vendor 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 		
		SELECT * FROM enlistment.t_device_manufacturer_cum_vendor AS tdmcv 
			WHERE tdmcv.id = par_id;
END;
$BODY$;

ALTER FUNCTION enlistment.f_device_manufacturer_cum_vendor_by_id(bigint)
    OWNER TO postgres;


---------------------------------------------------------------------------------------------------------------------------------




CREATE OR REPLACE FUNCTION public.f_list_ota_command_type_master()
    RETURNS SETOF public.t_ota_command_type_master 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 		
		SELECT * FROM public.t_ota_command_type_master;
END;
$BODY$;

--------------------------------------------------------------------------------------

-- Alter Table

-- Table: public.t_ota_command_type_master

-- DROP TABLE IF EXISTS public.t_ota_command_type_master;

CREATE TABLE IF NOT EXISTS public.t_ota_command_type_master
(
    ota_command_type_id integer NOT NULL,
    ota_command_type character varying(300) COLLATE pg_catalog."default" NOT NULL,
    mandatory_yn character(1) COLLATE pg_catalog."default",
    updated_by character varying COLLATE pg_catalog."default",
    updated_ip character varying COLLATE pg_catalog."default",
    updated_on time without time zone,
    default_yn character(1) COLLATE pg_catalog."default",
    default_syntax character varying(10) COLLATE pg_catalog."default",
    CONSTRAINT pk_mastercommandtype PRIMARY KEY (ota_command_type_id)
)


------------------------------------------------------------------------------------------------



------------------------------------------------------------- Home Database Work----------------------------------

-- Home Database Work


-- FUNCTION: public.f_get_vendor_command_mapping_by_vendorid_ndevice_model(character varying, character varying)

-- DROP FUNCTION IF EXISTS public.f_get_vendor_command_mapping_by_vendorid_ndevice_model(character varying, character varying);

CREATE OR REPLACE FUNCTION public.f_get_vendor_command_mapping_by_vendorid_ndevice_model(
	par_vendor_id character varying,
	par_device_model character varying)
    RETURNS SETOF t_vendor_command_mapping 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN				  	      
RETURN QUERY

	Select * From public.t_vendor_command_mapping Where vendor_id = par_vendor_id AND device_model= par_device_model;

END;
$BODY$;


-----------------------------------------------------------------------------------------------------------------------


CREATE OR REPLACE FUNCTION public.f_get_vendor_command_mapping_by_cmdid_vendorid_ndevice_model(
	par_command_id integer,
	par_vendor_id character varying,
	par_device_model character varying)
    RETURNS SETOF t_vendor_command_mapping 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN				  	      
RETURN QUERY
	Select * From public.t_vendor_command_mapping Where command_id = par_command_id AND vendor_id = par_vendor_id AND device_model= par_device_model;
END;
$BODY$;


-----------------------------------------------------------------------------------------------------------------------




-- FUNCTION: public.f_list_ota_command_type_master()

-- DROP FUNCTION IF EXISTS public.f_list_ota_command_type_master();

CREATE OR REPLACE FUNCTION public.f_list_ota_command_type_master(
	)
    RETURNS SETOF t_ota_command_type_master 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 		
		SELECT * FROM public.t_ota_command_type_master WHERE default_yn='N' ORDER BY mandatory_yn DESC;
END;
$BODY$;


-------------------------------------------------------------------------------------------------------------------------


----------Date: 14-3-2024



CREATE OR REPLACE PROCEDURE public.add_enlist_ota_command(
	INOUT v_status text,
	p_state_id integer,
	p_vendorid text,
	p_devicemodel text,
	p_commandname text,
	p_commandsyntex text,
	p_commandtype smallint,
	p_successresponse text,
	p_created_by character varying,
	p_ip_address character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
	v_state   TEXT;
	v_msg     TEXT;
	v_detail  TEXT;
	v_hint    TEXT;
	v_context TEXT;
BEGIN 
	BEGIN 
		
if exists (select * from t_vendor_command_mapping where vendor_id=p_vendorid and command_id=p_commandtype
		  and device_model=p_devicemodel)
then v_status = 'E';	
_response := 'OTA Command exists';
RETURN;
else
	INSERT INTO t_vendor_command_mapping VALUES (p_vendorid,p_commandtype,p_commandsyntex,
				p_successresponse,null,p_commandname,p_created_by,p_ip_address,now(),
					p_devicemodel);
				
	v_status = 'S';	
	_response := 'OTA Command Added Successfully';
	RETURN;
end if;		
		
		
 				EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
 				_response:= 'SQL Exeception: Something went wrong: '||v_msg;				
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA',p_ip_address);	
				END;
END;
$BODY$;


---------------------------------------------------------------------------------------------------------------------

---- New Function


CREATE OR REPLACE FUNCTION public.f_list_ota_command_type_master_mandatory_y(
	)
    RETURNS TABLE(v_id integer) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 		
	SELECT ota_command_type_id FROM public.t_ota_command_type_master WHERE mandatory_yn='Y';
END;
$BODY$;


---------------------------------------------------------------------------------------------------------


---- New Procedure


CREATE OR REPLACE PROCEDURE public.delete_vendor_cmd_maping_by_cmdid_vendorid_ndevicemodel(	
	p_state_id integer,
	par_command_id integer,
	par_vendor_id character varying,
	par_device_model character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN
		
	 DELETE From t_vendor_command_mapping Where command_id = par_command_id::smallint AND vendor_id = par_vendor_id AND device_model= par_device_model;
		_response := 'Deleted Record Successfully';

EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA',p_ip_address);	
				END;
END;
$BODY$;


----------------------------------------------- Home Work ---------------------------------------------------------------------------------

-- Procedure Changes

-- FUNCTION: public.f_get_mobile_no_by_login_id(character varying, character, smallint)

-- DROP FUNCTION IF EXISTS public.f_get_mobile_no_by_login_id(character varying, character, smallint);

CREATE OR REPLACE FUNCTION public.f_get_mobile_no_by_login_id(
	par_login_id character varying,
	par_mobile_no character,
	par_state_id smallint)
    RETURNS TABLE(val_flag integer, val_state_short_name character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE var_state_short_name character(2);
BEGIN
    SELECT state_short_name_current INTO var_state_short_name FROM public.t_state_master WHERE state_id=par_state_id;
 	IF EXISTS (SELECT mobile_no FROM public.users WHERE login_id=par_login_id AND mobile_no=par_mobile_no)THEN
        RETURN QUERY SELECT 1 AS Flag,var_state_short_name AS state_short_name;
    ELSE
        RETURN QUERY SELECT 0 AS Flag,var_state_short_name AS state_short_name;
    END IF;            
END;
$BODY$;


-------------------------------------------------------------------------------------------------------------------------

--Date: 15-3-2024


--- Changes in Procedure

CREATE OR REPLACE PROCEDURE public.reset_password(
	p_login_id character varying,
	p_new_password character varying,
	p_ip_address character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_password text;
	v_hash_password character varying;
BEGIN
	BEGIN
		IF(LENGTH(p_new_password) <> 64)
		 THEN
			  --v_hash_password := SELECT HASHBYTES('SHA2_256', CAST(p_NewPassword AS TEXT)) ;
			  --p_new_password:=LOWER(CAST('' as xml);.value('xs:hexBinary(sql:variable("@HashPassword"))', 'varchar(max)'));
		 SELECT * INTO v_hash_password FROM f_udf_convert_to_sha256(p_new_password);
		 END IF;
		 	 
		Select password Into v_password from users where login_id = p_login_id; 
		IF Exists (select mobile_no From users where login_id = p_login_id )
		THEN
  			Insert into t_password_change_log(login_id,created_at,created_by,password,created_by_ip)Values(p_login_id,NOW(),p_login_id,v_password,p_ip_address);
		  	UPDATE users SET password=v_hash_password,is_first_time_login='Y' WHERE login_id = p_login_id;
  		    _response:= 'Password has been changed successfully.';
		ELSE
  		_response:= 'Please enter correct Login ID';
		END IF;
  	
  EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(0,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_login_id,p_ip_address);	
				END;
  
END;
$BODY$;

---------------------------------------------------------------------------------------------------------------------

-- Date: 18-03-2024

-- Changes in Procedure


CREATE OR REPLACE FUNCTION enlistment.f_list_mobile_by_imei(
	par_imei character(15))
    RETURNS TABLE(val_response text) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
	DECLARE par_mobile_no character(10) := NULL;
BEGIN 				
				SELECT COALESCE(mobile_no_1,'') into par_mobile_no
				FROM enlistment.t_device_manufacturer_cum_vendor WHERE imei=par_imei;
					
				   IF(par_mobile_no IS NULL)
				    then
					RETURN QUERY 
					  SELECT 'This IMEI number not registred.' AS Response;
				   ELSEIF(par_mobile_no='')
				   	then
					RETURN QUERY 
					  SELECT 'Mobile number not registred for this IMEI. Update your mobile number.' AS  Response;
				   ELSE
				   RETURN QUERY 
				   	SELECT par_mobile_no::text AS Response;
				   END IF;
END;
$BODY$;


--------------------------------------------------------------------------------------------------------------------------


-- Changes in FUNCTION

-- Date: 20-03-2024


CREATE OR REPLACE FUNCTION enlistment.f_get_manufacture_registration_status(
	par_imei character DEFAULT NULL::bpchar)
    RETURNS TABLE(val_manufacturer_name character varying, val_mobile_no_1 character, val_email_id_1 character varying, val_contact_person_name character varying, val_vendor_id character varying, val_imei character, val_device_modal character varying, val_vehicle_reg_no character varying, val_date_of_registration text, val_is_pvt_data_received text, val_is_epb_data_received text, val_is_lgn_data_received text, val_is_hel_data_received text, val_is_approved character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN
					  	
    RETURN QUERY

        SELECT  manufacturer_name,
                mobile_no_1,
                email_id_1,
                contact_person_name,
                DM.vendor_id,
                DM.imei,
                device_modal,
                DM.vehicle_reg_no,
                date_of_registration,
                CASE WHEN TL.imei IS NULL THEN 'N' ELSE 'Y' END AS is_pvt_data_received,
                CASE WHEN ED.imei IS NULL THEN 'N' ELSE 'Y' END AS is_epb_data_received,
                CASE WHEN LD.imei IS NULL THEN 'N' ELSE 'Y' END AS is_lgn_data_received,
                CASE WHEN HD.imei IS NULL THEN 'N' ELSE 'Y' END AS is_hel_data_received,
                is_approved  FROM
                (
                    SELECT  manufacturer_name,
                            contact_person_name,
                            mobile_no_1,
                            email_id_1,
                            vendor_id,
                            device_modal,
                            vehicle_reg_no,
                            imei,
                            is_approved,
                            to_char(registration_date, 'dd-mm-yyyy') as date_of_registration
                    FROM enlistment.t_device_manufacturer_cum_vendor WHERE imei=par_imei

                ) AS DM LEFT OUTER JOIN enlistment.t_vltd_pvt_pkt_latest TL ON DM.imei=TL.imei 
                LEFT OUTER JOIN
                (
                    SELECT imei,COUNT(1) AS total_packet FROM enlistment.t_vltd_emg_pkt_latest WHERE imei=par_imei
                    GROUP BY imei

                ) AS ED ON ED.imei=DM.imei
                LEFT OUTER JOIN
                (
                    SELECT imei,COUNT(1) AS total_packet FROM enlistment.t_vltd_login_pkt_latest WHERE imei=par_imei
                    GROUP BY imei
                ) AS LD ON LD.imei=DM.imei 
                LEFT OUTER JOIN
                (
                    SELECT imei,COUNT(1) AS total_packet FROM enlistment.t_vltd_health_pkt_latest WHERE imei=par_imei
                    GROUP BY imei
                ) AS HD ON HD.imei=DM.imei; 

END;
$BODY$;


-------------------------------------------------------------------------------------------

-- Date: 22-3-2024

-- New Schemas: temp

-- New Table:  temp.t_temp_users


-- Table: temp.t_temp_users

-- DROP TABLE IF EXISTS temp.t_temp_users;

CREATE TABLE IF NOT EXISTS temp.t_temp_users
(
    id integer NOT NULL DEFAULT nextval('temp.t_temp_users_id_seq'::regclass),
    password character varying(255) COLLATE pg_catalog."default" NOT NULL,
    state_id smallint,
    login_id character varying(20) COLLATE pg_catalog."default" NOT NULL,
    username character varying(50) COLLATE pg_catalog."default" NOT NULL,
    mobile_no character(10) COLLATE pg_catalog."default" NOT NULL,
    ip_address character varying(15) COLLATE pg_catalog."default",
    created_at timestamp(0) without time zone,
    is_enlistment_completed character(1) COLLATE pg_catalog."default",
    enlistment_step integer,
    CONSTRAINT users_pkey PRIMARY KEY (id)
)



----------------------------------------------------------------------------------------------------

-- Date: 26-03-2024

-- New Procedure add_temp_user_login



CREATE OR REPLACE PROCEDURE public.add_temp_user_login(
	p_role_id smallint,
	p_email_id character varying,
	p_mobile_no character,
	p_login_id character varying,
	p_state_id smallint,
	p_ip_address character varying,
	p_user_login_id character varying,
	p_name character varying,	
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_sha256_password character varying;
BEGIN
 BEGIN
    SELECT * INTO v_sha256_password FROM f_udf_convert_to_sha256(p_mobile_no);
	IF NOT EXISTS(Select login_id From users Where login_id=UPPER(p_login_id))
	THEN
		IF NOT EXISTS(Select login_id From temp.t_temp_users Where login_id=UPPER(p_login_id))
		THEN
			INSERT INTO temp.t_temp_users(password, state_id, login_id, username, mobile_no, 
				ip_address, created_at, is_enlistment_completed, enlistment_step)
			VALUES (v_sha256_password, p_state_id, UPPER(p_login_id), UPPER(p_login_id), p_mobile_no, 
				p_ip_address, NOW(), 'N', 1);	
			
			INSERT INTO users(state_id,role_id,login_id,password,username,mobile_no,
				email,is_first_time_login,created_at) 
			VALUES(p_state_id,p_role_id,UPPER(p_login_id),v_sha256_password,UPPER(p_login_id),p_mobile_no,
	   			p_email_id,'Y',NOW());
	   
			_response := 'User Added Successfully';
		ELSE
			_response := 'LoginID Already Exists';
		END IF;
	ELSE
	_response := 'LoginID Already Exists';
	END IF;
 
		EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_user_login_id,p_ip_address);	
				END; 
END;
$BODY$;


------------------------------------------------------------------------------------------------------------------

-- Insert Query at t_designation_master Table 

INSERT INTO public.t_designation_master(
	designation_id, designation_name)
	VALUES (17, 'Temp Enlistment User');


----------------------------------------------------------------------------------------------


--Users Table changes

-- name and email column allow NULL


-- Table: public.users

-- DROP TABLE IF EXISTS public.users;

CREATE TABLE IF NOT EXISTS public.users
(
    id bigint NOT NULL DEFAULT nextval('users_id_seq'::regclass),
    name character varying(255) COLLATE pg_catalog."default",
    email character varying(255) COLLATE pg_catalog."default",
    email_verified_at timestamp(0) without time zone,
    password character varying(255) COLLATE pg_catalog."default" NOT NULL,
    state_id smallint NOT NULL,
    role_id smallint NOT NULL,
    login_id character varying(20) COLLATE pg_catalog."default" NOT NULL,
    username character varying(50) COLLATE pg_catalog."default" NOT NULL,
    mobile_no character(10) COLLATE pg_catalog."default" NOT NULL,
    is_first_time_login character(1) COLLATE pg_catalog."default" NOT NULL,
    last_login_time timestamp(3) without time zone,
    last_login_ip character varying(15) COLLATE pg_catalog."default",
    remember_token character varying(100) COLLATE pg_catalog."default",
    created_at timestamp(0) without time zone,
    updated_at timestamp(0) without time zone,
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT users_email_unique UNIQUE (email)
)


-------------------------------------------------------------------------------------


-- New Permission

INSERT INTO public.t_permissions(
	id, route_name, name, local_name, created_at, updated_at)
	VALUES (15,'temp_enlist.index','Temporary User Enlistment','Temporary User Enlistment','2024-03-13 12:05:53','2024-03-13 12:05:53');


----------------------------------------------------------------------------------------


--- New Role has Permission

INSERT INTO public.t_role_has_permissions(
	id, role_id, route_name, created_by, created_at, updated_at)
	VALUES (14,17,'temp_enlist.index',1,'2024-03-22 15:34:24','2024-03-22 15:34:24');
	
	
	
--------------------------------------------------------------------------------------------	
	
-- Date: 27-03-2024

-- New Procedure

-- PROCEDURE: temp.update_enlistment_step(integer, integer, character varying, character varying)

-- DROP PROCEDURE IF EXISTS temp.update_enlistment_step(integer, integer, character varying, character varying);

CREATE OR REPLACE PROCEDURE temp.update_enlistment_step(
	p_state_id integer,
	p_enlistment_step integer,
	p_login_id character varying,
	p_ip_address character varying)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;

BEGIN
	BEGIN
		UPDATE temp.t_temp_users SET enlistment_step= p_enlistment_step
			WHERE login_id=p_login_id;
		
		EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;                
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_login_id,p_ip_address);	
				END;	
		

END;
$BODY$;



--------------------------------------------------------------------------------------------------------------


-- New Function


CREATE OR REPLACE FUNCTION temp.f_get_temp_user_by_login_id(
	p_login_id character varying)
    RETURNS TABLE(val_login_id character varying, val_mobile_no character, val_is_enlistment_completed character, val_enlistment_step integer, val_role_id smallint, val_is_first_time_login character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
	RETURN QUERY
		Select 
		TMU.login_id,
		TMU.mobile_no,
		is_enlistment_completed,
    	enlistment_step,
		PU.role_id,
		PU.is_first_time_login	
		from temp.t_temp_users as TMU		
		LEFT JOIN public.users as PU ON TMU.login_id = PU.login_id
		Where TMU.login_id=p_login_id;
END;
$BODY$;

------------------------------------------------------------------------------------------------------------


-- New Table for Temporary Enlistment

-- Table: temp.t_device_manufacturer_cum_vendor

-- DROP TABLE IF EXISTS temp.t_device_manufacturer_cum_vendor;

CREATE TABLE IF NOT EXISTS temp.t_device_manufacturer_cum_vendor
(
    id integer NOT NULL DEFAULT nextval('temp.t_device_manufacturer_cum_vendor_id_seq'::regclass),
    state_id smallint NOT NULL,
    cin character(21) COLLATE pg_catalog."default" NOT NULL,
    vendor_id character varying(20) COLLATE pg_catalog."default" NOT NULL,
    manufacturer_name character varying(200) COLLATE pg_catalog."default" NOT NULL,
    building_no character varying(100) COLLATE pg_catalog."default" NOT NULL,
    street character varying(100) COLLATE pg_catalog."default" NOT NULL,
    city character varying(50) COLLATE pg_catalog."default" NOT NULL,
    pin character(6) COLLATE pg_catalog."default" NOT NULL,
    manufacturer_state_id smallint NOT NULL,
    manufacturer_district_id smallint NOT NULL,
    landline character varying(12) COLLATE pg_catalog."default",
    faxno character varying(12) COLLATE pg_catalog."default",
    mobile_no_1 character(10) COLLATE pg_catalog."default" NOT NULL,
    mobile_no_2 character(10) COLLATE pg_catalog."default",
    email_id_1 character varying(100) COLLATE pg_catalog."default" NOT NULL,
    email_id_2 character varying(100) COLLATE pg_catalog."default",
    testing_agency_id character(1) COLLATE pg_catalog."default" NOT NULL,
    contact_person_name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    device_modal character varying(50) COLLATE pg_catalog."default",
    imei character(15) COLLATE pg_catalog."default",
    vehicle_reg_no character varying(11) COLLATE pg_catalog."default",
    primary_misdn character varying(13) COLLATE pg_catalog."default",
    fallback_misdn character varying(13) COLLATE pg_catalog."default",
    esim_provider character(1) COLLATE pg_catalog."default",
    icc_id character varying(23) COLLATE pg_catalog."default",
    tac_documents bytea NOT NULL,
    cop_date date,
    signed_reg_document bytea NOT NULL,
    registration_date timestamp(3) without time zone DEFAULT now(),
    approval_letter bytea,
    approval_letter_no character varying(50) COLLATE pg_catalog."default",
    approval_date date,
    is_approved character(1) COLLATE pg_catalog."default",
    updation_date timestamp(3) without time zone,
    insert_or_update_by character varying(20) COLLATE pg_catalog."default",
    ip_address character varying(15) COLLATE pg_catalog."default",
    terms_n_conditions integer,
    CONSTRAINT t_device_manufacturer_cum_vendor_pkey PRIMARY KEY (id)
)


----------------------------------------------------------------------------------------------


-- Date: 28-03-2024

-- New Procedure

-- PROCEDURE: temp.add_manufacture_data_for_enlistment(smallint, character varying, character varying, character varying, character varying, character varying, smallint, smallint, character varying, character varying, character varying, character, character, character varying, character varying, character varying, character, date, character varying, character, integer, bytea, bytea, character varying, text, text)

-- DROP PROCEDURE IF EXISTS temp.add_manufacture_data_for_enlistment(smallint, character varying, character varying, character varying, character varying, character varying, smallint, smallint, character varying, character varying, character varying, character, character, character varying, character varying, character varying, character, date, character varying, character, integer, bytea, bytea, character varying, text, text);

CREATE OR REPLACE PROCEDURE temp.add_manufacture_data_for_enlistment(
	p_state_id smallint,
	p_manufacturer_name character varying,
	p_building_no character varying,
	p_street character varying,
	p_city character varying,
	p_pin character varying,
	p_state smallint,
	p_district smallint,
	p_name_of_contact_person character varying,
	p_landline character varying,
	p_fax_no character varying,
	p_mobile_no1 character,
	p_mobile_no2 character,
	p_email_id1 character varying,
	p_email_id2 character varying,
	p_vendor_id character varying,
	p_testing_agency character,
	p_cop_date date,
	p_insert_or_update_by character varying,
	p_cin character,
	p_terms_n_conditions integer,
	p_tac_documents bytea DEFAULT NULL::bytea,
	p_signed_reg_document bytea DEFAULT NULL::bytea,
	p_ip_address character varying DEFAULT ''::character varying,
	INOUT _msg text DEFAULT NULL::text,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN
		IF NOT EXISTS(SELECT vendor_id AS vendor_id FROM temp.t_device_manufacturer_cum_vendor 
					  WHERE vendor_id=p_vendor_id)
			THEN
				INSERT INTO temp.t_device_manufacturer_cum_vendor
			   (
			   cin, state_id, manufacturer_name, building_no,
			   street, city, pin, manufacturer_state_id, manufacturer_district_id,
			   contact_person_name, landline, faxno, mobile_no_1, mobile_no_2,
			   email_id_1, email_id_2, vendor_id, testing_agency_id,
			   tac_documents, cop_date, signed_reg_document,			   
			   registration_date, ip_address, insert_or_update_by
			   )VALUES (upper(p_cin),p_state_id,upper(p_manufacturer_name),upper(p_building_no),
				upper(p_street),upper(p_city),p_pin,p_state,p_district,
				upper(p_name_of_contact_person),p_landline,p_fax_no,p_mobile_no1,p_mobile_no2,
				lower(p_email_id1),lower(p_email_id2),upper(p_vendor_id),p_testing_agency,
				p_tac_documents,p_cop_date,p_signed_reg_document,now(),p_ip_address,p_insert_or_update_by
				);

				_msg := 'Manufacturer Registred successfully for Enlistment.';
				_response := 'success';

			ELSE
				_msg := 'This vendor Id already exist.';
				_response := 'fail';
			END IF;

			EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;
END;
$BODY$;


----------------------------------------------------------------------------------------------------------------------


-- New Procedure


-- PROCEDURE: temp.update_manufacture_data_for_enlisment(integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character, character varying, text, text)

-- DROP PROCEDURE IF EXISTS temp.update_manufacture_data_for_enlisment(integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character, character varying, text, text);

CREATE OR REPLACE PROCEDURE temp.update_manufacture_data_for_enlisment(
	p_state integer,
	p_vendor_id character varying,
	p_device_modal character varying,
	p_imei character varying,
	p_vehicle_reg_no character varying,
	p_ip_address character varying,
	p_insert_or_update_by character varying,
	p_primary_misdn character varying,
	p_fallback_misdn character varying,
	p_esim_provider character,
	p_icc_id character varying,
	INOUT _msg text DEFAULT NULL::text,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN
   		IF EXISTS(SELECT vendor_id AS vendor_id FROM temp.t_device_manufacturer_cum_vendor 
					  WHERE vendor_id=p_vendor_id)
			THEN			  
				Update temp.t_device_manufacturer_cum_vendor set    		   		   
				   vendor_id=upper(p_vendor_id),
				   device_modal=upper(p_device_modal),
				   imei=p_imei,
				   vehicle_reg_no=upper(p_vehicle_reg_no),		   
				   is_approved='n',
				   primary_misdn=p_primary_misdn,
				   fallback_misdn=p_fallback_misdn,
				   esim_provider=p_esim_provider,
				   updation_date=now(),
				   ip_address=p_ip_address,
				   insert_or_update_by=p_insert_or_update_by,
				   icc_id=p_icc_id 
				   where vendor_id=p_vendor_id;

				 _msg := 'Manufacturer Registration Updated successfully.';
				_response := 'success';
				
			ELSE
				_response := 'This vendor Id not exist.';
				_msg := 'fail';
			END IF;	
   
   EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;
END;
$BODY$;

ALTER PROCEDURE temp.update_manufacture_data_for_enlisment(integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character, character varying, text, text)
    OWNER TO postgres;


-----------------------------------------------------------------------------------------------------------------------------------

-- New Table in Temp Schemas

-- Table: temp.t_enlist_related_docs

-- DROP TABLE IF EXISTS temp.t_enlist_related_docs;

CREATE TABLE IF NOT EXISTS temp.t_enlist_related_docs
(
    id serial PRIMARY KEY,
    stateid integer NOT NULL,
    login_id character varying NOT NULL,
    msme_certificate bytea,
    pan_card bytea,
    gst_certificate bytea,
    asi140_certificate bytea,
    product_brochure bytea,
    company_profile bytea,
    bank_guarantee bytea,
    insertiondatetime timestamp(0) without time zone NOT NULL,
    ipaddress character varying(25) COLLATE pg_catalog."default",
    CONSTRAINT enlist_related_docs_login_id_key UNIQUE (login_id)
)


-----------------------------------------------------------------------------------------------------------------

-- New function

-- FUNCTION: temp.f_get_enlist_related_docs(character varying)

-- DROP FUNCTION IF EXISTS temp.f_get_enlist_related_docs(character varying);

CREATE OR REPLACE FUNCTION temp.f_get_enlist_related_docs(
	par_login_id character varying)
    RETURNS TABLE(val_login_id character varying, val_msme_certificate bytea, val_pan_card bytea, val_gst_certificate bytea, val_asi140_certificate bytea, val_product_brochure bytea, val_company_profile bytea, val_bank_guarantee bytea) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN
					  	
    RETURN QUERY

    SELECT ERD.login_id as login_id,msme_certificate,pan_card,
		gst_certificate,asi140_certificate,product_brochure,
		company_profile,bank_guarantee 
        FROM temp.t_enlist_related_docs AS ERD
		LEFT JOIN temp.t_device_manufacturer_cum_vendor DMCV ON ERD.login_id=DMCV.vendor_id 
        WHERE login_id=par_login_id;

END;
$BODY$;

-------------------------------------------------------------------------------------------------------------------


-- New function


-- FUNCTION: temp.f_get_enlist_related_docs_by_id(character varying)

-- DROP FUNCTION IF EXISTS temp.f_get_enlist_related_docs_by_id(character varying);

CREATE OR REPLACE FUNCTION temp.f_get_enlist_related_docs_by_id(
	par_login_id character varying)
    RETURNS TABLE(val_msme_certificate bytea, val_pan_card bytea, val_gst_certificate bytea, val_asi140_certificate bytea, val_product_brochure bytea, val_company_profile bytea, val_bank_guarantee bytea) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN
					  	
    RETURN QUERY

    SELECT msme_certificate,pan_card,gst_certificate,asi140_certificate,
			product_brochure,company_profile,bank_guarantee 
			FROM temp.t_enlist_related_docs 		
			WHERE login_id=par_login_id;

END;
$BODY$;


----------------------------------------------------------------------------------------------------------

-- New Procedure

CREATE OR REPLACE PROCEDURE temp.add_enlist_related_docs(
	p_stateid integer,
	p_login_id character varying,
	p_msme_certificate bytea,
	p_pan_card bytea,
	p_gst_certificate bytea,
	p_asi140_certificate bytea,
	p_product_brochure bytea,
	p_company_profile bytea,
	p_bank_guarantee bytea,
	p_ipaddress character varying,
	p_insertiondatetime timestamp without time zone)
LANGUAGE 'plpgsql'
AS $BODY$
Declare 
	v_roleid int;
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN	
		INSERT into temp.t_enlist_related_docs(stateid, login_id, msme_certificate, pan_card, gst_certificate, 
				asi140_certificate, product_brochure, company_profile, bank_guarantee, 
				insertiondatetime, ipaddress)
		VALUES(p_stateid, p_login_id, p_msme_certificate, p_pan_card, p_gst_certificate, 
				p_asi140_certificate, p_product_brochure, p_company_profile, p_bank_guarantee, 
				p_insertiondatetime, p_ipaddress);
	
		EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;

				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_stateid,0,v_state,v_msg || ' ' || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,1,now(),'NA','NA');	
				END;
	
END;
$BODY$;


------------------------------------------------------------------------------------------------------------


-- New Procedure


CREATE OR REPLACE PROCEDURE temp.update_enlist_related_docs(
	p_msme_certificate bytea,
	p_pan_card bytea,
	p_gst_certificate bytea,
	p_asi140_certificate bytea,
	p_product_brochure bytea,
	p_company_profile bytea,
	p_bank_guarantee bytea,
	p_login_id character varying)
LANGUAGE 'plpgsql'
AS $BODY$
Declare 
	v_roleid int;
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_stateid smallint;
BEGIN
	BEGIN	
		
		UPDATE temp.t_enlist_related_docs SET msme_certificate=p_msme_certificate,
				pan_card=p_pan_card, gst_certificate=p_gst_certificate, 
				asi140_certificate=p_asi140_certificate, product_brochure=p_product_brochure, 
				company_profile=p_company_profile, bank_guarantee=p_bank_guarantee 
				WHERE login_id=p_login_id;	
		
		v_stateid := (SELECT stateid FROM temp.t_enlist_related_docs WHERE login_id=p_login_id);	
		
		EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;

				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(v_stateid,0,v_state,v_msg || ' ' || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,1,now(),p_login_id,'NA');	
				END;
END;
$BODY$;

----------------------------------------------------------------------------------------------------------


-- Date: 29-03-2024

-- New Function

-- FUNCTION: temp.f_device_manufacturer_cum_vendor_by_id(character varying)

-- DROP FUNCTION IF EXISTS temp.f_device_manufacturer_cum_vendor_by_id(character varying);

CREATE OR REPLACE FUNCTION temp.f_device_manufacturer_cum_vendor_by_login_id(
	par_login_id character varying)
    RETURNS SETOF temp.t_device_manufacturer_cum_vendor 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 		
		SELECT * FROM temp.t_device_manufacturer_cum_vendor AS tdmcv 
			WHERE tdmcv.vendor_id = par_login_id;
END;
$BODY$;


----------------------------------------------------------------------------------------------------------------

-- New Table at Temp Schemas

-- Table: temp.t_vendor_command_mapping

-- DROP TABLE IF EXISTS temp.t_vendor_command_mapping;

CREATE TABLE IF NOT EXISTS temp.t_vendor_command_mapping
(
    vendor_id character varying COLLATE pg_catalog."default",
	device_model character varying(300) COLLATE pg_catalog."default",
    command_id smallint,
    command_syntax character varying COLLATE pg_catalog."default",
    success_status character varying COLLATE pg_catalog."default",
    supported_mode character varying COLLATE pg_catalog."default",
    command_name character varying COLLATE pg_catalog."default",
    updated_by character varying COLLATE pg_catalog."default",
    updated_ip character varying COLLATE pg_catalog."default",
    updated_on timestamp without time zone    
)

------------------------------------------------------------------------------------------------------------------

-- New Function

-- FUNCTION: temp.f_get_vendor_command_mapping_by_vendorid_ndevice_model(character varying, character varying)

-- DROP FUNCTION IF EXISTS temp.f_get_vendor_command_mapping_by_vendorid_ndevice_model(character varying, character varying);

CREATE OR REPLACE FUNCTION temp.f_get_vendor_command_mapping_by_vendorid_ndevice_model(
	par_vendor_id character varying,
	par_device_model character varying)
    RETURNS SETOF temp.t_vendor_command_mapping 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN				  	      
RETURN QUERY

	Select * From temp.t_vendor_command_mapping Where vendor_id = par_vendor_id AND device_model= par_device_model;

END;
$BODY$;

--------------------------------------------------------------------------------------------------------------------

-- New Procedure


-- PROCEDURE: temp.add_enlist_ota_command(text, integer, text, text, text, text, smallint, text, character varying, character varying, text)

-- DROP PROCEDURE IF EXISTS temp.add_enlist_ota_command(text, integer, text, text, text, text, smallint, text, character varying, character varying, text);

CREATE OR REPLACE PROCEDURE temp.add_enlist_ota_command(
	INOUT v_status text,
	p_state_id integer,
	p_vendorid text,
	p_devicemodel text,
	p_commandname text,
	p_commandsyntex text,
	p_commandtype integer,
	p_successresponse text,
	p_created_by character varying,
	p_ip_address character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
	v_state   TEXT;
	v_msg     TEXT;
	v_detail  TEXT;
	v_hint    TEXT;
	v_context TEXT;
BEGIN 
	BEGIN 
		
	if exists (select * from temp.t_vendor_command_mapping where vendor_id=p_vendorid and command_id=p_commandtype::smallint
		  and device_model=p_devicemodel)
		then 
			v_status = 'E';	
			_response := 'OTA Command exists';
			RETURN;
	else
		INSERT INTO temp.t_vendor_command_mapping VALUES (p_vendorid,p_devicemodel,p_commandtype::smallint,p_commandsyntex,
				p_successresponse,null,p_commandname,p_created_by,p_ip_address,now());
				
		v_status = 'S';	
		_response := 'OTA Command Added Successfully';
		RETURN;
	end if;		
		
 				EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
 				_response:= 'SQL Exeception: Something went wrong: '||v_msg;				
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA',p_ip_address);	
				END;
END;
$BODY$;


-------------------------------------------------------------------------------------------------------------------


-- New Procedure

-- PROCEDURE: temp.delete_vendor_cmd_maping_by_cmdid_vendorid_ndevicemodel(integer, integer, character varying, character varying, text)

-- DROP PROCEDURE IF EXISTS temp.delete_vendor_cmd_maping_by_cmdid_vendorid_ndevicemodel(integer, integer, character varying, character varying, text);

CREATE OR REPLACE PROCEDURE temp.delete_vendor_cmd_maping_by_cmdid_vendorid_ndevicemodel(
	p_state_id integer,
	par_command_id integer,
	par_vendor_id character varying,
	par_device_model character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN
		
	 DELETE From temp.t_vendor_command_mapping Where command_id = par_command_id::smallint AND vendor_id = par_vendor_id AND device_model= par_device_model;
		_response := 'Deleted Record Successfully';

EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA',p_ip_address);	
				END;
END;
$BODY$;


---------------------------------------------------------------------------------------------------------------------------


-- New Function

-- FUNCTION: temp.f_get_vendor_command_mapping_by_cmdid_vendorid_ndevice_model(integer, character varying, character varying)

-- DROP FUNCTION IF EXISTS temp.f_get_vendor_command_mapping_by_cmdid_vendorid_ndevice_model(integer, character varying, character varying);

CREATE OR REPLACE FUNCTION temp.f_get_vendor_command_mapping_by_cmdid_vendorid_ndevice_model(
	par_command_id integer,
	par_vendor_id character varying,
	par_device_model character varying)
    RETURNS SETOF temp.t_vendor_command_mapping 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN				  	      
RETURN QUERY
	Select * From temp.t_vendor_command_mapping Where command_id = par_command_id AND vendor_id = par_vendor_id AND device_model= par_device_model;
END;
$BODY$;


--------------------------------------------------------------------------------------

-- New Function

-- FUNCTION: temp.f_list_ota_command_type_master_mandatory_y()

-- DROP FUNCTION IF EXISTS temp.f_list_ota_command_type_master_mandatory_y();

CREATE OR REPLACE FUNCTION temp.f_list_ota_command_type_master_mandatory_y(
	)
    RETURNS TABLE(v_id integer) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 		
	SELECT ota_command_type_id FROM temp.t_ota_command_type_master WHERE mandatory_yn='Y';
END;
$BODY$;


------------------------------------------------------------------------------------------------------------


-- New Procedure




CREATE OR REPLACE PROCEDURE complete_temp_user_enlistment(
	p_state_id integer,
	p_login_id character varying,
	p_device_model character varying,
	INOUT _msg text DEFAULT NULL::text,
	INOUT _response text DEFAULT NULL::text)
	
    LANGUAGE 'plpgsql'
    
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;

BEGIN
	BEGIN	
		IF NOT EXISTS(SELECT vendor_id AS vendor_id FROM enlistment.t_device_manufacturer_cum_vendor 
					  WHERE vendor_id=p_login_id)
			THEN
				INSERT INTO enlistment.t_device_manufacturer_cum_vendor
					Select state_id, cin, vendor_id, manufacturer_name, building_no, 
					street, city, pin, manufacturer_state_id, 
					manufacturer_district_id, landline, faxno, 
					mobile_no_1, mobile_no_2, email_id_1, email_id_2, 
					testing_agency_id, contact_person_name, device_modal, 
					imei, vehicle_reg_no, primary_misdn, fallback_misdn, 
					esim_provider, icc_id, tac_documents, cop_date, 
					signed_reg_document, registration_date, approval_letter, 
					approval_letter_no, approval_date, is_approved, 
					updation_date, insert_or_update_by, ip_address, terms_n_conditions 
					FROM temp.t_device_manufacturer_cum_vendor 
					Where vendor_id=p_login_id;
				
				INSERT INTO enlistment.t_enlist_related_docs
					Select stateid, login_id, msme_certificate, pan_card, 
					gst_certificate, asi140_certificate, product_brochure, 
					company_profile, bank_guarantee, insertiondatetime, 
					ipaddress FROM temp.t_enlist_related_docs 
					Where login_id=p_login_id;
					
				INSERT INTO public.t_vendor_command_mapping
					Select vendor_id, command_id, command_syntax, success_status, 
					supported_mode, command_name, updated_by, updated_ip, 
					updated_on, device_model FROM temp.t_vendor_command_mapping 
					Where login_id=p_login_id AND device_model=p_device_model;
				
				_msg := 'Manufacturer Registred successfully for Enlistment.';
				_response := 'success';

			ELSE
				_msg := 'This vendor Id already exist.';
				_response := 'fail';
			END IF;

			EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;
END;
$BODY$;


--------------------------------------------- Home Work -----------------------------------------------------------------

-- Date: 30-3-2024

-- Correction in Function

-- New Function

-- FUNCTION: temp.f_list_ota_command_type_master_mandatory_y()

-- DROP FUNCTION IF EXISTS temp.f_list_ota_command_type_master_mandatory_y();

CREATE OR REPLACE FUNCTION temp.f_list_ota_command_type_master_mandatory_y(
	)
    RETURNS TABLE(v_id integer) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 		
	SELECT ota_command_type_id FROM t_ota_command_type_master WHERE mandatory_yn='Y';
END;
$BODY$;


-------------------------------------------------------------------------------


-- Correction in procedure

-- PROCEDURE: public.complete_temp_user_enlistment(integer, character varying, character varying, character varying, text, text)

-- DROP PROCEDURE IF EXISTS public.complete_temp_user_enlistment(integer, character varying, character varying, character varying, text, text);

CREATE OR REPLACE PROCEDURE public.complete_temp_user_enlistment(
	IN p_state_id integer,
	IN p_login_id character varying,
	IN p_device_model character varying,
	IN p_ip_address character varying,
	INOUT _msg text DEFAULT NULL::text,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;

BEGIN
	BEGIN	
		IF NOT EXISTS(SELECT vendor_id AS vendor_id FROM enlistment.t_device_manufacturer_cum_vendor 
					  WHERE vendor_id=p_login_id)
			THEN
				INSERT INTO enlistment.t_device_manufacturer_cum_vendor
					Select state_id, cin, vendor_id, manufacturer_name, building_no, 
					street, city, pin, manufacturer_state_id, 
					manufacturer_district_id, landline, faxno, 
					mobile_no_1, mobile_no_2, email_id_1, email_id_2, 
					testing_agency_id, contact_person_name, device_modal, 
					imei, vehicle_reg_no, primary_misdn, fallback_misdn, 
					esim_provider, icc_id, tac_documents, cop_date, 
					signed_reg_document, registration_date, approval_letter, 
					approval_letter_no, approval_date, is_approved, 
					updation_date, insert_or_update_by, ip_address, terms_n_conditions 
					FROM temp.t_device_manufacturer_cum_vendor 
					Where vendor_id=p_login_id;
				
				INSERT INTO enlistment.t_enlist_related_docs(stateid, login_id, msme_certificate, 
					pan_card, gst_certificate, asi140_certificate, product_brochure, 
					company_profile, bank_guarantee, insertiondatetime, 
					ipaddress)
					Select stateid::smallint, login_id, msme_certificate, pan_card, 
					gst_certificate, asi140_certificate, product_brochure, 
					company_profile, bank_guarantee, insertiondatetime, 
					ipaddress FROM temp.t_enlist_related_docs 
					Where login_id=p_login_id;
					
				INSERT INTO public.t_vendor_command_mapping
					Select vendor_id, command_id, command_syntax, success_status, 
					supported_mode, command_name, updated_by, updated_ip, 
					updated_on, device_model FROM temp.t_vendor_command_mapping 
					Where vendor_id=p_login_id AND device_model=p_device_model;
				
				_msg := 'Manufacturer Registred successfully for Enlistment.';
				_response := 'success';

			ELSE
				_msg := 'This vendor Id already exist.';
				_response := 'fail';
			END IF;

			EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_login_id,p_ip_address);	
				END;
END;
$BODY$;


---------------------------------------------------------------------------------------------------------------


-- Correction in procedure msg

CREATE OR REPLACE PROCEDURE temp.add_manufacture_data_for_enlistment(
	IN p_state_id smallint,
	IN p_manufacturer_name character varying,
	IN p_building_no character varying,
	IN p_street character varying,
	IN p_city character varying,
	IN p_pin character varying,
	IN p_state smallint,
	IN p_district smallint,
	IN p_name_of_contact_person character varying,
	IN p_landline character varying,
	IN p_fax_no character varying,
	IN p_mobile_no1 character,
	IN p_mobile_no2 character,
	IN p_email_id1 character varying,
	IN p_email_id2 character varying,
	IN p_vendor_id character varying,
	IN p_testing_agency character,
	IN p_cop_date date,
	IN p_insert_or_update_by character varying,
	IN p_cin character,
	IN p_terms_n_conditions integer,
	IN p_tac_documents bytea DEFAULT NULL::bytea,
	IN p_signed_reg_document bytea DEFAULT NULL::bytea,
	IN p_ip_address character varying DEFAULT ''::character varying,
	INOUT _msg text DEFAULT NULL::text,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN
		IF NOT EXISTS(SELECT vendor_id AS vendor_id FROM temp.t_device_manufacturer_cum_vendor 
					  WHERE vendor_id=p_vendor_id)
			THEN
				INSERT INTO temp.t_device_manufacturer_cum_vendor
			   (
			   cin, state_id, manufacturer_name, building_no,
			   street, city, pin, manufacturer_state_id, manufacturer_district_id,
			   contact_person_name, landline, faxno, mobile_no_1, mobile_no_2,
			   email_id_1, email_id_2, vendor_id, testing_agency_id,
			   tac_documents, cop_date, signed_reg_document,			   
			   registration_date, ip_address, insert_or_update_by
			   )VALUES (upper(p_cin),p_state_id,upper(p_manufacturer_name),upper(p_building_no),
				upper(p_street),upper(p_city),p_pin,p_state,p_district,
				upper(p_name_of_contact_person),p_landline,p_fax_no,p_mobile_no1,p_mobile_no2,
				lower(p_email_id1),lower(p_email_id2),upper(p_vendor_id),p_testing_agency,
				p_tac_documents,p_cop_date,p_signed_reg_document,now(),p_ip_address,p_insert_or_update_by
				);

				_msg := 'Add details successfully.';
				_response := 'success';

			ELSE
				_msg := 'This vendor Id already exist.';
				_response := 'fail';
			END IF;

			EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;
END;
$BODY$;

-----------------------------------------------------------------------------------------------------

--Date: 3-04-2024

-- Function Correction


-- FUNCTION: enlistment.f_list_device_manufacturer_cum_vendor_details_by_cin(character)

-- DROP FUNCTION IF EXISTS enlistment.f_list_device_manufacturer_cum_vendor_details_by_cin(character);

CREATE OR REPLACE FUNCTION enlistment.f_list_device_manufacturer_cum_vendor_details_by_cin(
	par_cin character)
    RETURNS TABLE(val_id integer, val_state_id smallint, val_cin character, val_vendor_id character varying, val_manufacturer_name character varying, val_building_no character varying, val_street character varying, val_city character varying, val_pin character, val_manufacturer_state_id smallint, val_manufacturer_district_id smallint, val_landline character varying, val_faxno character varying, val_mobile_no_1 character, val_mobile_no_2 character, val_email_id_1 character varying, val_email_id_2 character varying, val_testing_agency_id character, val_contact_person_name character varying, val_device_modal character varying, val_imei character, val_vehicle_reg_no character varying, val_primary_misdn character varying, val_fallback_misdn character varying, val_esim_provider character, val_icc_id character varying, val_cop_date date, val_registration_date timestamp without time zone, val_approval_letter_no character varying, val_approval_date date, val_is_approved character, val_updation_date timestamp without time zone, val_insert_or_update_by character varying, val_ip_address character varying, val_terms_n_conditions integer) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN					  	      

RETURN QUERY

	Select id,state_id, cin, vendor_id, manufacturer_name, building_no, street, 
			city, pin, manufacturer_state_id, manufacturer_district_id, landline, 
			faxno, mobile_no_1, mobile_no_2, email_id_1, email_id_2, testing_agency_id, 
			contact_person_name, device_modal, imei, vehicle_reg_no, primary_misdn, 
			fallback_misdn, esim_provider, icc_id, cop_date, registration_date, 
			approval_letter_no, approval_date, is_approved, updation_date, 
			insert_or_update_by, ip_address, terms_n_conditions 
			From enlistment.t_device_manufacturer_cum_vendor Where cin = par_cin;

END;
$BODY$;


------------------------------------------------------------------

-- New Procedure

-- Date: 24-4-2024


CREATE OR REPLACE PROCEDURE public.update_user_namemail(
	p_state_id integer,
	p_name character varying,
	p_email character varying,
	p_login_id character varying,
	p_ip_address character varying)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;

BEGIN
	BEGIN
		UPDATE public.users SET name = p_name,
							email = p_email
			WHERE login_id=p_login_id;
		
		EXCEPTION
			WHEN others THEN 
			ROLLBACK;
			get stacked diagnostics
			v_state   = returned_sqlstate,
			v_msg     = message_text,
			v_detail  = pg_exception_detail,
			v_hint    = pg_exception_hint,
			v_context = pg_exception_context;                
			raise notice E'Got exception:
			state  : %
			message: %
			detail : %
			hint   : %
			context: %', v_state, v_msg, v_detail, v_hint, v_context;
			INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_login_id,p_ip_address);	
			END;	
		

END;
$BODY$;


-------------------------------------------------------------------------------------------


-- Date: 1-5-2024

-- Changes in Procedure


CREATE OR REPLACE PROCEDURE public.add_or_edit_vltd_cum_vehicle_details(
	p_state_id smallint,
	p_imei_no character,
	p_device_serial_no character varying,
	p_icc_id character varying,
	p_chassis_no character,
	p_engine_no character varying,
	p_date_of_registration character,
	p_regn_no character varying,
	p_veh_class character varying,
	p_model_name character varying,
	p_maker_name character varying,
	p_fitment_centre_name character varying,
	p_owner_name character varying,
	p_gnss_constellation_code character varying,
	p_tac_no character varying,
	p_tac_valid_upto character,
	p_device_activation_status character varying,
	p_ip_address character varying,
	p_rfc_id character,
	p_vendor_id character varying,
	p_is_successful_upload character varying DEFAULT 'No'::character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_server_date_time TIMESTAMP(3)=NOW();
	v_state_short_name_current CHAR(2)=NULL;
	v_state_short_name_old CHAR(2)=NULL;
BEGIN
	BEGIN
  	IF NOT EXISTS(SELECT imei AS imei FROM t_vltd_cum_vehicle_details WHERE imei=p_imei_no)
    	THEN
  		INSERT INTO t_vltd_cum_vehicle_details
	  	(
		   state_id,imei,device_serial_no,icc_id,chassis_no,engine_no,date_of_registration,vehicle_reg_no,vehicle_class,model_name,maker_name,
		   fitment_centre_name,owner_name,gnss_constellation_code,tac_no,tac_valid_upto,device_activation_status,created_at,rfc_id,vendor_id,created_by_ip
	  	)
	  	VALUES
	  	(
	       p_state_id,p_imei_no,p_device_serial_no,p_icc_id,p_chassis_no,p_engine_no,p_date_of_registration,p_regn_no,UPPER(p_veh_class),p_model_name,p_maker_name,
		   p_fitment_centre_name,p_owner_name,p_gnss_constellation_code,p_tac_no,p_tac_valid_upto,'PENDING',v_server_date_time,p_rfc_id,p_vendor_id,p_ip_address
	  	);
		_response := 'Record Saved Successfully.';
	ELSE
	      UPDATE t_vltd_cum_vehicle_details SET chassis_no=p_chassis_no,date_of_registration=p_date_of_registration,device_activation_status=p_device_activation_status,device_serial_no=p_device_serial_no,
		  engine_no=p_engine_no,fitment_centre_name=p_fitment_centre_name,gnss_constellation_code=p_gnss_constellation_code,icc_id=p_icc_id,imei=p_imei_no,maker_name=p_maker_name,model_name=p_model_name,
		  owner_name=p_owner_name,vehicle_reg_no=p_regn_no,tac_no=p_tac_no,tac_valid_upto=p_tac_valid_upto,vehicle_class=UPPER(p_veh_class),updated_at=v_server_date_time,rfc_id=p_rfc_id,vendor_id=p_vendor_id
		  WHERE imei=p_imei_no;
          SELECT RTRIM(state_short_name_current),RTRIM(state_short_name_old) INTO v_state_short_name_current, v_state_short_name_old FROM t_state_master WHERE state_id=p_state_id;

		  IF(UPPER(p_device_activation_status)='ACTIVATED' AND SUBSTRING(p_regn_no,1,2) IN(v_state_short_name_current,v_state_short_name_old))
		    THEN
			  UPDATE t_device_status_details SET vehicle_reg_no=p_regn_no,activate_status='ACTIVATED',updated_at=v_server_date_time WHERE imei=p_imei_no;
		  END IF;

		  IF(UPPER(p_is_successful_upload)='YES')
		  THEN
				UPDATE t_vltd_activation_details SET device_activation_status=p_device_activation_status WHERE imei=p_imei_no;
				UPDATE t_device_status_details SET activate_status=p_device_activation_status,vehicle_reg_no=p_regn_no WHERE imei=p_imei_no;
          END IF;
		  _response := 'Record Updated Successfully.,' || p_device_activation_status;
	END IF;  
	
	
		  EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong. Please contact to System Administrator.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA',p_ip_address);	
				END;
END;
$BODY$;

--------------------------------------------------------------------------------------------------------


-- Date: 7-5-2024

-- Changes in function

CREATE OR REPLACE FUNCTION enlistment.f_list_manufacutre_data(
	par_vendor_id character varying DEFAULT NULL::character varying,
	par_device_modal character varying DEFAULT NULL::character varying,
	par_imei character DEFAULT NULL::character(1))
    RETURNS TABLE(val_id integer, val_manufacturer_name character varying, val_vendor_id character varying, val_mobile_no_1 character, val_email_id_1 character varying, val_contact_person_name character varying, val_device_modal character varying, val_vehicle_reg_no character varying, val_imei character, val_date_of_registration text, val_is_pvt_data_received text, val_is_emg_data_received text, val_is_lgn_data_received text, val_is_hel_data_received text, val_is_approved character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
		IF(par_vendor_id='') THEN par_vendor_id=NULL; END IF;
		IF(par_device_modal='') THEN par_device_modal=NULL; END IF;
		IF(par_imei='') THEN par_imei=NULL; END IF;
 RETURN QUERY 
 				
				SELECT
				DM.id,
				manufacturer_name,
				DM.vendor_id,
				mobile_no_1,
				email_id_1,
				contact_person_name, 
				device_modal,
				DM.vehicle_reg_no,
				DM.imei,
				date_of_registration,
				CASE WHEN TL.imei IS NULL THEN 'N' ELSE 'Y' END AS is_pvt_data_received,
				CASE WHEN E.imei IS NULL THEN 'N' ELSE 'Y' END AS is_emg_data_received,
				CASE WHEN L.imei IS NULL THEN 'N' ELSE 'Y' END AS is_lgn_data_received,
				CASE WHEN H.imei IS NULL THEN 'N' ELSE 'Y' END AS is_hel_data_received,
				DM.is_approved
				 FROM
				 (
					 SELECT mcv.id,manufacturer_name,contact_person_name,mobile_no_1 ,email_id_1,vendor_id ,device_modal,vehicle_reg_no,
					 imei, 
					 mcv.is_approved ,
					 to_char(registration_date::timestamp, 'dd-mm-yyyy') as date_of_registration
					 FROM enlistment.t_device_manufacturer_cum_vendor AS mcv WHERE (par_vendor_id IS NULL OR vendor_id=par_vendor_id) 
					 AND (par_device_modal IS NULL OR device_modal=par_device_modal) AND (par_imei IS NULL OR imei=par_imei)
				) AS DM LEFT OUTER JOIN enlistment.t_vltd_pvt_pkt_latest AS TL ON DM.imei=TL.imei LEFT OUTER JOIN
				 (
					  SELECT imei,COUNT(1) AS total_packet FROM enlistment.t_vltd_emg_pkt_latest GROUP BY imei
				 ) AS E ON E.imei=DM.imei Left OUTER JOIN 
				 (
					  SELECT imei,COUNT(1) AS total_packet FROM enlistment.t_vltd_login_pkt_latest GROUP BY imei
				 ) AS L ON L.imei=DM.imei LEFT OUTER JOIN (
					  SELECT imei,COUNT(1) AS total_packet FROM enlistment.t_vltd_health_pkt_latest GROUP BY imei
				 ) AS H ON H.imei=DM.imei

				WHERE (par_vendor_id IS NULL OR  DM.vendor_id=par_vendor_id);
END;
$BODY$;

----------------------------------------------------------------------------------------------------

-- Date: 7-05-2024

-- Changes in function

CREATE OR REPLACE FUNCTION enlistment.f_get_enlist_related_docs_by_id(
	par_id character varying)
    RETURNS TABLE(val_id integer,val_msme_certificate bytea, val_pan_card bytea, val_gst_certificate bytea, val_asi140_certificate bytea, val_product_brochure bytea, val_company_profile bytea, val_bank_guarantee bytea) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN
					  	
    RETURN QUERY

    SELECT id,msme_certificate,pan_card,gst_certificate,asi140_certificate,
			product_brochure,company_profile,bank_guarantee 
			FROM enlistment.t_enlist_related_docs 		
			WHERE login_id= par_id;

END;
$BODY$;


---------------------------------------------------------------------------------------------------------------

-- Date: 8-5-2024

-- Chnages in Procedure

CREATE OR REPLACE PROCEDURE enlistment.edit_manufacture_data_for_enlisment(
	p_id integer,
	p_manufacturer_name character varying,
	p_building_no character varying,
	p_street character varying,
	p_city character varying,
	p_pin character varying,
	p_state smallint,
	p_district smallint,
	p_name_of_contact_person character varying,
	p_landline character varying,
	p_fax_no character varying,
	p_mobile_no1 character,
	p_mobile_no2 character,
	p_email_id1 character varying,
	p_email_id2 character varying,
	p_vendor_id character varying,
	p_device_modal character varying,
	p_imei character varying,
	p_vehicle_reg_no character varying,
	p_testing_agency character,
	p_imei_old character varying,
	p_vendor_id_old character varying,
	p_ip_address character varying,
	p_insert_or_update_by character varying,
	p_primary_misdn character varying,
	p_fallback_misdn character varying,
	p_esim_provider character,
	p_cin character,
	p_icc_id character varying,
	p_tac_documents bytea DEFAULT NULL::bytea,
	p_signed_reg_document bytea DEFAULT NULL::bytea,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN
   		Insert INTO enlistment.t_device_manufacturer_cum_vendor_log 
   		Select * from enlistment.t_device_manufacturer_cum_vendor where imei=p_imei_old and vendor_id=p_vendor_id_old;

   		Update enlistment.t_device_manufacturer_cum_vendor set 
   		   cin=upper(p_cin), 
		   manufacturer_name=upper(p_manufacturer_name),
           building_no=upper(p_building_no),
           street=upper(p_street),
           city=upper(p_city),
		   pin=p_pin,
		   manufacturer_state_id=p_state,
		   manufacturer_district_id=p_district,
		   contact_person_name=upper(p_name_of_contact_person),
		   landline=p_landline,
		   faxno=p_fax_no,
		   mobile_no_1=p_mobile_no1,
		   mobile_no_2=p_mobile_no2,
		   email_id_1=lower(p_email_id1),
		   email_id_2=lower(p_email_id2),
		   vendor_id=upper(p_vendor_id),
           device_modal=upper(p_device_modal),
		   imei=p_imei,
		   vehicle_reg_no=upper(p_vehicle_reg_no),
		   testing_agency_id=p_testing_agency,
		   tac_documents= case when p_tac_documents is null then tac_documents else p_tac_documents end,
		   signed_reg_document= case when p_signed_reg_document is null then signed_reg_document else p_signed_reg_document end,
           is_approved='N',
		   primary_misdn=p_primary_misdn,
		   fallback_misdn=p_fallback_misdn,
		   esim_provider=p_esim_provider,
		   updation_date=now(),
		   ip_address=p_ip_address,
		   insert_or_update_by=p_insert_or_update_by,
		   icc_id=p_icc_id 
		   where id = p_id;
	
 		_response := 'Manufacturer Registration Updated successfully.';
   
   EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;
END;
$BODY$;


-------------------------------------------------------------------------------------------


-- Date: 9-5-2024

-- New FUNCTION



CREATE OR REPLACE FUNCTION enlistment.f_get_enlist_related_docs_by_login_id(
	par_login_id character varying)
    RETURNS TABLE(val_id integer, val_msme_certificate bytea, val_pan_card bytea, val_gst_certificate bytea, val_asi140_certificate bytea, val_product_brochure bytea, val_company_profile bytea, val_bank_guarantee bytea) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN
					  	
    RETURN QUERY

    SELECT id,msme_certificate,pan_card,gst_certificate,asi140_certificate,
			product_brochure,company_profile,bank_guarantee 
			FROM enlistment.t_enlist_related_docs 		
			WHERE login_id= par_login_id;

END;
$BODY$;


---------------------------------------------------------------------------------------------------

-- Changes in Function

CREATE OR REPLACE FUNCTION enlistment.f_get_enlist_related_docs_by_id(
	par_id integer)
    RETURNS TABLE(val_id integer, val_msme_certificate bytea, val_pan_card bytea, val_gst_certificate bytea, val_asi140_certificate bytea, val_product_brochure bytea, val_company_profile bytea, val_bank_guarantee bytea) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
    
BEGIN
					  	
    RETURN QUERY

    SELECT id,msme_certificate,pan_card,gst_certificate,asi140_certificate,
			product_brochure,company_profile,bank_guarantee 
			FROM enlistment.t_enlist_related_docs 		
			WHERE id= par_id;

END;
$BODY$;

---------------------------------------------------------------------------------------------------

-- changes in procedure

CREATE OR REPLACE PROCEDURE enlistment.add_enlist_related_docs(
	p_stateid integer,
	p_login_id character varying,
	p_msme_certificate bytea,
	p_pan_card bytea,
	p_gst_certificate bytea,
	p_asi140_certificate bytea,
	p_product_brochure bytea,
	p_company_profile bytea,
	p_bank_guarantee bytea,
	p_ipaddress character varying,
	p_insertiondatetime timestamp without time zone)
LANGUAGE 'plpgsql'
AS $BODY$
Declare 
	v_roleid int;
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN	
		INSERT into enlistment.t_enlist_related_docs(stateid, login_id, msme_certificate, pan_card, gst_certificate, 
				asi140_certificate, product_brochure, company_profile, bank_guarantee, 
				insertiondatetime, ipaddress)
		VALUES(p_stateid::smallint, p_login_id, p_msme_certificate, p_pan_card, p_gst_certificate, 
				p_asi140_certificate, p_product_brochure, p_company_profile, p_bank_guarantee, 
				p_insertiondatetime, p_ipaddress);
	
		EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;

				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_stateid,0,v_state,v_msg || ' ' || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,1,now(),'NA','NA');	
				END;
	
END;
$BODY$;

----------------------------------------------------------------------------------------------------------

-- Date: 14-05-2024

-- Changes in Function

CREATE OR REPLACE FUNCTION enlistment.f_list_raw_data_enlistment_data(
	par_vendor_id character varying DEFAULT NULL::character varying,
	par_imei character DEFAULT NULL::character(1),
	par_from_date timestamp without time zone DEFAULT NULL::timestamp without time zone,
	par_to_date timestamp without time zone DEFAULT NULL::timestamp without time zone,
	par_display_length integer DEFAULT 10,
	par_display_start integer DEFAULT 0,
	par_sort_col integer DEFAULT 0,
	par_sort_dir character varying DEFAULT 'ASC'::character varying,
	par_search character varying DEFAULT ''::character varying)
    RETURNS TABLE(val_row_num bigint, val_total_count bigint, val_port_number character varying, val_raw_message text, val_total_parameter smallint, val_insert_date_time text, val_pkt_type character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
		DECLARE 
			 par_first_rec integer := par_display_start;  
    		 par_last_rec integer := par_display_start +par_display_length; 
BEGIN

	IF(par_vendor_id='') THEN par_vendor_id=NULL; END IF;
	IF(par_imei='') THEN par_imei=NULL; END IF;
	IF(par_sort_dir='') THEN par_sort_dir='ASC'; END IF;
	IF(par_search='') THEN par_search=''; END IF;
	
		CREATE TEMP TABLE IF NOT EXISTS temp_cte_10(
			port_number character varying,
			raw_message text,
			total_parameter smallint,
			pkt_type character(3),
			created_at timestamp without time zone
		);
		
		Delete from temp_cte_10;
		INSERT INTO temp_cte_10   
			Select
			port_number,
			raw_message,
			total_parameter,
			pkt_type,
			created_at 
			FROM enlistment.t_enlistment_raw_pkt 
			Where (par_imei IS NULL OR imei=par_imei) 
			AND (par_from_date IS NULL OR par_to_date IS NULL OR created_at Between par_from_date AND par_to_date )
  			ORDER BY created_at DESC fetch first 5000 rows only;

 RETURN QUERY 
			 WITH cte_temp AS  
					(  
						SELECT ROW_NUMBER() OVER (ORDER BY  

						CASE WHEN (par_sort_col = 1 and par_sort_dir='ASC')  
							 THEN created_at  
						END ASC,  
						CASE WHEN (par_sort_col = 1 and par_sort_dir='DESC')  
							 THEN created_at  
						END DESC,
						 CASE WHEN (par_sort_col = 2 and par_sort_dir='ASC')  
							 THEN pkt_type  
						END ASC,  
						CASE WHEN (par_sort_col = 2 and par_sort_dir='DESC')  
							 THEN pkt_type  
						END DESC,
						 CASE WHEN (par_sort_col = 3 and par_sort_dir='ASC')  
							 THEN total_parameter  
						END ASC,  
						CASE WHEN (par_sort_col = 3 and par_sort_dir='DESC')  
							 THEN total_parameter  
						END DESC
				  )  
					AS row_num,  
						COUNT(1) over() as total_count,  
						port_number,
						raw_message,
						total_parameter,
						concat (to_char(created_at::timestamp, 'dd/mm/yyyy') , LTRIM(RIGHT(to_char(created_at::timestamp, 'mm/dd/yy hh:mm:ss AM/PM'), 11))) AS InsertDateTime,
						pkt_type
						 FROM temp_cte_10
						 where (par_search IS NULL OR raw_message Like '%'||par_search||'%')

					)  
					
					 SELECT *  
					FROM cte_temp  
					WHERE row_num > par_first_rec and row_num <=par_last_rec;
					
					
END;
$BODY$;


---------------------------------------------------------------------------------------------------------

-- Date: 15-05-2024

-- New Function


CREATE OR REPLACE FUNCTION enlistment.f_list_consolidate_report(
	)
    RETURNS TABLE(val_imei character varying, val_vendor_id character varying, alert_1 integer, alert_2 integer, alert_3 integer, alert_4 integer, alert_5 integer, alert_6 integer, alert_7 integer, alert_8 integer, alert_9 integer, alert_10 integer, alert_11 integer, alert_12 integer, alert_13 integer, alert_14 integer, alert_15 integer, alert_16 integer, pvt text, emg text, hel text, lgn text) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY
    SELECT 
        pivot_table.imei,
        pivot_table.vendor_id,
        COALESCE(pivot_table."1", 0) AS "1",
        COALESCE(pivot_table."2", 0) AS "2",
        COALESCE(pivot_table."3", 0) AS "3",
        COALESCE(pivot_table."4", 0) AS "4",
        COALESCE(pivot_table."5", 0) AS "5",
        COALESCE(pivot_table."6", 0) AS "6",
        COALESCE(pivot_table."7", 0) AS "7",
        COALESCE(pivot_table."8", 0) AS "8",
        COALESCE(pivot_table."9", 0) AS "9",
        COALESCE(pivot_table."10", 0) AS "10",
        COALESCE(pivot_table."11", 0) AS "11",
        COALESCE(pivot_table."12", 0) AS "12",
        COALESCE(pivot_table."13", 0) AS "13",
        COALESCE(pivot_table."14", 0) AS "14",
        COALESCE(pivot_table."15", 0) AS "15",
        COALESCE(pivot_table."16", 0) AS "16",
        CASE WHEN A.imei IS NULL THEN '0' ELSE '1' END AS PVT,
        CASE WHEN E.imei IS NULL THEN '0' ELSE '1' END AS EMG,
        CASE WHEN H.imei IS NULL THEN '0' ELSE '1' END AS HEL,
        CASE WHEN L.imei IS NULL THEN '0' ELSE '1' END AS LGN
    FROM (
        SELECT *
        FROM crosstab(
            'SELECT V.imei,V.vendor_id, M.alert_id, COUNT(V.alert_id)
             FROM (
                 SELECT DISTINCT imei, alert_id, vendor_id 
                 FROM enlistment.t_vltd_pvt_pkt_history
                 WHERE imei IN (SELECT imei FROM enlistment.t_device_manufacturer_cum_vendor)
             ) V
             RIGHT JOIN public.t_message_and_alerts_master M ON V.alert_id = M.alert_id
             GROUP BY V.imei, M.alert_id, V.vendor_id
             ORDER BY V.imei, M.alert_id, V.vendor_id',
            'SELECT DISTINCT alert_id FROM public.t_message_and_alerts_master ORDER BY alert_id'
        ) AS ct (
            imei VARCHAR,
            vendor_id VARCHAR,
            "1" INTEGER,
            "2" INTEGER,
            "3" INTEGER,
            "4" INTEGER,
            "5" INTEGER,
            "6" INTEGER,
            "7" INTEGER,
            "8" INTEGER,
            "9" INTEGER,
            "10" INTEGER,
            "11" INTEGER,
            "12" INTEGER,
            "13" INTEGER,
            "14" INTEGER,
            "15" INTEGER,
            "16" INTEGER
        )
    ) pivot_table
    LEFT JOIN (
        SELECT imei 
        FROM enlistment.t_vltd_pvt_pkt_latest 
        WHERE imei IN (SELECT imei FROM enlistment.t_device_manufacturer_cum_vendor)
    ) A ON pivot_table.imei = A.imei
    LEFT JOIN (
        SELECT DISTINCT imei 
        FROM enlistment.t_vltd_emg_pkt_latest 
        WHERE imei IN (SELECT imei FROM enlistment.t_device_manufacturer_cum_vendor)
    ) E ON pivot_table.imei = E.imei
    LEFT JOIN (
        SELECT DISTINCT imei 
        FROM enlistment.t_vltd_health_pkt_latest 
        WHERE imei IN (SELECT imei FROM enlistment.t_device_manufacturer_cum_vendor)
    ) H ON pivot_table.imei = H.imei
    LEFT JOIN (
        SELECT DISTINCT imei 
        FROM enlistment.t_vltd_login_pkt_latest 
        WHERE imei IN (SELECT imei FROM enlistment.t_device_manufacturer_cum_vendor)
    ) L ON pivot_table.imei = L.imei
    WHERE pivot_table.imei IS NOT NULL;
END;
$BODY$;

--------------------------------------------------------------------------------------------------------

-- Date: 17-5-2024

-- New Function 

CREATE OR REPLACE FUNCTION public.f_list_month(
	)
    RETURNS SETOF public.t_month_master  
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 	SELECT * FROM public.t_month_master ORDER BY month_id ASC; 
END;
$BODY$;


------------------------------------------------------------------------------------------------------------

-- New Function

CREATE OR REPLACE FUNCTION public.f_list_year(
	)
    RETURNS SETOF public.t_year_master  
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 	SELECT * FROM public.t_year_master ORDER BY year_id ASC; 
END;
$BODY$;

------------------------------------------------------------------------------------

-- Date: 21-05-2024

-- New Function

CREATE OR REPLACE FUNCTION public.f_get_route_name()
    RETURNS SETOF t_route_master
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY 	
    Select * From public.t_route_master ORDER BY route_id ASC;              
END;
$BODY$;

---------------------------------------------------------------------------------

-- Date: 22-05-2024

-- New Table


CREATE TABLE IF NOT EXISTS public.t_vltd_speed_violation_alert_data
(
    imei character(15) COLLATE pg_catalog."default" NOT NULL,
    packetstatus character(1) COLLATE pg_catalog."default" NOT NULL,
    trackingdatetime timestamp without time zone NOT NULL,
    latitude double precision,
    longitude double precision,
    speed double precision,
    gpsfix character(1) COLLATE pg_catalog."default",
    ignitionstatus smallint,
    serverlogdatetime timestamp without time zone NOT NULL,
    ipaddress character varying(15) COLLATE pg_catalog."default",
    CONSTRAINT t_vltd_speed_violation_alert_data_pkey PRIMARY KEY (imei)
);


----------------------------------------------------------------------------------------

-- New Function


CREATE OR REPLACE FUNCTION public.f_list_speed_violation_vehicle(
	p_loginid character varying DEFAULT NULL::character varying,
	p_displaylength integer DEFAULT 10,
	p_displaystart integer DEFAULT 0,
	p_sortcol integer DEFAULT 0,
	p_sortdir character varying DEFAULT 'ASC'::character varying,
	p_search character varying DEFAULT ''::character varying,
	p_stateabbreviation character DEFAULT 'HR'::bpchar,
	p_fromdate timestamp without time zone DEFAULT NULL::timestamp without time zone,
	p_todate timestamp without time zone DEFAULT NULL::timestamp without time zone)
    RETURNS TABLE(val_row_num bigint, val_total_count bigint, val_imei character, val_alert_count text, val_vehclass character varying, val_ownername character varying, val_vehicle_reg_no character varying, val_owner_mobileno character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE
    v_FirstRec INT;
    v_LastRec INT;
    v_Color VARCHAR(500) := '<span style="font-weight:bold;font-size:18px; color: #dc3545">';
BEGIN
    v_FirstRec := p_displaystart;
    v_LastRec := p_displaystart + p_displaylength;

    RETURN QUERY
    WITH CTE_Temp AS (
        SELECT
            ROW_NUMBER() OVER (
                ORDER BY
                    CASE WHEN (p_sortcol = 1 AND p_sortdir = 'ASC') THEN V.vehicle_reg_no END ASC,
                    CASE WHEN (p_sortcol = 1 AND p_sortdir = 'DESC') THEN V.vehicle_reg_no END DESC,
                    CASE WHEN (p_sortcol = 2 AND p_sortdir = 'ASC') THEN P.imei END ASC,
                    CASE WHEN (p_sortcol = 2 AND p_sortdir = 'DESC') THEN P.imei END DESC,
                    CASE WHEN (p_sortcol = 4 AND p_sortdir = 'ASC') THEN vehicle_class END ASC,
                    CASE WHEN (p_sortcol = 4 AND p_sortdir = 'DESC') THEN vehicle_class END DESC
            ) AS RowNum,
            COUNT(1) OVER() AS TotalCount,
            P.imei,
            v_Color || COUNT(1)::VARCHAR || '</span>' AS AlertCount,
            vehicle_class AS VehClass,
            owner_name,
            V.vehicle_reg_no,
            owner_mobile_no
        FROM
            t_vltd_speed_violation_alert_data P
        INNER JOIN
            t_vltd_activation_details A ON P.imei = A.imei
        INNER JOIN
            t_vltd_cum_vehicle_details V ON P.imei = V.imei
        WHERE
            (p_fromdate IS NULL OR p_todate IS NULL OR P.trackingdatetime BETWEEN p_fromdate AND p_todate)
            AND (p_loginid IS NULL OR A.arto_id = p_loginid)
            AND (p_search IS NULL OR V.vehicle_reg_no LIKE '%' || p_search || '%')
        GROUP BY
            P.imei, vehicle_class, owner_name, V.vehicle_reg_no, owner_mobile_no
    )
    SELECT
        RowNum, TotalCount, imei, AlertCount, VehClass, owner_name, vehicle_reg_no, owner_mobile_no
    FROM
        CTE_Temp
    WHERE
        RowNum > v_FirstRec AND RowNum <= v_LastRec;
END;
$BODY$;


------------------------------------------------------------------------------------------------------

-- New Function

CREATE OR REPLACE FUNCTION public.f_report_speed_violation_vehicle(
	p_loginid character varying DEFAULT NULL::character varying,
	p_fromdate timestamp without time zone DEFAULT NULL::timestamp without time zone,
	p_todate timestamp without time zone DEFAULT NULL::timestamp without time zone)
    RETURNS TABLE(val_imei character, val_alertcount bigint, val_vehicleclass character varying, val_ownername character varying, val_vehicleregno character varying, val_ownermobileno character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY
    SELECT 
        P.imei, 
        COUNT(1) AS AlertCount, 
        V.vehicle_class AS "Vehicle Class", 
        V.owner_name, 
        V.vehicle_reg_no, 
        owner_mobile_no AS "Owner Mobile No"
    FROM 
        t_vltd_speed_violation_alert_data P
    INNER JOIN 
        t_vltd_activation_details A ON P.imei = A.imei
    INNER JOIN 
        t_vltd_cum_vehicle_details V ON P.imei = V.imei
    WHERE 
        (p_fromdate IS NULL OR p_todate IS NULL OR P.trackingdatetime BETWEEN p_fromdate AND p_todate)
        AND (p_loginid IS NULL OR A.arto_id = p_loginid)
    GROUP BY 
        P.imei, V.vehicle_class, V.owner_name, V.vehicle_reg_no, owner_mobile_no;
END;
$BODY$;

--------------------------------------------------------------------------------------------------------

-- Date: 24-5-2024

-- New Function 

CREATE OR REPLACE FUNCTION public.f_list_speed_violation_alert_imei_wise(
	p_imei character,
	p_login_id character varying DEFAULT NULL::character varying,
	p_displaylength integer DEFAULT 10,
	p_displaystart integer DEFAULT 0,
	p_sortcol integer DEFAULT 0,
	p_sortdir character varying DEFAULT 'ASC'::character varying,
	p_search character varying DEFAULT ''::character varying,
	p_stateabbreviation character DEFAULT 'HR'::bpchar,
	p_fromdate timestamp without time zone DEFAULT NULL::timestamp without time zone,
	p_todate timestamp without time zone DEFAULT NULL::timestamp without time zone)
    RETURNS TABLE(val_row_num bigint, val_total_count bigint, val_imei character, 
				  val_tracking_datetime text, val_serverlog_datetime text, 
				  val_location text, val_vehclass character varying, 
				  val_owner_name character varying, val_vehicle_reg_no character varying, 
				  val_owner_mobile_no character, val_speed double precision) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY
    WITH CTE_Temp AS (
        SELECT 
            ROW_NUMBER() OVER (
                ORDER BY 
                    CASE 
                        WHEN p_sortcol = 3 AND p_sortdir = 'ASC' THEN P.trackingdatetime
                        ELSE NULL
                    END ASC,
                    CASE 
                        WHEN p_sortcol = 3 AND p_sortdir = 'DESC' THEN P.trackingdatetime
                        ELSE NULL
                    END DESC,
                    CASE 
                        WHEN p_sortcol = 4 AND p_sortdir = 'ASC' THEN P.serverlogdatetime
                        ELSE NULL
                    END ASC,
                    CASE 
                        WHEN p_sortcol = 4 AND p_sortdir = 'DESC' THEN P.serverlogdatetime
                        ELSE NULL
                    END DESC
            ) AS RowNum,
            COUNT(*) OVER () AS TotalCount,
            P.imei,
            TO_CHAR(P.trackingdatetime, 'DD/MM/YYYY HH24:MI:SS') AS trackingdatetime,
            TO_CHAR(P.serverlogdatetime, 'DD/MM/YYYY HH24:MI:SS') AS serverlogdatetime,
            'http://maps.google.com/maps?q=' || P.latitude || ',' || P.longitude AS Location,
            V.vehicle_class AS VehClass,
            V.owner_name,
            V.vehicle_reg_no,
            A.owner_mobile_no,
            P.speed
        FROM t_vltd_speed_violation_alert_data P
        INNER JOIN t_vltd_activation_details A ON P.imei = A.imei
        INNER JOIN t_vltd_cum_vehicle_details V ON P.imei = V.imei
        WHERE 
            (p_login_id IS NULL OR A.arto_id = p_login_id)
            AND (p_login_id IS NULL OR A.arto_id = p_login_id)
            AND P.imei = p_imei
            AND (p_fromdate IS NULL OR p_todate IS NULL OR P.trackingdatetime BETWEEN p_fromdate AND p_todate)
            AND (p_search IS NULL OR V.vehicle_reg_no ILIKE '%' || p_search || '%')
    )
    SELECT *
    FROM CTE_Temp
    WHERE RowNum > p_displaystart AND RowNum <= p_displaystart + p_displaylength;
END;
$BODY$;


----------------------------------------------------------------------------------------------------------------

-- New Function 

CREATE OR REPLACE FUNCTION public.f_list_category_wise_activated_vltds(
	p_category character varying DEFAULT 'vendor_id'::character varying,
	p_fromdate date DEFAULT '2019-01-01'::date,
	p_uptodate date DEFAULT '2024-03-23'::date,
	p_status integer DEFAULT 1,
	p_statussearchtext character varying DEFAULT ''::character varying)
    RETURNS TABLE(val_activated_vltds bigint, val_category character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE
    v_Query TEXT;
    v_SearchQuery TEXT := '';
BEGIN
    IF p_status = 1 THEN
        v_SearchQuery := ' AND (''' || p_statussearchtext || ''' = '''' OR V2.arto_id = ''' || p_statussearchtext || ''')';
    ELSIF p_status = 2 THEN
        v_SearchQuery := ' AND (''' || p_statussearchtext || ''' = '''' OR V2.vendor_id = ''' || p_statussearchtext || ''')';
    END IF;

    v_Query := 'SELECT COUNT(1) AS ActivatedVLTDs, ' ||
               'CASE WHEN UPPER(V1.' || p_category || ') = '''' THEN ''UNREGISTRED'' ELSE V1.' || p_category || ' END AS Category ' ||
               'FROM t_vltd_cum_vehicle_details V1 ' ||
               'INNER JOIN t_vltd_activation_details V2 ON V1.imei = V2.imei ' ||
               'WHERE V1.device_activation_status = ''ACTIVATED'' ' ||
               'AND V2.device_activation_status = ''ACTIVATED'' ' ||
               'AND V2.created_at::DATE >= ' || quote_literal(p_fromdate) || ' ' ||
               'AND V2.created_at::DATE <= ' || quote_literal(p_uptodate) || ' ' ||
               v_SearchQuery || ' ' ||
               'GROUP BY V1.' || p_category || ' ' ||
               'ORDER BY V1.' || p_category;

    RETURN QUERY EXECUTE v_Query;
END;
$BODY$;


--------------------------------------------------------------------------------------------------------------

-- New Table

CREATE TABLE IF NOT EXISTS public.t_manufacturer_cum_vltd_model_block_detail
(
    blocktype integer,
    vendorid character varying(20) COLLATE pg_catalog."default" NOT NULL,
    devicemodel character varying(300) COLLATE pg_catalog."default",
    reason integer,
    remark character varying(250) COLLATE pg_catalog."default",
    blockletternumber character varying(50) COLLATE pg_catalog."default",
    blockletterdate date,
    blockletter bytea,
    insertiondate timestamp without time zone NOT NULL,
    insertionby character varying(20) COLLATE pg_catalog."default",
    updationdate timestamp without time zone,
    updationby character varying(20) COLLATE pg_catalog."default",
    CONSTRAINT t_manufacturer_cum_vltd_model_block_detail_pkey PRIMARY KEY (vendorid, insertiondate)
);



----------------------------------------------------------------------------------------------------------------

-- New Table

CREATE TABLE IF NOT EXISTS public.t_manufacturer_cum_vltd_model_block_detail_log
(
    blocktype integer,
    vendorid character varying(20) COLLATE pg_catalog."default" NOT NULL,
    devicemodel character varying(300) COLLATE pg_catalog."default" NOT NULL,
    reason integer NOT NULL,
    remark character varying(250) COLLATE pg_catalog."default" NOT NULL,
    blockletternumber character varying(50) COLLATE pg_catalog."default" NOT NULL,
    blockletter bytea NOT NULL,
    blockletterdate date NOT NULL,
    insertiondate timestamp without time zone NOT NULL,
    insertionby character varying(20) COLLATE pg_catalog."default" NOT NULL,
    updationdate timestamp without time zone,
    updationby character varying(20) COLLATE pg_catalog."default",
    logdatetime timestamp without time zone
);



-----------------------------------------------------------------------------------------------------------

-- New Function

CREATE OR REPLACE FUNCTION public.f_get_vendor_list(
	)
    RETURNS TABLE(val_vendor_id character varying, val_manufacturer_name character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY
    SELECT dmcv.vendor_id, dmcv.manufacturer_name
    FROM t_device_manufacturer_cum_vendor dmcv
    WHERE dmcv.vendor_id NOT IN (
        SELECT vendor_id 
        FROM t_vltd_model_block_details 
        WHERE block_type = '1'
    );
END;
$BODY$;


---------------------------------------------------------------------------------------------------


-- Date: 27-05-2024

-- New Function


CREATE OR REPLACE FUNCTION public.f_report_category_wise_activated_vltds(
	p_category character varying DEFAULT 'vehicle_class'::character varying,
	p_from_date date DEFAULT '2019-01-01'::date,
	p_upto_date date DEFAULT '2023-03-23'::date,
	p_status integer DEFAULT 2,
	p_status_search_text character varying DEFAULT ''::character varying)
    RETURNS TABLE(val_category character varying, val_activated_vltds bigint) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE
    query TEXT;
    search_query TEXT := '';
    header VARCHAR(50) := p_category;
BEGIN
    p_category := REPLACE(p_category, ' ', '');

    IF p_status = 1 THEN
        search_query := ' AND ($1 = '''' OR v2.arto_id = $1)';
    ELSIF p_status = 2 THEN
        search_query := ' AND ($1 = '''' OR v2.vendor_id = $1)';
    END IF;

    query := format(
        'SELECT 
            CASE WHEN UPPER(v1.%I) = '''' THEN ''UNREGISTERED'' ELSE %I END AS %I, 
            COUNT(1) AS activated_vltds 
        FROM 
            t_vltd_cum_vehicle_details v1 
        INNER JOIN 
            t_vltd_activation_details v2 
        ON 
            v1.imei = v2.imei 
        WHERE 
            v1.device_activation_status = ''ACTIVATED'' 
            AND v2.device_activation_status = ''ACTIVATED'' 
            AND v2.created_at::DATE >= $2 
            AND v2.created_at::DATE <= $3' || search_query || 
        ' GROUP BY v1.%I 
        ORDER BY v1.%I', 
        p_category, p_category, header, p_category, p_category
    );

    RETURN QUERY EXECUTE query USING p_status_search_text, p_from_date, p_upto_date;
END;
$BODY$;


------------------------------------------------------------------------------------------

-- Date: 29-5-2024

-- New Procedure


CREATE OR REPLACE PROCEDURE public.delete_retro_fitment_center(
	p_rfcid character,
	p_ipaddress character varying,
	p_login_id character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_role_id smallint;
	v_max_role_id smallint;
BEGIN
	BEGIN
	    IF EXISTS(SELECT * FROM t_retro_fitment_center_master WHERE rfc_id=p_rfcid) 
		THEN
			UPDATE t_retro_fitment_center_master 
					SET is_active = 'N' 
				WHERE rfc_id = p_rfcid;

            -- Insert into LoginLog	
			INSERT INTO t_login_log(state_id,role_id,login_id,login_password,
					username,mobile_no,email_id,is_first_time_login,last_login_time ,
    				last_login_ip,created_at, created_by, created_by_ip)
            SELECT state_id, role_id, login_id, password, 
					name, mobile_no, email, is_first_time_login, last_login_time, 
					last_login_ip, created_at, login_id, last_login_ip
            FROM users WHERE login_id = p_rfcid;

            -- Update Login
            UPDATE users 
            SET is_active = 'N' 
            WHERE login_id = p_rfcid;
			
			_response := 'Record deleted Successfully.';
		ELSE
  			_response := 'This RFC not exist.';
		END IF;
  
  
  				EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,
					exception_message,module_type,created_at,created_by,created_by_ip) 
		values(6,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,
			   	2,now(),'NA','NA');	
				END;
END;
$BODY$;

-----------------------------------------------------------------------------------------------------------

-- New Procedure



CREATE OR REPLACE PROCEDURE public.unlock_retro_fitment_center(
	p_rfcid character,
	p_ipaddress character varying,
	p_login_id character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_role_id smallint;
	v_max_role_id smallint;
BEGIN
	BEGIN
	    IF EXISTS(SELECT * FROM t_retro_fitment_center_master WHERE rfc_id=p_rfcid) 
		THEN
			UPDATE t_retro_fitment_center_master 
					SET is_active = 'Y' WHERE rfc_id = p_rfcid;

            -- Insert into LoginLog	
			INSERT INTO t_login_log(state_id,role_id,login_id,login_password,
					username,mobile_no,email_id,is_first_time_login,last_login_time ,
    				last_login_ip,created_at, created_by, created_by_ip)
            SELECT state_id, role_id, login_id, password, 
					name, mobile_no, email, is_first_time_login, last_login_time, 
					last_login_ip, created_at, login_id, last_login_ip
            FROM users WHERE login_id = p_rfcid;

            -- Update Login
            UPDATE users SET is_active = 'Y' WHERE login_id = p_rfcid;
			
			_response := 'Record unlock Successfully.';
		ELSE
  			_response := 'This RFC not exist.';
		END IF;
  
  
  				EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,
					exception_message,module_type,created_at,created_by,created_by_ip) 
		values(6,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,
			   	2,now(),'NA','NA');	
				END;
END;
$BODY$;


--------------------------------------------------------------------------------------------------------------

-- Date: 3-6-2024

-- New Function


CREATE OR REPLACE FUNCTION public.f_list_esim_provider_wise_device_status_report(
	)
    RETURNS TABLE(val_esim_provider character varying, val_total_device bigint, val_total_expired_device bigint) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$

BEGIN
 RETURN QUERY 				
				
		SELECT esim_provider,COALESCE(total_device,0) AS total_device,COALESCE(total_expired_device,0) AS total_expired_device FROM 
		(
			SELECT E.esim_provider_id, COUNT(1) AS total_device from t_device_status_details W 
			INNER JOIN t_esim_cum_vltd_inventory  E ON W.imei=E.imei 
			WHERE activate_status='ACTIVATED' GROUP BY E.esim_provider_id
		) AS D
		LEFT JOIN
		(
			SELECT E.esim_provider_id, COUNT(1) AS total_expired_device from t_device_status_details W 
			INNER JOIN  t_esim_cum_vltd_inventory  E ON W.imei=E.imei 
			WHERE activate_status='ACTIVATED' AND CAST( esim_expired_on as date)< CAST(now() as date) 
			GROUP BY E.esim_provider_id
		 ) E ON D.esim_provider_id=E.esim_provider_id 
		 RIGHT JOIN  t_esim_provider_master M ON D.esim_provider_id=M.esim_provider_id 
		 where esim_provider<>'OTHER' order by esim_provider; 

END;
$BODY$;


-----------------------------------------------------------------------------------------------

-- Date: 4-6-2024

-- New Function


CREATE OR REPLACE FUNCTION f_tsp_wise_device_status_report()
RETURNS TABLE(
    val_tsp VARCHAR,
    val_total_device bigint,
    val_total_expired_device bigint,
    val_total_fall_back_tsp_device bigint,
    val_total_fall_back_tsp_expired_device bigint
)
AS $$
BEGIN
    RETURN QUERY
    SELECT M.tsp, 
           COALESCE(D.total_device, 0) AS total_device,
           COALESCE(E.total_expired_device, 0) AS total_expired_device,
           COALESCE(A.total_fall_back_tsp_device, 0) AS total_fall_back_tsp_device,
           COALESCE(F.total_fall_back_tsp_expired_device, 0) AS total_fall_back_tsp_expired_device
    FROM 
    (
        SELECT E.primary_tsp_id, COUNT(1) AS total_device 
        FROM t_device_status_details W 
        INNER JOIN t_esim_cum_vltd_inventory E ON W.imei = E.imei
        WHERE W.activate_status = 'ACTIVATED'  
        GROUP BY E.primary_tsp_id
    ) AS D
    LEFT JOIN
    (
        SELECT E.fallback_tsp_id, COUNT(1) AS total_fall_back_tsp_device 
        FROM t_device_status_details W 
        INNER JOIN t_esim_cum_vltd_inventory E ON W.imei = E.imei 
        WHERE W.activate_status = 'ACTIVATED'  
        GROUP BY E.fallback_tsp_id
    ) A ON D.primary_tsp_id = A.fallback_tsp_id
    LEFT JOIN
    (
        SELECT E.fallback_tsp_id, COUNT(1) AS total_fall_back_tsp_expired_device 
        FROM t_device_status_details W 
        INNER JOIN t_esim_cum_vltd_inventory E ON W.imei = E.imei 
        WHERE W.activate_status = 'ACTIVATED' 
          AND CAST(E.esim_expired_on AS DATE) < NOW() 
        GROUP BY E.fallback_tsp_id
    ) F ON D.primary_tsp_id = F.fallback_tsp_id
    LEFT JOIN
    (
        SELECT E.primary_tsp_id, COUNT(1) AS total_expired_device 
        FROM t_device_status_details W 
        INNER JOIN t_esim_cum_vltd_inventory E ON W.imei = E.imei 
        WHERE W.activate_status = 'ACTIVATED' 
          AND CAST(E.esim_expired_on AS DATE) < NOW() 
        GROUP BY E.primary_tsp_id
    ) E ON D.primary_tsp_id = E.primary_tsp_id
    RIGHT JOIN t_telecom_service_provider_master M ON D.primary_tsp_id = M.tsp_id 
    ORDER BY M.tsp;
END;
$$ LANGUAGE plpgsql;

---------------------------------------------------------------------------------------------


-- New Function


CREATE OR REPLACE FUNCTION public.f_report_tsp_wise_device_status(
	)
    RETURNS TABLE(val_telecom_service_provider character varying, val_activated_device_primary_msisdn bigint, val_expired_device_primary_msisdn bigint, val_activated_device_fallback_msisdn bigint, val_expired_device_fallback_msisdn bigint) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY
    SELECT M.tsp AS telecom_service_provider,
           COALESCE(D.total_device, 0) AS activated_device_primary_MSISDN,
           COALESCE(E.total_expired_device, 0) AS expired_device_primary_MSISDN,
           COALESCE(A.total_fall_back_tsp_device, 0) AS activated_device_fallback_MSISDN,
           COALESCE(F.total_fall_back_tsp_expired_device, 0) AS expired_device_fallback_MSISDN
    FROM 
    (
        SELECT E.primary_tsp_id, COUNT(1) AS total_device 
        FROM t_device_status_details W 
        INNER JOIN t_esim_cum_vltd_inventory E ON W.imei = E.imei 
        WHERE W.activate_status = 'ACTIVATED'  
        GROUP BY E.primary_tsp_id
    ) AS D
    LEFT JOIN
    (
        SELECT E.fallback_tsp_id, COUNT(1) AS total_fall_back_tsp_device 
        FROM t_device_status_details W 
        INNER JOIN t_esim_cum_vltd_inventory E ON W.imei = E.imei 
        WHERE W.activate_status = 'ACTIVATED'  
        GROUP BY E.fallback_tsp_id
    ) A ON D.primary_tsp_id = A.fallback_tsp_id
    LEFT JOIN
    (
        SELECT E.fallback_tsp_id, COUNT(1) AS total_fall_back_tsp_expired_device 
        FROM t_device_status_details W 
        INNER JOIN t_esim_cum_vltd_inventory E ON W.imei = E.imei 
        WHERE W.activate_status = 'ACTIVATED' 
          AND CAST(E.esim_expired_on AS DATE) < NOW() 
        GROUP BY E.fallback_tsp_id
    ) F ON D.primary_tsp_id = F.fallback_tsp_id
    LEFT JOIN
    (
        SELECT E.primary_tsp_id, COUNT(1) AS total_expired_device 
        FROM t_device_status_details W 
        INNER JOIN t_esim_cum_vltd_inventory E ON W.imei = E.imei 
        WHERE W.activate_status = 'ACTIVATED' 
          AND CAST(E.esim_expired_on AS DATE) < NOW() 
        GROUP BY E.primary_tsp_id
    ) E ON D.primary_tsp_id = E.primary_tsp_id
    RIGHT JOIN t_telecom_service_provider_master M ON D.primary_tsp_id = M.tsp_id 
    ORDER BY M.tsp;
END;
$BODY$;


-----------------------------------------------------------------------------------------------------

-- Date: 5-6-2024

-- New Function


CREATE OR REPLACE FUNCTION public.f_list_device_firmware_version(
	par_display_length integer DEFAULT 10,
	par_display_start integer DEFAULT 0,
	par_sort_col integer DEFAULT 3,
	par_sort_dir character varying DEFAULT 'ASC'::character varying,
	par_search character varying DEFAULT ''::character varying,
	par_vendor_id character varying DEFAULT NULL::character varying)
    RETURNS TABLE(val_row_num bigint, val_total_count bigint, val_vehicle_reg_no character varying, val_imei character, val_firmware_version character varying, val_vendor_id character varying, val_manufacturer_name character varying, val_server_log_date_time text) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY WITH CTE_Temp AS (
        SELECT 
            ROW_NUMBER() OVER (ORDER BY 
                CASE WHEN (par_sort_col = 6 AND par_sort_dir='ASC') THEN server_log_date_time END ASC, 
                CASE WHEN (par_sort_col = 6 AND par_sort_dir='DESC') THEN server_log_date_time END DESC
            ) AS row_num,
            COUNT(1) OVER() AS total_count,
            info.vehicle_reg_no,
            T.imei,
            T.firmware_version,
            D.vendor_id,
            D.manufacturer_name,
            TO_CHAR(server_log_date_time, 'DD/MM/YYYY HH24:MI:SS') AS server_log_date_time
        FROM 
            pvt.t_vltd_pvt_pkt_latest T
        INNER JOIN 
            t_vltd_cum_vehicle_details info ON T.imei = info.imei
        INNER JOIN 
            t_vltd_activation_details VD ON T.imei = VD.imei
        INNER JOIN 
            t_device_manufacturer_cum_vendor D ON VD.vendor_id = D.vendor_id
        WHERE 
            info.device_activation_status = 'ACTIVATED' AND 
            (par_vendor_id IS NULL OR info.vendor_id = par_vendor_id) AND
            (par_search IS NULL OR
                info.vehicle_reg_no ILIKE '%' || par_search || '%' OR
                T.imei ILIKE '%' || par_search || '%' OR
                T.firmware_version ILIKE '%' || par_search || '%' OR
                D.vendor_id ILIKE '%' || par_search || '%' OR
                D.manufacturer_name ILIKE '%' || par_search || '%')
    )
    SELECT *
    FROM CTE_Temp
    WHERE row_num > par_display_start AND row_num <= (par_display_start + par_display_length);
END; 
$BODY$;



--------------------------------------------------------------------------------------------------------


-- Date: 24-06-2024

-- New Function 

CREATE OR REPLACE FUNCTION f_report_device_firmware_version(p_vendor_id VARCHAR DEFAULT NULL)
RETURNS TABLE (
    val_vehicle_reg_no VARCHAR,
    val_imei CHAR,
    val_firmware_version VARCHAR,
    val_vendor_id VARCHAR,
    val_manufacturer_name VARCHAR,
    val_server_log_datetime TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        info.vehicle_reg_no AS vehicle_reg_no,
        t.imei,
        t.firmware_version,
        d.vendor_id AS vendor_id,
        d.manufacturer_name,
        TO_CHAR(t.server_log_date_time, 'DD/MM/YYYY HH24:MI:SS') AS server_log_date_time
    FROM 
        pvt.t_vltd_pvt_pkt_latest t
    INNER JOIN 
        t_vltd_cum_vehicle_details info ON t.imei = info.imei    
    INNER JOIN 
        t_vltd_activation_details vd ON t.imei = vd.imei
    INNER JOIN 
        t_device_manufacturer_cum_vendor d ON vd.vendor_id = d.vendor_id
    WHERE  
        info.device_activation_status = 'ACTIVATED' AND 
        (p_vendor_id IS NULL OR info.vendor_id = p_vendor_id)
    ORDER BY 
        t.server_log_date_time DESC;
END;
$$ LANGUAGE plpgsql;


-----------------------------------------------------------------------------------

-- New function


CREATE OR REPLACE FUNCTION f_list_vltd_not_sending_login_data(
    p_display_length INT DEFAULT 10,
    p_display_start INT DEFAULT 0,
    p_sort_col INT DEFAULT 3,
    p_sort_dir VARCHAR DEFAULT 'DESC',
    p_search VARCHAR DEFAULT NULL
)
RETURNS TABLE (
	val_row_num BIGINT,
	val_total_count BIGINT,
    val_vendor_id VARCHAR,
    val_manufacturer_name VARCHAR,
    val_device_serial_no CHAR,
    val_vehicle_reg_no VARCHAR,
    val_chassis_no VARCHAR,
    val_imei CHAR,
    val_owner_name VARCHAR,
    val_owner_mobile_no CHAR,
    val_artoid VARCHAR,
    val_date_time text
) AS $$
DECLARE
    first_rec INT := p_display_start;
    last_rec INT := p_display_start + p_display_length;
BEGIN
    RETURN QUERY
    WITH cte_temp AS (
        SELECT 
            ROW_NUMBER() OVER (ORDER BY 
                CASE WHEN p_sort_col = 3 AND p_sort_dir = 'ASC' THEN e.imei END ASC,
                CASE WHEN p_sort_col = 3 AND p_sort_dir = 'DESC' THEN e.imei END DESC
            ) AS rownum,
            COUNT(1) OVER() AS totalcount,
            a.vendor_id,
            dm.manufacturer_name,
            v.device_serial_no,
            v.vehicle_reg_no,
            v.chassis_no,
            e.imei,
            v.owner_name,
            a.owner_mobile_no,
            ro.arto AS artoid,
            TO_CHAR(e.server_log_date_time, 'DD/MM/YYYY HH24:MI:SS') AS datetime
        FROM pvt.t_vltd_pvt_pkt_latest e
        INNER JOIN t_vltd_cum_vehicle_details v ON e.imei = v.imei
        INNER JOIN t_vltd_activation_details a ON v.imei = a.imei
        INNER JOIN f_view_registration_office ro ON ro.arto_id = a.arto_id
        INNER JOIN t_device_manufacturer_cum_vendor dm ON v.vendor_id = dm.vendor_id
        WHERE e.imei NOT IN (SELECT imei FROM pvt.t_vltd_login_pkt_latest)
        AND (
            p_search IS NULL OR
            v.vehicle_reg_no ILIKE '%' || p_search || '%' OR
            v.imei ILIKE '%' || p_search || '%' OR
            v.chassis_no ILIKE '%' || p_search || '%' OR
            v.device_serial_no ILIKE '%' || p_search || '%' OR
            a.vendor_id ILIKE '%' || p_search || '%' OR
            dm.manufacturer_name ILIKE '%' || p_search || '%'
        )
    )
    SELECT rownum,totalcount,
        vendor_id,
        manufacturer_name,
        device_serial_no,
        vehicle_reg_no,
        chassis_no,
        imei,
        owner_name,
        owner_mobile_no,
        artoid,
        datetime
    FROM cte_temp
    WHERE rownum > first_rec AND rownum <= last_rec
    ORDER BY totalcount DESC;
END;
$$ LANGUAGE plpgsql;


---------------------------------------------------------------------------------------------

-- New Function

CREATE OR REPLACE FUNCTION f_list_vltd_not_sending_login_data_report()
RETURNS TABLE (
    val_vehicle_reg_no VARCHAR,
    val_imei CHAR,
    val_device_serial_no CHAR,
    val_chassis_no VARCHAR,
    val_owner_name VARCHAR,
    val_owner_mobile_no CHAR,
    val_registration_office CHAR,
    val_vendor_id VARCHAR,
    val_manufacturer_name VARCHAR,
    val_last_pvt_datetime text
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        v.vehicle_reg_no,
        e.imei,
        v.device_serial_no AS device_serial_no,
        v.chassis_no AS chassis_no,
        v.owner_name AS owner_name,
        a.owner_mobile_no AS owner_mobile_no,
        a.arto_id AS registration_office,
        a.vendor_id AS vendor_id,
        dm.manufacturer_name AS manufacturer_name,
        TO_CHAR(e.server_log_date_time, 'DD/MM/YYYY HH24:MI:SS') AS last_pvt_datetime
    FROM 
        pvt.t_vltd_pvt_pkt_latest e
    INNER JOIN 
        t_vltd_cum_vehicle_details v ON e.imei = v.imei
    INNER JOIN 
        t_vltd_activation_details a ON v.imei = a.imei
    INNER JOIN 
        t_device_manufacturer_cum_vendor dm ON v.vendor_id = dm.vendor_id
    WHERE  
        e.imei NOT IN (SELECT imei FROM pvt.t_vltd_login_pkt_latest)
    ORDER BY 
        e.server_log_date_time DESC;
END;
$$ LANGUAGE plpgsql;


--------------------------------------------------------------------------------------------------------

-- Date: 25-06-2024

-- Changes in Procedure

CREATE OR REPLACE PROCEDURE public.add_manufacturer_login_and_approved_vltd_model(
	p_state_id smallint,
	p_vendor_id character varying,
	p_vendor_name character varying,
	p_contact_person character varying,
	p_mobile_no character,
	p_email_id character varying,
	p_approved_device_modal character varying,
	p_cop_date date,
	p_ip_address character varying,
	p_login_id character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
       DECLARE
	    v_state   TEXT;
		v_msg     TEXT;
		v_detail  TEXT;
		v_hint    TEXT;
		v_context TEXT;
	   	v_approved_device_modals VARCHAR(300)=NULL;
		v_password CHAR(64)=NULL;
BEGIN
	BEGIN

   	SELECT TRIM(LTRIM(approved_device_modal)) INTO v_approved_device_modals FROM t_device_manufacturer_cum_vendor WHERE vendor_id=p_vendor_id;
	   IF (v_approved_device_modals IS NULL)
	   THEN
			SELECT * INTO v_Password FROM f_udf_convert_to_sha256(UPPER(SUBSTRING(p_vendor_id,1,1)) || LOWER(SUBSTRING(p_vendor_id,2,2))||'@'|| RIGHT(p_mobile_no,4));
			INSERT INTO t_device_manufacturer_cum_vendor
				   (	
						state_id,vendor_id,manufacturer_name,contact_person_name,mobile_no,email_id,approved_device_modal,is_active,created_by_ip,created_at
				   )
			VALUES (p_state_id,p_vendor_id,p_vendor_name,p_contact_person,p_mobile_no,p_email_id,p_approved_device_modal,'Y',p_ip_Address,NOW());

			INSERT INTO t_device_model(vendor_id,device_model,cop_date,created_at)Values(p_vendor_id,p_approved_device_modal,p_cop_date,NOW());

			IF NOT EXISTS(SELECT login_id FROM users WHERE login_id=p_vendor_id)
			  THEN 
 				/*	INSERT INTO t_login(state_id,username,role_id,login_id,login_password,mobile_no,email_id,is_first_time_login,created_at)
				 VALUES(p_state_id,p_vendor_name,4,p_vendor_id,v_password,p_mobile_no,p_email_id,'Y',NOW()); */
				 
				 UPDATE users SET role_id=4, username=p_vendor_name, login_password=v_password,
				 		mobile_no=p_mobile_no, email_id=p_email_id, is_first_time_login='Y',
						created_at=NOW() WHERE login_id=p_vendor_id;
				 
			END IF;
		    _response:= 'VLTD model ('||p_approved_device_modal||') has been approved and manufacturer login created successfully.,'||UPPER(SUBSTRING(p_vendor_id,1,1))+LOWER(SUBSTRING(p_vendor_id,2,2))||'@'|| RIGHT(p_mobile_no,4);

	   ELSE
			    IF NOT EXISTS(SELECT item FROM f_udf_split_string(COALESCE(v_approved_device_modals,''),',') WHERE item=p_approved_device_modal)THEN
					  
					     v_approved_device_modals:=UPPER(v_approved_device_modals||','||RTRIM(LTRIM(p_approved_device_modal)));
						 UPDATE t_device_manufacturer_cum_vendor SET approved_device_modal=v_approved_device_modals WHERE vendor_id=p_vendor_id;
 							
							_response:='VLTD model ('||p_approved_device_modal||') has been approved successfully and added in model list of manufacturer.';
 						
						INSERT INTO t_device_model(vendor_id,device_model,cop_date,created_at)Values(p_vendor_id,p_approved_device_modal,p_cop_date,NOW());
			    ELSE
				 _response:='VLTD model ('||p_approved_device_modal||') is already approved.';
				END IF;
		END IF;	
		
		
		EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
				_response := 'Something went wrong. Please Contact to System Administrator.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_login_id,p_ip_address);	
				END;
END;
$BODY$;



--------------------------------------------------------------------------------------------------------

-- Create New Function 

CREATE OR REPLACE FUNCTION f_list_vltd_not_sending_health_data(
    p_display_length INT DEFAULT 10,
    p_display_start INT DEFAULT 0,
    p_sort_col INT DEFAULT 3,
    p_sort_dir VARCHAR(10) DEFAULT 'DESC',
    p_search VARCHAR(255) DEFAULT NULL
)
RETURNS TABLE (
	val_row_num BIGINT,
	val_total_count BIGINT,
    val_vendor_id VARCHAR,
    val_manufacturer_name VARCHAR,
    val_device_serial_no CHAR,
    val_vehicle_reg_no VARCHAR,
    val_chassis_no VARCHAR,
    val_imei CHAR,
    val_owner_name VARCHAR,
    val_owner_mobile_no CHAR,
    val_artoid CHAR,
    val_date_time text
		
) AS $$
DECLARE
    FirstRec INT := p_display_start;
    LastRec INT := p_display_start + p_display_length;
BEGIN
    RETURN QUERY
    WITH CTE_TEMP AS (
        SELECT
            ROW_NUMBER() OVER (ORDER BY
                CASE WHEN (p_sort_col = 2 AND p_sort_dir = 'ASC') THEN E.imei END ASC,
                CASE WHEN (p_sort_col = 2 AND p_sort_dir = 'DESC') THEN E.imei END DESC,
                CASE WHEN (p_sort_col = 10 AND p_sort_dir = 'ASC') THEN E.tracking_date_time END ASC,
                CASE WHEN (p_sort_col = 10 AND p_sort_dir = 'DESC') THEN E.tracking_date_time END DESC
            ) AS rownum,
            COUNT(*) OVER() AS totalcount,
            A.vendor_id,
            DM.manufacturer_name,
            V.device_serial_no,
            V.vehicle_reg_no,
            V.chassis_no,
            E.imei,
            V.owner_name,
            A.owner_mobile_no,
            RO.arto_id,
            TO_CHAR(E.server_log_date_time, 'DD/MM/YYYY HH24:MI:SS') AS datetime
        FROM
            pvt.t_vltd_pvt_pkt_latest E
            INNER JOIN t_vltd_cum_vehicle_details V ON E.imei = V.imei
            INNER JOIN t_vltd_activation_details A ON V.imei = A.imei
            INNER JOIN f_view_registration_office RO ON RO.arto_id = A.arto_id
            INNER JOIN t_device_manufacturer_cum_vendor DM ON V.vendor_id = DM.vendor_id
        WHERE
            E.imei NOT IN (SELECT imei FROM pvt.t_vltd_health_pkt_latest)
            AND (
                p_search IS NULL OR
                V.vehicle_reg_no ILIKE '%' || p_search || '%' OR
                V.imei ILIKE '%' || p_search || '%' OR
                V.chassis_no ILIKE '%' || p_search || '%' OR
                V.device_serial_no ILIKE '%' || p_search || '%' OR
                A.vendor_id::TEXT ILIKE '%' || p_search || '%' OR
                DM.manufacturer_name ILIKE '%' || p_search || '%'
            )
    )
    SELECT
		rownum,
		totalcount,
        vendor_id,
        manufacturer_name,
        device_serial_no,
        vehicle_reg_no,
        chassis_no,
        imei,
        owner_name,
        owner_mobile_no,
        arto_id,
        datetime
    FROM
        CTE_TEMP
    WHERE
        rownum > FirstRec AND rownum <= LastRec
    ORDER BY
        totalcount DESC;
END;
$$ LANGUAGE plpgsql;


------------------------------------------------------------------------------------------------------


-- Create new Function


CREATE OR REPLACE FUNCTION f_list_vltd_not_sending_health_data_report()
RETURNS TABLE (
    val_vehicle_reg_no VARCHAR,
    val_imei CHAR,
    val_device_serial_no CHAR,
    val_chassis_no VARCHAR,
    val_owner_name VARCHAR,
    val_owner_mobile_no CHAR,
    val_registration_office CHAR,
    val_vendor_id VARCHAR,
    val_manufacturer_name VARCHAR,
    val_last_pvt_datetime text
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        v.vehicle_reg_no,
        e.imei,
        v.device_serial_no AS device_serial_no,
        v.chassis_no AS chassis_no,
        v.owner_name AS owner_name,
        a.owner_mobile_no AS owner_mobile_no,
        a.arto_id AS registration_office,
        a.vendor_id AS vendor_id,
        dm.manufacturer_name AS manufacturer_name,
        TO_CHAR(e.server_log_date_time, 'DD/MM/YYYY HH24:MI:SS') AS last_pvt_date_time
    FROM 
        pvt.t_vltd_pvt_pkt_latest e
    INNER JOIN 
        t_vltd_cum_vehicle_details v ON e.imei = v.imei
    INNER JOIN 
        t_vltd_activation_details a ON v.imei = a.imei
    INNER JOIN 
        t_device_manufacturer_cum_vendor dm ON v.vendor_id = dm.vendor_id
    WHERE  
        e.imei NOT IN (SELECT imei FROM pvt.t_vltd_health_pkt_latest)
    ORDER BY 
        e.server_log_date_time DESC;
END;
$$ LANGUAGE plpgsql;



------------------------------------------------------------------------------------------------


-- Date: 28-06-2024


CREATE TABLE IF NOT EXISTS public.t_web_application_exception_logs
(    
	errorlogno BIGSERIAL NOT NULL,        
	logdatetime timestamp(0) without time zone NOT NULL,
    type character varying(191) COLLATE pg_catalog."default" NOT NULL,
    message text COLLATE pg_catalog."default",
    targetsite text COLLATE pg_catalog."default" NOT NULL,
    requesturl text COLLATE pg_catalog."default" NOT NULL,
    useragent text COLLATE pg_catalog."default" NOT NULL,
    userip text COLLATE pg_catalog."default" NOT NULL,
    userauthentication character varying(191) COLLATE pg_catalog."default" NOT NULL,
    loginid bigint NOT NULL, 
    CONSTRAINT webapplicationexceptionlog_pkey PRIMARY KEY (errorlogno)
)


----------------------------------------------------------------------------------------------------

-- Create new Function

CREATE OR REPLACE FUNCTION f_list_web_application_exception_log(
    p_month_id INT DEFAULT NULL,		
    p_date DATE DEFAULT NULL,
    p_to_date DATE DEFAULT NULL,
    p_year CHAR(4) DEFAULT NULL,
    p_display_length INT DEFAULT 0,
    p_display_start INT DEFAULT 20,
    p_sort_col INT DEFAULT 0,
    p_sort_dir VARCHAR DEFAULT 'ASC',
    p_search VARCHAR DEFAULT ''
) 
RETURNS TABLE (
    val_row_num BIGINT,
    val_total_count BIGINT,
    val_error_log_no BIGINT,
    val_log_datetime text,
    val_type VARCHAR,
    val_message TEXT,
    val_user_ip text,
    val_request_url text,
    val_login_id bigint
) AS $$
DECLARE
    first_rec INT := p_display_start;
    last_rec INT := p_display_start + p_display_length;
BEGIN
    RETURN QUERY
    WITH cte_temp AS (
        SELECT 
            ROW_NUMBER() OVER (ORDER BY 
                CASE WHEN p_sort_col = 1 AND p_sort_dir = 'ASC' THEN logdatetime END ASC,
                CASE WHEN p_sort_col = 1 AND p_sort_dir = 'DESC' THEN logdatetime END DESC
            ) AS rownum,
            COUNT(1) OVER() AS total_count,
            errorlogno,
            TO_CHAR(logdatetime, 'DD/MM/YYYY HH24:MI:SS') AS log_datetime,
            type,
            message,
            userip,
            requesturl,
            loginid
        FROM 
            t_web_application_exception_logs
        WHERE 
            ((EXTRACT(YEAR FROM logdatetime) = p_year::INT AND EXTRACT(MONTH FROM logdatetime) = p_month_id)
            OR (logdatetime BETWEEN p_date AND p_to_date))
            AND (p_search IS NULL OR loginid::TEXT ILIKE '%' || p_search || '%')
    )
    SELECT 
        rownum AS row_num,
        total_count AS total_count,
        errorlogno AS error_log_no,
        log_datetime,
        type AS val_type,
        message AS val_message,
        userip AS val_user_ip,
        requesturl AS val_request_url,
        loginid AS val_login_id
    FROM 
        cte_temp
    WHERE 
        rownum > first_rec AND rownum <= last_rec;
END;
$$ LANGUAGE plpgsql;

---------------------------------------------------------------------------

-- New Table

CREATE TABLE t_socket_exception_log (
    type VARCHAR(50) NOT NULL,
    message VARCHAR(1024) NOT NULL,
    logdatetime TIMESTAMP NOT NULL,
    ip_address VARCHAR(15),
    packet VARCHAR(250)
);


-------------------------------------------------------------------------


-- New Function


CREATE OR REPLACE FUNCTION f_list_socket_exception_log(
    p_monthid INT DEFAULT NULL,
    p_date TIMESTAMP DEFAULT NULL,
    p_todate TIMESTAMP DEFAULT NULL,
    p_year CHAR(4) DEFAULT NULL,
    p_displaylength INT DEFAULT 10,
    p_displaystart INT DEFAULT 20,
    p_sortcol INT DEFAULT 0,
    p_sortdir VARCHAR(10) DEFAULT 'ASC',
    p_search VARCHAR(255) DEFAULT ''
)
RETURNS TABLE (
    val_rownum BIGINT,
    val_totalcount BIGINT,
    val_logdatetime text,
    val_type VARCHAR,
    val_message character varying,
	val_ip_address character varying,
	val_packet character varying
) AS $$
BEGIN
    RETURN QUERY
    WITH CTE_Temp AS (
        SELECT 
            ROW_NUMBER() OVER (
                ORDER BY
                    CASE WHEN p_sortcol = 1 AND p_sortdir = 'ASC' THEN logdatetime END ASC,
                    CASE WHEN p_sortcol = 1 AND p_sortdir = 'DESC' THEN logdatetime END DESC
            ) AS rownum,
            COUNT(*) OVER () AS totalcount,
            TO_CHAR(logdatetime, 'DD/MM/YYYY HH24:MI:SS') AS logdatetime,
            type,
            message,
		ip_address,
		packet
        FROM t_socket_exception_log
        WHERE ((EXTRACT(YEAR FROM logdatetime)::CHAR(4) = p_year AND EXTRACT(MONTH FROM logdatetime) = p_monthid) OR 
               logdatetime BETWEEN p_date AND p_todate) AND 
              (p_search IS NULL OR message ILIKE '%' || p_search || '%')
    )
    SELECT rownum, totalcount, logdatetime, type, message,
		ip_address,
		packet
    FROM CTE_Temp
    WHERE rownum > p_displaystart AND rownum <= p_displaystart + p_displaylength;
END;
$$ LANGUAGE plpgsql;


----------------------------------------------------------------------------------------------

-- Date: 01-07-2024

-- New Function

CREATE OR REPLACE FUNCTION public.get_sys_dashboard_count(
	)
    RETURNS TABLE(val_rto bigint, val_arto bigint, val_user_count bigint, val_vehicle_class bigint, val_vehicle_fuel bigint, val_role_count bigint, val_unblocked bigint, val_block_vendor bigint, val_active bigint, val_inactive bigint) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY
    SELECT 
        COALESCE((SELECT COUNT(1) FROM t_rto_master), 0) AS rto,
        COALESCE((SELECT COUNT(1) FROM t_arto_master), 0) AS arto,
        COALESCE((SELECT COUNT(1) FROM users WHERE role_id NOT IN ('4', '5')), 0) AS user_count,
        COALESCE((SELECT COUNT(1) FROM t_vehicle_type_master), 0) AS vehicle_class,
        COALESCE((SELECT COUNT(1) FROM t_vehicle_type_master), 0) AS vehicle_fuel,
        COALESCE((SELECT COUNT(1) FROM t_designation_master), 0) AS role_count,
        COALESCE((SELECT COUNT(1) FROM t_device_manufacturer_cum_vendor WHERE vendor_id NOT IN 
                 (SELECT vendor_id FROM t_vltd_model_block_details WHERE block_type = 1)), 0) AS unblocked,
        COALESCE((SELECT COUNT(1) FROM t_vltd_model_block_details WHERE block_type = 1), 0) AS block_vendor,
        COALESCE((SELECT COUNT(1) FROM users WHERE is_active = 'Y' AND role_id NOT IN ('4', '5')), 0) AS active,
        COALESCE((SELECT COUNT(1) FROM users WHERE is_active = 'N' AND role_id NOT IN ('4', '5')), 0) AS inactive;
END;
$BODY$;



---------------------------------------------------------------------------------------


-- New Function

CREATE OR REPLACE FUNCTION f_list_master_district()
RETURNS TABLE (
    val_state_id bigint ,
    val_state_name character varying,
    val_district_id bigint,
    val_district_name TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        D.state_id::bigint AS state_id,
        S.state_name AS state_name,
        D.district_id::bigint AS district_id,
        UPPER(D.district_name) AS district_name
    FROM 
        t_state_master S 
        INNER JOIN t_district_master D ON S.state_id = D.state_id
    ORDER BY 
        S.state_name, D.district_name ASC;
END;
$$ LANGUAGE plpgsql;



------------------------------------------------------------------------------------------

-- Date: 02-07-2024

-- New Table


CREATE TABLE public.t_city_master (
    state_id SMALLINT NOT NULL,
    district_id SMALLINT NOT NULL,
    city_id SERIAL PRIMARY KEY,
    city_name VARCHAR(100) NOT NULL UNIQUE
);



--------------------------------------------------------------------------

-- New FUNCTION

CREATE OR REPLACE FUNCTION public.f_list_cities(
	p_state_id smallint,
	p_district_id smallint DEFAULT null,
	p_city_id integer DEFAULT null)
    RETURNS TABLE(val_district_id smallint, val_district_name character varying, val_city_id integer, val_city_name character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY
    SELECT 
        C.district_id,
        D.district_name,
        C.city_id,
        C.city_name
    FROM 
        public.t_city_master C
        INNER JOIN public.t_district_master D ON C.district_id = D.district_id
    WHERE 
        C.state_id = p_state_id
        AND (p_district_id IS NULL OR C.district_id = p_district_id)
        AND (p_city_id IS NULL OR C.city_id = p_city_id)
    ORDER BY 
        C.city_name;
END; 
$BODY$;


----------------------------------------------------------------------------------


-- Date: 03-07-2024

-- New Procedure


CREATE OR REPLACE PROCEDURE public.add_city(
	p_state_id integer,
	p_district_id integer,
	p_city_name character varying,
	p_ip_address character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_city_id INT;
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
    
    -- Insert the new city
    INSERT INTO public.t_city_master(state_id, district_id, city_name)
    VALUES (p_state_id, p_district_id, UPPER(p_city_name));

    -- Return a response message
    _response := 'City details have saved.';
	
	
	EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
				_response := 'FAIL#Something went wrong. Please Contact to System Administrator.';
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA',p_ip_address);	
				
	
	
END;
$BODY$;


--------------------------------------------------------------------------------------

-- New Procedure


CREATE OR REPLACE PROCEDURE public.update_city(
	p_state_id integer,
	p_district_id integer,
	p_city_id integer,
	p_city_name character varying,
	p_ip_address character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE    
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
    
    -- Update city
    UPDATE public.t_city_master SET state_id = p_state_id, district_id = p_district_id, 
					city_name = p_city_name WHERE city_id = p_city_id;

    -- Return a response message
    _response := 'City details have been updated.';
	
	
	EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
				_response := 'FAIL#Something went wrong. Please Contact to System Administrator.';
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA',p_ip_address);	
						
END;
$BODY$;


-------------------------------------------------------------------------------


-- Update in Procedure


CREATE OR REPLACE PROCEDURE public.add_rto_office_details(
	p_state integer,
	p_rto_code character,
	p_rto_name character varying,
	p_ip_address character varying,
	p_login_id bigint,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_sha256_password character varying;
BEGIN 
	BEGIN
		IF NOT EXISTS(SELECT 1 FROM t_rto_master WHERE rto_id=p_rto_code)THEN
			--password generate
			SELECT * INTO v_sha256_password FROM f_udf_convert_to_sha256(p_rto_code);
		
			INSERT INTO t_rto_master(state_id,rto_type,rto_id,rto) VALUES(p_state,'1',p_rto_code,p_rto_name); 
		
			INSERT INTO users(state_id,username,role_id,login_id,password,is_first_time_login,mobile_no,email,created_at,is_active)
     		VALUES (p_state,p_rto_name,3,p_rto_code,v_sha256_password,'Y','','',NOW(),'Y');
		
			_response := 'RTO Login created Successfully and Your Login ID and Password is '|| p_rto_code;    
		ELSE
			UPDATE t_rto_master SET rto=p_rto_name Where rto_id=p_rto_code;
		
			_response := 'RTO Record Updated Successfully';
		END IF;
		
		
 			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state,p_login_id,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA',p_ip_address);	
				END;
END;
$BODY$;


------------------------------------------------------------------------------------------------------------------------

-- Date: 4-7-2024

-- Update in procedure


CREATE OR REPLACE PROCEDURE public.add_arto_office_detail(
	p_state character,
	p_type integer,
	p_rto_code character,
	p_arto_code character,
	p_arto_name character varying,
	p_created_by character varying,
	p_created_by_ip character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_sha256_password character varying;
BEGIN  
  		BEGIN 
		IF NOT EXISTS(SELECT 1 FROM t_arto_master WHERE arto_id=p_arto_code)    
		THEN   
				INSERT INTO t_arto_master(state_id,arto_type,rto_id,arto_id,arto)VALUES(p_state::smallint,p_type,p_rto_code,p_arto_code,p_arto_name);  
			 	
				-- convert password to sha256
				SELECT * INTO v_sha256_password from f_udf_convert_to_sha256(p_arto_code);
				
				INSERT INTO users(state_id,username,role_id,login_id,password,is_first_time_login,mobile_no,email,created_at,is_active)  
					 VALUES (p_state::smallint,p_arto_name,10,p_arto_code,v_sha256_password,'Y','','',now(),'Y');      
				_response := 'ARTO/DTO Login created Successfully and Your Login ID and Password is '||p_arto_code;
		ELSE  
				UPDATE t_arto_master SET arto=p_arto_name,rto_id=p_rto_code WHERE arto_id=p_arto_code;
				_response := 'ARTO/DTO Record Updated Successfully';
		END IF;  
		
		
				EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
 				_response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(0,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_created_by,p_created_by_ip);	
				END;
END;  
$BODY$;


-----------------------------------------------------------------------------------------


-- Date: 05-07-2024


-- Update in Procedure


CREATE OR REPLACE PROCEDURE public.update_esim_provider_api(
	p_esim_provider_id smallint,
	p_is_api_available character,
	p_is_api_whitelisted character,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE    
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN

	INSERT INTO t_esim_provider_master_log
		Select * from t_esim_provider_master Where esim_provider_id=p_esim_provider_id;

	UPDATE t_esim_provider_master SET is_api_available= p_is_api_available,is_api_whitelisted=p_is_api_whitelisted WHERE esim_provider_id=p_esim_provider_id;
	_response := 'Update';
	
	EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
				_response := 'FAIL#Something went wrong. Please Contact to System Administrator.';
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA',p_ip_address);	
	
END;
$BODY$;


----------------------------------------------------------------------------------------


-- Create New Table With data Import work


CREATE TABLE t_vehicle_class_master (
    vehicle_class_id SERIAL PRIMARY KEY,
    vehicle_class VARCHAR(50) NOT NULL,
    class_type VARCHAR(50),
    category VARCHAR(50) NOT NULL
    
);


------------------------------------------------------------

-- New Function 

CREATE OR REPLACE FUNCTION public.f_list_vehicle_class(
	)
    RETURNS SETOF t_vehicle_class_master 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  
BEGIN  
	RETURN QUERY 	
	SELECT * from t_vehicle_class_master ORDER BY vehicle_class ASC ;
END;
$BODY$;

---------------------------------------------------------------------------

-- New Function


CREATE OR REPLACE FUNCTION public.f_list_vehicle_fule_type(
	)
    RETURNS SETOF t_vehicle_fule_type_master 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
  
BEGIN  
	RETURN QUERY 	
	SELECT * from t_vehicle_fule_type_master ORDER BY vehicle_fule_type ASC ;
END;
$BODY$;


------------------------------------------------------------------------------------------------

-- Date: 8-7-2024

-- Update in function


-- SELECT * FROM pvt.f_list_registered_vehicle(null,null,null,null,null,10,20,0,'ASC','','UK');



CREATE OR REPLACE FUNCTION pvt.f_list_registered_vehicle(
	par_login_id character varying DEFAULT NULL::character varying,
	par_from_date timestamp with time zone DEFAULT NULL::timestamp with time zone,
	par_to_date timestamp with time zone DEFAULT NULL::timestamp with time zone,
	par_group_id integer DEFAULT NULL::integer,
	par_rto character varying DEFAULT NULL::character varying,
	par_display_length integer DEFAULT 10,
	par_display_start integer DEFAULT 20,
	par_sort_col integer DEFAULT 0,
	par_sort_dir character varying DEFAULT 'ASC'::character varying,
	par_search character varying DEFAULT ''::character varying,
	par_state_abbreviation character DEFAULT 'UK'::character(1))
    RETURNS TABLE(val_row_num bigint, val_total_count bigint, val_imei character, val_device_serial_no character, val_vendor_id character varying, val_manufacturer_name character varying, val_date_of_registration character, val_icc_id character varying, val_chasis_no character varying, val_model_name character varying, val_owner_name character varying, val_owner_address character varying, val_activation_date_time text, val_vehicle_reg_no_vlt character varying, val_vehicle_reg_no_vhn character varying, val_device_activation_status character varying, val_icc_id_valid_upto character, val_district_id smallint, val_status text, val_owner_mobile_no character, val_vlt_and_vehicle_status integer, val_rfc_id character varying, val_vehicle_fuel_type character varying, val_vehicle_class character varying, val_arto character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$

			DECLARE 
				 par_first_rec integer := par_display_start;  
				 par_last_rec integer := par_display_start + par_display_length;  
	
BEGIN

	IF(par_login_id='') THEN par_login_id=NULL; END IF;
	IF(par_group_id=0) THEN par_group_id=NULL; END IF;
	IF(par_rto='') THEN par_rto=NULL; END IF;
	
	
	IF(par_display_length=0) THEN par_display_length=10; END IF;
	IF(par_display_start=0) THEN par_display_start=20; END IF;
	IF(par_sort_col=0) THEN par_sort_col=0; END IF;
	IF(par_sort_dir='') THEN par_sort_dir='ASC'; END IF;
	IF(par_search='') THEN par_search=''; END IF;
	IF(par_state_abbreviation='') THEN par_state_abbreviation='UK'; END IF;
 RETURN QUERY 
 				  
					WITH cte_temp AS
						(
							SELECT ROW_NUMBER() OVER (ORDER BY

						   CASE WHEN (par_sort_col = 1 and UPPER(par_sort_dir)='ASC')
								 THEN P.imei
							END ASC,
							  CASE WHEN (par_sort_col = 1 and UPPER(par_sort_dir)='DESC')
								 THEN P.imei
							END DESC,
							  CASE WHEN (par_sort_col = 2 and UPPER(par_sort_dir)='ASC')
								 THEN VI.vehicle_reg_no
							END ASC,
							 CASE WHEN (par_sort_col = 2 and UPPER(par_sort_dir)='DESC')
								 THEN VI.vehicle_reg_no
							END DESC,
								  CASE WHEN (par_sort_col = 3 and UPPER(par_sort_dir)='ASC')
								 THEN V.owner_mobile_no
							END ASC,
							 CASE WHEN (par_sort_col = 3 and UPPER(par_sort_dir)='DESC')
								 THEN V.owner_mobile_no
							END DESC,
								  CASE WHEN (par_sort_col = 4 and UPPER(par_sort_dir)='ASC')
								 THEN V.device_serial_no
							END ASC,
							 CASE WHEN (par_sort_col = 4 and UPPER(par_sort_dir)='DESC')
								 THEN V.device_serial_no
							END DESC,
							 CASE WHEN (par_sort_col = 5 and UPPER(par_sort_dir)='ASC')
								 THEN VI.model_name
							END ASC,
							 CASE WHEN (par_sort_col = 5 and UPPER(par_sort_dir)='DESC')
								 THEN VI.model_name
							END DESC,
							CASE WHEN (par_sort_col = 6 and UPPER(par_sort_dir)='ASC')
								 THEN V.icc_id
							END ASC,
							 CASE WHEN (par_sort_col = 6 and UPPER(par_sort_dir)='DESC')
								 THEN V.icc_id
							END DESC,
							CASE WHEN (par_sort_col = 7 and UPPER(par_sort_dir)='ASC')
								 THEN VI.chassis_no
							END ASC,
							 CASE WHEN (par_sort_col = 7 and UPPER(par_sort_dir)='DESC')
								 THEN VI.chassis_no
							END DESC,
							CASE WHEN (par_sort_col = 8 and UPPER(par_sort_dir)='ASC')
								 THEN P.vehicle_reg_no
							END ASC,
							 CASE WHEN (par_sort_col = 8 and UPPER(par_sort_dir)='DESC')
								 THEN P.vehicle_reg_no
							END DESC,
							CASE WHEN (par_sort_col = 9 and UPPER(par_sort_dir)='ASC')
								 THEN VI.device_activation_status
							END ASC,
							 CASE WHEN (par_sort_col = 9 and UPPER(par_sort_dir)='DESC')
								 THEN VI.device_activation_status
							END DESC,
							CASE WHEN (par_sort_col = 10 and UPPER(par_sort_dir)='ASC')
								 THEN V.created_at
							END ASC,
							 CASE WHEN (par_sort_col = 10 and UPPER(par_sort_dir)='DESC')
								 THEN V.created_at
							END DESC
							)
							 AS row_num,
							 COUNT(1) over() as total_count,
							 V.imei, 
							V.device_serial_no ,
							V.vendor_id ,
							DM.manufacturer_name,
							VI.date_of_registration ,
							V.icc_id ,VI.chassis_no,
							VI.model_name,
							VI.owner_name,
							V.owner_address,
							to_char(V.created_at::timestamp,'dd/MM/yyyy HH:mm:ss'),
							P.vehicle_reg_no,
							VI.vehicle_reg_no,
							VI.device_activation_status ,
							V.icc_id_valid_upto ,
							D.district_id,
							case when P.vehicle_reg_no=VI.vehicle_reg_no then 'Matched' else 'Not Matched' end , 
							V.owner_mobile_no,
							CASE
						   /*Vehicle is registred, VLT device is activated and vehicle number set in VLT Device.*/
							WHEN SUBSTRING(COALESCE(VI.vehicle_reg_no,''),1,2) NOT IN('') AND COALESCE(VI.device_activation_status,'')='ACTIVATED' AND COALESCE(V.imei,'')=V.imei AND COALESCE(VI.vehicle_reg_no,'')=COALESCE(P.vehicle_reg_no,'')
						   THEN 1 
						/*Vehicle is registred, VLT device is activated and vehicle number is not set in VLT Device.*/
						WHEN SUBSTRING(COALESCE(VI.vehicle_reg_no,''),1,2) NOT IN('') AND COALESCE(VI.device_activation_status,'')='ACTIVATED' AND COALESCE(V.imei,'')=V.imei AND COALESCE(VI.vehicle_reg_no,'')<>COALESCE(P.vehicle_reg_no,'')
						   THEN 2 
						/*Vehicle is registred and  VLT device is not activated.*/
						WHEN SUBSTRING(COALESCE(VI.vehicle_reg_no,''),1,2) NOT IN('') AND COALESCE(VI.device_activation_status,'')<>'ACTIVATED' AND COALESCE(V.imei,'')=V.imei   
						   THEN 3
						/*Vehicle is not registred and VLT device not activated.*/
						WHEN SUBSTRING(COALESCE(VI.vehicle_reg_no,''),1,2)='' AND COALESCE(VI.device_activation_status,'')<>'ACTIVATED' AND COALESCE(V.imei,'')<>V.imei  
						   THEN 4 
						/*Vehicle is not registred and VLT device is activated.*/
						WHEN  SUBSTRING(COALESCE(VI.vehicle_reg_no,''),1,2)='' AND COALESCE(VI.device_activation_status,'')='ACTIVATED' AND COALESCE(V.imei,'')=V.imei 
						   THEN 5
						END,
						V.created_by,VI.vehicle_fule_type,VI.vehicle_class,ro.arto
						FROM t_vltd_activation_details AS V
						inner join t_vltd_cum_vehicle_details AS VI on V.imei=VI.imei
									INNER JOIN t_device_manufacturer_cum_vendor AS DM ON V.vendor_id=DM.vendor_id 
						inner join t_retro_fitment_center_master AS F on V.created_by= F.rfc_id
						inner join t_district_master AS D on F.district_id=D.district_id 
LEFT JOIN f_view_registration_office ro ON ro.arto_id = V.arto_id
						Left JOIN pvt.t_vltd_pvt_pkt_latest AS P on V.imei=P.imei 
						where V.device_activation_status='ACTIVATED' AND COALESCE(VI.vehicle_reg_no,'')<>'' 
						AND	(par_from_date IS NULL OR par_to_date IS NULL OR V.created_at::DATE between par_from_date AND par_to_date )
						AND (par_rto IS NULL OR V.arto_id=par_rto OR V.vendor_id=par_rto OR 
							 D.district_id::character varying =par_rto)
							AND(par_login_id IS NULL OR V.arto_id=par_login_id) AND
						(par_group_id IS NULL OR VI.vehicle_reg_no in(Select vehicle_reg_no From t_vehicle_group_mapping Where group_id=par_group_id  ))
							 AND (  par_search IS NULL
									 OR VI.vehicle_reg_no LIKE '%' || par_search || '%'
									 OR V.imei LIKE '%' || par_search || '%'
									 OR V.device_serial_no LIKE '%' || par_search || '%'
									 OR VI.model_name LIKE '%' || par_search || '%')
						)
					
					SELECT *  
					FROM cte_temp  
					WHERE row_num > par_first_rec and row_num <=par_last_rec;  

END;
$BODY$;


------------------------------------------------------------------------------------------------


-- Update in Table t_project_details_master

-- Add Column in Table t_project_details_master


	is_permit_login_enable character(1) COLLATE pg_catalog."default",
    pull_sms_mobile_no character(10) COLLATE pg_catalog."default",
	
	
-------------------------------------------------------------------------------


-- Update in Function



CREATE OR REPLACE FUNCTION public.f_list_project_details(
	par_state_id integer)
    RETURNS TABLE(val_department_name character varying, val_goverment character varying, val_project_title character varying, val_logo character varying, val_project_subtitle character varying, val_office_address character varying, val_mail_id character varying, val_contact_number character varying, val_latitude double precision, val_longitude double precision, val_base_url character varying, val_map_key character varying, val_is_permit_login_enable character,
				val_pull_sms_mobile_no character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 				select 
				department_name ,
				goverment ,
				project_title ,
				state_logo_path AS logo,
				project_subtitle,
				office_address,
				mail_id,
				contact_number,
				latitude,
				longitude,
				base_url,
				map_key,				
				COALESCE(is_permit_login_enable, 'N') AS is_permit_login_enable,
				pull_sms_mobile_no
				from t_project_details_master where state_id=par_state_id;
END;
$BODY$;	



--------------------------------------------------------------------------------------------


-- Update in Procedure


CREATE OR REPLACE PROCEDURE public.add_project_details(
	p_project_title character varying,
	p_project_sub_title character varying,
	p_department_name character varying,
	p_goverment character varying,
	p_state_id smallint,
	p_office_address character varying,
	p_contact_number character,
	p_mail_id character varying,
	p_latitude double precision,
	p_longitude double precision,
	p_base_url character varying,
	p_map_key character varying,
	p_state_logo_path character varying DEFAULT NULL::character varying,
	p_is_permit_login_enable character DEFAULT NULL::character,
	p_pull_sms_mobile_no character DEFAULT NULL::character,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
Declare 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN

	IF(p_state_logo_path='') THEN p_state_logo_path= NULL; END IF;

	BEGIN
		IF NOT Exists(Select state_id From t_project_details_master Where state_id=p_state_id)
		THEN
		INSERT into t_project_details_master(project_title,project_subtitle,department_name,
					development_agency,goverment,state_id,office_address,contact_number,
					mail_id,latitude,longitude,base_url,map_key,state_logo_path,
									is_permit_login_enable,pull_sms_mobile_no)
		Values(p_project_title,p_project_sub_title,p_department_name,
			   'NA',p_goverment,p_state_id,p_office_address,p_contact_number,
			   p_mail_id,p_latitude,p_longitude,p_base_url,p_map_key,p_state_logo_path,
			   p_is_permit_login_enable,p_pull_sms_mobile_no);
			_response := 'Added Project Details Successfully';  
		ELSE

		Update t_project_details_master SET project_title=p_project_title,
				project_subtitle=p_project_sub_title, department_name=p_department_name,
				goverment=p_goverment, office_address=p_office_address,
				contact_number=p_contact_number,mail_id=p_mail_id,
				latitude=p_latitude,longitude=p_longitude,
				base_url=p_base_url,map_key=p_map_key,
			state_logo_path=Case When COALESCE(p_state_logo_path,'')='' 
				Then state_logo_path ELSE p_state_logo_path END,
	is_permit_login_enable = p_is_permit_login_enable, pull_sms_mobile_no=p_pull_sms_mobile_no
			Where state_id=p_State_id;
			_response := 'Updated Project Details Successfully';  
		END IF;

			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
				_response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(0,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA','NA');	
				END;
END;
$BODY$;



-----------------------------------------------------------------------------------------------------------


-- Date: 09-07-2024


-- Update in Function


CREATE OR REPLACE FUNCTION public.f_list_ota_command_type(
	par_state_id integer,
	par_vendor_id character varying)
    RETURNS SETOF refcursor 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE 
	c_vltd_ota_command refcursor;
	c_m2m_vmn_gatway_details refcursor;
	
BEGIN
           
     
	OPEN c_vltd_ota_command FOR
    	Select M.ota_command_type_id,M.ota_command_type, ota_command from t_ota_command_type_master AS 
		M Left JOIN
		(Select * from t_vltd_ota_commands Where vendor_id=par_vendor_id) AS V 
		ON M.ota_command_type_id=V.ota_command_type_id  where M.ota_command_type_id not in (3,4);
			   
	RETURN NEXT c_vltd_ota_command; 		   
	
	
	
	OPEN c_m2m_vmn_gatway_details FOR
    	
		Select vmn From t_m2m_vmn_gatway_details;
			
 	RETURN NEXT c_m2m_vmn_gatway_details; 	
	
 
END;
$BODY$;


-----------------------------------------------------------

-- Update in Table

-- Add Column in Table t_vltd_ota_commands, t_vltd_ota_commands_log


	gprs_ota_command character varying
	
	
----------------------------------------------------------------------------

-- Create new table

CREATE TABLE IF NOT EXISTS public.t_ota_command_type_master2 (
    ota_command_type_id SERIAL PRIMARY KEY,
    ota_command_type VARCHAR NOT NULL
);


-----------------------------------------------------------------------------------


-- New FUNCTION


CREATE OR REPLACE FUNCTION f_list_ota_command_type2(p_vendor_id VARCHAR(20))
RETURNS TABLE (
    val_ota_command_type_id INT,
    val_ota_command_type VARCHAR,
    val_ota_command VARCHAR,
    val_gprs_ota_command VARCHAR,
    val_vmn CHAR
) AS $$
BEGIN
    RETURN QUERY
    SELECT M.ota_command_type_id, M.ota_command_type, ota_command, gprs_ota_command, vmn
    FROM t_ota_command_type_master2 M 
    LEFT JOIN (SELECT * FROM t_vltd_ota_commands WHERE vendor_id = p_vendor_id) V 
    ON M.ota_command_type_id = V.ota_command_type_id
    LEFT JOIN (SELECT vmn FROM t_m2m_vmn_gatway_details) vmn
    ON TRUE ORDER BY M.ota_command_type_id ASC; 
	
-- Assuming you want to join every row in the first result with every row in the second result

END;
$$ LANGUAGE plpgsql;


-------------------------------------------------------------------------------------------------------

-- Date: 10-07-2024

-- Update in Function 

CREATE OR REPLACE FUNCTION public.f_list_vltd_ota_command(
	par_display_length integer DEFAULT 10,
	par_display_start integer DEFAULT 0,
	par_sort_col integer DEFAULT 3,
	par_sort_dir character varying DEFAULT 'ASC'::character varying,
	par_search character varying DEFAULT ''::character varying)
    RETURNS TABLE(val_row_num bigint, val_total_count bigint, val_vendor_id character varying, val_ota_command_type character varying, val_ota_command character varying, val_ota_command_type_id integer, val_gprs_ota_command character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$

			DECLARE 
				 par_first_rec integer := par_display_start;  
				 par_last_rec integer := par_display_start + par_display_length;  
	
BEGIN
 RETURN QUERY 
 				  
					 WITH cte_temp AS  
						(  
							SELECT ROW_NUMBER() OVER (ORDER BY  

							  CASE WHEN (par_sort_col = 1 and par_sort_dir='ASC')  
							THEN  V.vendor_id
							END ASC,
							 CASE WHEN (par_sort_col = 1 and par_sort_dir='DESC')  
							THEN  V.vendor_id
							END DESC,
							 CASE WHEN (par_sort_col = 3 and par_sort_dir='ASC')  
							THEN  M.ota_command_type
							END ASC,
							 CASE WHEN (par_sort_col = 3 and par_sort_dir='DESC')  
							THEN  M.ota_command_type
							END DESC
					  )  
						AS row_num,  
							 COUNT(1) over() as total_count,  
							 V.vendor_id ,
							 M.ota_command_type, V.ota_command,
							 V.ota_command_type_id,
							V.gprs_ota_command
							 from t_vltd_ota_commands AS V 
							 INNER JOIN t_ota_command_type_master AS M ON V.ota_command_type_id=M.ota_command_type_id where  
						  (
							  V.ota_command like '%'|| par_search ||'%'
							 OR V.vendor_id like '%'|| par_search ||'%'
							 )

						)  
					
					SELECT *  
					FROM cte_temp  
					WHERE row_num > par_first_rec and row_num <=par_last_rec;  

END;
$BODY$;


-----------------------------------------------------------------------------------------------------------


-- Create New Table 


CREATE TABLE IF NOT EXISTS public.t_black_list_command_master (
    command varchar PRIMARY KEY
);


--------------------------------------------------------------------------


-- Create new Procedure

CREATE OR REPLACE PROCEDURE public.add_vltd_ota_commands(
    p_vendor_id VARCHAR(20),
    p_ota_command_type_id INT,
    p_ota_command VARCHAR(100),
    p_gprs_ota_command VARCHAR(100),
    p_state_id SMALLINT,
    p_ip_address VARCHAR(15),
	INOUT _response text DEFAULT NULL::text
)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE    
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
    BEGIN
        IF NOT EXISTS(SELECT 1 FROM t_black_list_command_master WHERE command LIKE '%' || p_ota_command || '%') THEN
            IF NOT EXISTS(SELECT 1 FROM t_black_list_command_master WHERE command LIKE '%' || p_gprs_ota_command || '%') THEN
                IF NOT EXISTS(SELECT 1 FROM t_vltd_ota_commands WHERE vendor_id = p_vendor_id AND ota_command_type_id = p_ota_command_type_id) THEN
                    INSERT INTO t_vltd_ota_commands (vendor_id, ota_command_type_id, ota_command, gprs_ota_command, created_at)
                    VALUES (p_vendor_id, p_ota_command_type_id, p_ota_command, p_gprs_ota_command, NOW());
                    _response := 'Command Added Successfully';
                ELSE
                    INSERT INTO t_vltd_ota_commands_log
                    	SELECT * FROM t_vltd_ota_commands 
							WHERE ota_command_type_id = p_ota_command_type_id 
							AND vendor_id = p_vendor_id;
                    
                    UPDATE t_vltd_ota_commands  
                    	SET ota_command = p_ota_command, gprs_ota_command = p_gprs_ota_command, 
						updated_at = NOW()
                    WHERE ota_command_type_id = p_ota_command_type_id AND vendor_id = p_vendor_id;
                    
                    _response := 'Command Updated Successfully';
                END IF;
            ELSE
                _response := 'Invalid Command';
            END IF;
        ELSE
            _response := 'Invalid Command';
        END IF;
		
		
		
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
			get stacked diagnostics
			v_state   = returned_sqlstate,
			v_msg     = message_text,
			v_detail  = pg_exception_detail,
			v_hint    = pg_exception_hint,
			v_context = pg_exception_context;
			_response := 'Something went to wrong.'||v_msg;
			raise notice E'Got exception:
			state  : %
			message: %
			detail : %
			hint   : %
			context: %', v_state, v_msg, v_detail, v_hint, v_context;
			INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA',p_ip_address);	
			END;
			
    END;    

$BODY$;


-------------------------------------------------------------------------

-- Date: 11-07-2024

-- Create New Function 

CREATE OR REPLACE FUNCTION public.f_get_master_socket_by_id(
	par_socket_id integer)
    RETURNS TABLE(val_socket_id smallint, val_socket_name character varying, val_socket_port bigint, val_socket_url character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 	
	Select socket_id, socket_name,socket_port, socket_url 
		From t_socket_master WHERE socket_id=par_socket_id;
END;
$BODY$;



---------------------------------------------------------------------------------------------


-- Update in Procedure


CREATE OR REPLACE PROCEDURE public.edit_socket_master_details(
	p_state_id smallint,
	p_socket_id smallint,
	p_socket_name character varying,
	p_socket_port bigint,
	p_socket_url character varying,
	p_insert_or_update_by character varying,
	p_ip_address character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_server_log_date_time TIMESTAMP(3)=NOW();
	
BEGIN
	BEGIN

			IF Exists(select socket_id From t_socket_master Where socket_id=p_socket_id)THEN
				
				INSERT INTO t_socket_master_log
					SELECT socket_id,socket_name,socket_port,socket_url,created_at,created_by,created_by_ip 
						FROM t_socket_master WHERE socket_id=p_socket_id;
				
				UPDATE t_socket_master SET socket_port=p_socket_port,socket_url=p_socket_url, 
					updated_by=p_insert_or_update_by,updated_at=v_server_log_date_time 
					WHERE socket_id=p_socket_id; 
				_response := 'Socket Master Updated Successfully';
			ELSE
				INSERT INTO t_socket_master(socket_id,socket_name,socket_port,socket_url,created_by,created_at,created_by_ip)
				VALUES(p_socket_id,p_socket_name,p_socket_port,p_socket_url,p_insert_or_update_by,NOW(),p_ip_address);
				_response := 'Socket Master Created Successfully';
			END IF;
			
	
		EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;
END;

$BODY$;


------------------------------------------------------------------------------------


-- Date: 12-07-2024

-- Update in Function


CREATE OR REPLACE FUNCTION public.f_list_user_details(
	)
    RETURNS TABLE(val_role_name character varying, val_role_id smallint, val_login_id character varying, val_name character varying, val_mobile_no text, val_email_id character varying, val_is_active character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 				SELECT
				R.designation_name,
				L.role_id,
				login_id,
				username,
				LTRIM(RTRIM (mobile_no)),
				email,is_active
				FROM users AS L
				INNER JOIN t_designation_master AS R on L.role_id=R.designation_id 
				-- where L.role_id in ('1','2','6','3','10')
				 where L.role_id NOT in ('4','5')
				;
END;
$BODY$;


--------------------------------------------------------------------------------------------------


-- Update in Function


CREATE OR REPLACE FUNCTION public.f_list_login_role(
	)
    RETURNS SETOF t_designation_master 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
	
BEGIN
 RETURN QUERY 
 	SELECT * FROM t_designation_master WHERE designation_id != '17' ORDER BY designation_id ASC;							
END;
$BODY$;

-------------------------------------------------------------------------------------------------------------------

-- Date: 15-07-2024

-- Update in Procedure


CREATE OR REPLACE PROCEDURE public.add_user_login(
	p_role_id smallint,
	p_email_id character varying,
	p_mobile_no character,
	p_login_id character varying,
	p_state_id smallint,
	p_ip_address character varying,
	p_user_login_id character varying,
	p_name character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_sha256_password character varying;
BEGIN
 BEGIN
    SELECT * INTO v_sha256_password FROM f_udf_convert_to_sha256(p_mobile_no);
	IF NOT EXISTS(Select login_id From users Where login_id=UPPER(p_login_id))
	THEN
		INSERT INTO users(state_id,role_id,login_id,password,username,mobile_no,email,
						  is_first_time_login,created_at) 
		VALUES(p_state_id,p_role_id,UPPER(p_login_id),v_sha256_password,p_name,
			   p_mobile_no,p_email_id,'Y',NOW());
			   
		_response := 'User Added Successfully';
	ELSE
	_response := 'LoginID Already Exists';
	END IF;
 
		EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_user_login_id,p_ip_address);	
				END; 
END;
$BODY$;



------------------------------------------------------------------------------------------------------------

-- Date: 15-07-2024

-- Create new Function

CREATE OR REPLACE FUNCTION f_get_user_by_id(p_id bigint)
    RETURNS TABLE(val_name character varying, val_email character varying, val_login_id character varying, val_mobile_no character, val_is_active character, val_role_id smallint, val_is_first_time_login character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
	RETURN QUERY
		Select 
		name,
		email,
		login_id,
		mobile_no,
		is_active,    	
		role_id,
		is_first_time_login	
		from users Where id = p_id;
END;
$BODY$;

----------------------------------------------------------------------------------------------------


-- Date: 19-07-2024

-- Update in Function


CREATE OR REPLACE FUNCTION public.f_list_user_details(
	)
    RETURNS TABLE(val_id bigint, val_role_name character varying, val_role_id smallint, val_login_id character varying, val_name character varying, val_mobile_no text, val_email_id character varying, val_is_active character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 				SELECT
				L.id,
				R.designation_name,
				L.role_id,
				login_id,
				name,
				LTRIM(RTRIM (mobile_no)),
				email,is_active
				FROM users AS L
				INNER JOIN t_designation_master AS R on L.role_id=R.designation_id 
				-- where L.role_id in ('1','2','6','3','10')
				 where L.role_id NOT in ('4','5','17')
				;
END;
$BODY$;


--------------------------------------------------------------------------------------------------


-- Update in procedure


CREATE OR REPLACE PROCEDURE public.edit_user_details(
	p_state_id smallint,
	p_login_id character varying,
	p_role_id smallint,
	p_name character varying,
	p_mobile_no character,
	p_insert_or_update_by character varying,
	p_email_id character varying,
	p_ip_address character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_server_log_date_time TIMESTAMP(3)=NOW();
BEGIN
	BEGIN
			INSERT INTO t_login_log
			 Select state_id,role_id,login_id,password,username,mobile_no,email,
			 	is_first_time_login,last_login_time,last_login_ip,NOW(),
				p_insert_or_update_by,p_ip_address From users 
				WHERE login_id=p_login_id AND role_id=p_role_id;

			UPDATE users Set name=p_name, mobile_no=p_mobile_no, email=p_email_id, 					
					updated_at=v_server_log_date_time
				Where login_id=p_login_id 
					AND role_id=p_role_id;				
			
			_response := 'Login  Updated Successfully';
			
			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;

END;
$BODY$;


----------------------------------------------------------------------------------------------------------


-- Create new procedure

CREATE OR REPLACE PROCEDURE public.edit_user_status(
	p_state_id smallint,
	p_login_id character varying,	
	p_insert_or_update_by character varying,	
	p_ip_address character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_server_log_date_time TIMESTAMP(3)=NOW();
BEGIN
	BEGIN
			INSERT INTO t_login_log
			 Select state_id,role_id,login_id,password,username,mobile_no,email,
			 	is_first_time_login,last_login_time,last_login_ip,NOW(),
				p_insert_or_update_by,p_ip_address From users WHERE login_id=p_login_id;

			UPDATE users Set 
					is_active= CASE WHEN is_active='N' THEN 'Y' ELSE 'N' END,					
					updated_at=v_server_log_date_time Where login_id=p_login_id;				
			
			_response := 'Record Updated Successfully';
			
			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;

END;
$BODY$;

-------------------------------------------------------------------------------------------------------------------


-- Date: 22-07-2024

-- Update in Procedure


CREATE OR REPLACE PROCEDURE public.edit_user_status(
	p_state_id smallint,
	p_login_id character varying,
	p_insert_or_update_by character varying,
	p_ip_address character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_server_log_date_time TIMESTAMP(3)=NOW();
BEGIN
	BEGIN
			INSERT INTO public.t_login_log
				Select state_id,role_id,login_id,password,username,
				   mobile_no,email,is_first_time_login,
				   last_login_time,last_login_ip,
	   				NOW(),p_insert_or_update_by,p_ip_address 
				   From users WHERE login_id=p_login_id;
		
			UPDATE users Set 
					is_active= CASE WHEN is_active='N' OR is_active IS NULL THEN 'Y' ELSE 'N' END,					
					updated_at=v_server_log_date_time Where login_id=p_login_id;				
			
			_response := 'Record Updated Successfully';
			
			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;

END;
$BODY$;

----------------------------------------------------------------------------------------------------


-- Create New Function

CREATE OR REPLACE FUNCTION f_list_send_sms_log(
    par_month_id integer DEFAULT NULL,
    par_date timestamp with time zone DEFAULT NULL,
    par_to_date timestamp with time zone DEFAULT NULL,
    par_year char(4) DEFAULT NULL,
    par_display_length integer DEFAULT 10,
    par_display_start integer DEFAULT 0,
    par_sort_col integer DEFAULT 0,
    par_sort_dir varchar(10) DEFAULT 'ASC',
    par_search varchar(255) DEFAULT ''
)
RETURNS TABLE(
    val_row_num bigint,
    val_total_count bigint,
    val_mobile_no varchar,
    val_insertion_date_time text,
    val_message varchar,
    val_status text,
    val_sms_gateway_response varchar
) AS $$
DECLARE
    par_first_rec integer := par_display_start;
    par_last_rec integer := par_display_start + par_display_length;
BEGIN
    RETURN QUERY
    WITH cte_temp AS (
        SELECT 
            ROW_NUMBER() OVER (ORDER BY
                CASE WHEN (par_sort_col = 1 AND UPPER(par_sort_dir) = 'ASC') THEN created_at END ASC,
                CASE WHEN (par_sort_col = 1 AND UPPER(par_sort_dir) = 'DESC') THEN created_at END DESC
            ) AS row_num,
            COUNT(1) OVER() AS total_count,
            mobile_no,
            TO_CHAR(created_at, 'DD/MM/YYYY HH24:MI:SS') AS insertion_date_time,
            text_message,
            CASE WHEN status = 'Y' THEN 'Success' WHEN status = 'N' THEN 'Failed' ELSE 'Failed' END AS status,
            sms_gateway_response
        FROM t_send_sms_log
        WHERE 
            ((EXTRACT(YEAR FROM created_at)::char(4) = par_year AND EXTRACT(MONTH FROM created_at) = par_month_id)
            OR (created_at BETWEEN par_date AND par_to_date))
            AND (par_search IS NULL OR text_message ILIKE '%' || par_search || '%' OR mobile_no ILIKE '%' || par_search || '%')
    )
    SELECT 
        row_num,
        total_count,
        mobile_no,
        insertion_date_time,
        text_message,
        status,
        sms_gateway_response
    FROM cte_temp
    WHERE row_num > par_first_rec AND row_num <= par_last_rec;
END;
$$ LANGUAGE plpgsql;



-------------------------------------------------------------------------------------------------------------------------


-- Create new Function 


CREATE OR REPLACE FUNCTION f_list_audit_trail_log(
    par_month_id integer DEFAULT NULL,
    par_date timestamp with time zone DEFAULT NULL,
    par_to_date timestamp with time zone DEFAULT NULL,
    par_year char(4) DEFAULT NULL,
    par_display_length integer DEFAULT 10,
    par_display_start integer DEFAULT 0,
    par_sort_col integer DEFAULT 0,
    par_sort_dir varchar(10) DEFAULT 'ASC',
    par_search varchar(255) DEFAULT NULL
)
RETURNS TABLE(
    val_row_num bigint,
    val_total_count bigint,
    val_login_id varchar,
    val_insertion_date_time text,
    val_action varchar,
    val_ip_address varchar
) AS $$
DECLARE
    par_first_rec integer := par_display_start;
    par_last_rec integer := par_display_start + par_display_length;
BEGIN
    RETURN QUERY
    WITH cte_temp AS (
        SELECT 
            ROW_NUMBER() OVER (ORDER BY
                CASE WHEN (par_sort_col = 1 AND UPPER(par_sort_dir) = 'ASC') THEN created_at END ASC,
                CASE WHEN (par_sort_col = 1 AND UPPER(par_sort_dir) = 'DESC') THEN created_at END DESC
            ) AS row_num,
            COUNT(1) OVER() AS total_count,
            login_id,
            TO_CHAR(created_at, 'DD/MM/YYYY HH24:MI:SS') AS insertion_date_time,
            audit_action,
            created_by_ip
        FROM t_audit_trail
        WHERE 
            ((EXTRACT(YEAR FROM created_at)::char(4) = par_year AND EXTRACT(MONTH FROM created_at) = par_month_id)
            OR (created_at BETWEEN par_date AND par_to_date))
            AND (par_search IS NULL OR login_id ILIKE '%' || par_search || '%' OR audit_action ILIKE '%' || par_search || '%')
    )
    SELECT 
        row_num,
        total_count,
        login_id,
        insertion_date_time,
        audit_action,
        created_by_ip
    FROM cte_temp
    WHERE row_num > par_first_rec AND row_num <= par_last_rec;
END;
$$ LANGUAGE plpgsql;


-------------------------------------------------------------------------------------------------------------

-- Date: 23-07-2024

-- Create New Table


CREATE TABLE enlistment.t_morth_approved_device_manufacturer (
    manufacturer_id serial PRIMARY KEY,
    manufacturer_name varchar(100) NOT NULL UNIQUE,
    manufacturer_name_old varchar(100),
    contact_person_name varchar(100),
    mobile_no char(10) NOT NULL,
    is_allowed char(1),
    uid varchar(50),
    creation_date_time timestamp NOT NULL,
    updation_date_time timestamp,
    ip_address varchar(15)
);


----------------------------------------------------------------------------------------------------------


-- Create New Function 


CREATE OR REPLACE FUNCTION enlistment.f_list_morth_approved_device_manufacturer()
RETURNS TABLE (
    val_manufacturer_id integer,
    val_manufacturer_name varchar,
    val_manufacturer_name_old varchar,
    val_contact_person_name varchar,
    val_mobile_no char,
    val_is_allowed char,
    val_uid varchar,
    val_creation_date_time timestamp,
    val_updation_date_time timestamp,
    val_ip_address varchar
) AS $$
BEGIN
    RETURN QUERY
    SELECT * FROM enlistment.t_morth_approved_device_manufacturer ORDER BY uid DESC;
END;
$$ LANGUAGE plpgsql;

----------------------------------------------------------------------------------------------------



-- Create New Table


CREATE TABLE enlistment.t_morth_approved_device_manufacturer_log (
    manufacturer_id serial PRIMARY KEY,
    manufacturer_name varchar(100) NOT NULL UNIQUE,
    manufacturer_name_old varchar(100),
    contact_person_name varchar(100),
    mobile_no char(10) NOT NULL,
    is_allowed char(1),
    uid varchar(50),
    creation_date_time timestamp NOT NULL,
    updation_date_time timestamp,
    ip_address varchar(15)
);

---------------------------------------------------------------------------------------

-- Create New Function

CREATE OR REPLACE FUNCTION enlistment.f_morth_manufacturer_by_id(
	p_id integer)
    RETURNS SETOF enlistment.t_morth_approved_device_manufacturer 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
	RETURN QUERY
		SELECT * FROM enlistment.t_morth_approved_device_manufacturer Where manufacturer_id = p_id;
END;
$BODY$;


---------------------------------------------------------------------------------------------------------------

-- Date: 24-07-2024


-- Add New Extention

	CREATE EXTENSION IF NOT EXISTS pgcrypto;

------------------------------------------------------------------------------------------------------


-- Create New Procedure

CREATE OR REPLACE PROCEDURE enlistment.update_manufacturer_status(
	p_state_id smallint,	
	p_insert_or_update_by character varying,
	p_is_allowed VARCHAR(5),
    p_manufacturer_id SMALLINT,
    p_ip_address VARCHAR(15),
    p_contact_person_name VARCHAR(100),
    p_mobile_no CHAR(10),	
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_server_log_date_time TIMESTAMP(3)=NOW();
BEGIN
	BEGIN
			-- Update the manufacturer status
        UPDATE enlistment.t_morth_approved_device_manufacturer
        	SET
            	is_allowed = CASE WHEN p_is_allowed = 'False' THEN 'N' ELSE 'Y' END,
            uid = CASE WHEN p_is_allowed = 'False' THEN NULL 
					ELSE UPPER(encode(digest(manufacturer_name, 'md5'), 'hex')) END,
            contact_person_name = p_contact_person_name,
            mobile_no = p_mobile_no
        	WHERE manufacturer_id = p_manufacturer_id;

        	-- Return success message
        	_response := 'Record Updated Successfully.';				
			
			
			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;

END;
$BODY$;


--------------------------------------------------------------------------------------------------------------------

-- Date: 29-07-2024

-- Update Function 



CREATE OR REPLACE FUNCTION public.f_list_state(
	)
    RETURNS TABLE(val_state_id integer, val_state_name character varying, val_state_short_name_current character, val_state_short_name_old character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 				SELECT
				state_id,
				state_name,
				state_short_name_current,
				state_short_name_old
				FROM t_state_master ORDER BY state_name ASC;
END;
$BODY$;


-----------------------------------------------------------------------------------------------------------------------

-- Date: 31-07-2024

-- Create New Function

CREATE OR REPLACE FUNCTION public.f_rfc_by_rfc_id(
	p_rfc_id character)
    RETURNS SETOF t_retro_fitment_center_master 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
	RETURN QUERY
		SELECT * FROM t_retro_fitment_center_master Where rfc_id = p_rfc_id;
END;
$BODY$;

---------------------------------------------------------------------------------------------------------

-- Create New table


CREATE TABLE IF NOT EXISTS public.t_retro_fitment_center_master_log
(
    state_id smallint NOT NULL,
    district_id smallint NOT NULL,
    vendor_id character varying(20) COLLATE pg_catalog."default" NOT NULL,
    rfc_id character(10) COLLATE pg_catalog."default" NOT NULL,
    rfc_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    rfc_address character varying(500) COLLATE pg_catalog."default" NOT NULL,
    contact_person_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    mobile_no character(10) COLLATE pg_catalog."default" NOT NULL,
    email_id character varying(50) COLLATE pg_catalog."default" NOT NULL,
    is_active character(1) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp(3) without time zone NOT NULL DEFAULT now(),
    updated_at timestamp(3) without time zone,
    created_by character varying(20) COLLATE pg_catalog."default",
    updated_by character varying(20) COLLATE pg_catalog."default",
    created_by_ip character varying(15) COLLATE pg_catalog."default",
    updated_by_ip character varying(15) COLLATE pg_catalog."default",
    action_taken character varying(20) COLLATE pg_catalog."default"
)


------------------------------------------------------------------------------------------------------------

-- Create New Procedure


CREATE OR REPLACE PROCEDURE public.update_rfc(
	p_state_id smallint,
	p_insert_or_update_by character varying,
	p_rfc_id character varying,
	p_rfc_name character varying,
	p_rfc_address character varying,
	p_contact_person_name character varying,
	p_mobile_no character,
	p_email_id character varying,
	p_ip_address character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
 	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_server_log_date_time TIMESTAMP(3)=NOW();
BEGIN
	BEGIN
			
		
			INSERT INTO t_retro_fitment_center_master_log
				SELECT *,'Update' FROM t_retro_fitment_center_master
				WHERE rfc_id=p_rfc_id;
				
		-- Update rfc
        UPDATE t_retro_fitment_center_master
        	SET
            	rfc_name = UPPER(p_rfc_name),
				rfc_address = UPPER(p_rfc_address),
				contact_person_name = UPPER(p_contact_person_name),            	
            	email_id = UPPER(p_email_id),
				updated_by = p_insert_or_update_by,
				updated_by_ip = p_ip_address
        	WHERE rfc_id = p_rfc_id;
			
			-- Insert into LoginLog	
			INSERT INTO t_login_log(state_id,role_id,login_id,login_password,
					username,mobile_no,email_id,is_first_time_login,last_login_time ,
    				last_login_ip,created_at, created_by, created_by_ip)
            SELECT state_id, role_id, login_id, password, 
					name, mobile_no, email, is_first_time_login, last_login_time, 
					last_login_ip, created_at, login_id, last_login_ip
            FROM users WHERE login_id=p_rfc_id;
				
				UPDATE users
        			SET
						name = UPPER(p_rfc_name),
						email = UPPER(p_email_id),
						username = UPPER(p_rfc_name),
						updated_at = v_server_log_date_time,            							
						update_by = p_insert_or_update_by
					WHERE login_id = p_rfc_id;

        	_response := 'Record Updated Successfully.';				
			
			
			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;

END;
$BODY$;


-----------------------------------------------------------------



-- Update Function Message


CREATE OR REPLACE FUNCTION public.f_check_vltd_activation_status(
	p_imei_or_sr_no character varying,
	p_type character varying,
	p_role_id smallint,
	p_login_id character varying DEFAULT NULL::character varying)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE 
	v_insertion_by varchar(50)=null;
	v_device_activation_status varchar(25);
	v_imei varchar(15);
	v_vendor_id varchar(20);
	v_arto_id char(4);
	v_rto_id char(4);
	v_response TEXT=NULL;
BEGIN
	 IF EXISTS(SELECT 1 FROM t_vltd_cum_vehicle_details WHERE (p_type='imei' AND imei=p_imei_or_sr_no) OR (p_type<>'imei' AND device_serial_no=p_imei_or_sr_no) OR(p_type='vehicle_reg_no' AND vehicle_reg_no=p_imei_or_sr_no))
	  THEN
	 
    	SELECT a.vendor_id,a.arto_id, a.created_by,a.device_activation_status,a.imei into v_vendor_id, v_arto_id, v_insertion_by, v_device_activation_status, v_imei FROM t_vltd_activation_details A INNER JOIN t_vltd_cum_vehicle_details V ON a.imei=v.imei WHERE (p_type='imei' AND a.imei=p_imei_or_sr_no) OR (p_type<>'imei' AND a.device_serial_no=p_imei_or_sr_no) OR(p_type='vehicle_reg_no' AND vehicle_reg_no=p_imei_or_sr_no);
		 IF(p_role_id=3)
	  THEN
	   IF(v_device_activation_status='ACTIVATED')
		     THEN
				 IF(p_login_Id = '' OR p_login_Id IS NULL OR v_insertion_by=p_login_Id OR v_vendor_id=p_login_Id OR v_arto_id=p_login_id OR v_arto_id IN(Select arto_id From t_arto_master Where rto_id=p_login_id))
				   THEN
  					v_response:= 'Yes,' ||v_imei;
				 ELSE
  					v_response:= 'You can not print activation certificate, because this VLTD is not activated by this account.';
				   END IF;
		ELSE
    		v_response:= 'You can not print activation certificate, because VLTD not activated.';
		 END IF;
	  ELSE
	   IF(v_device_activation_status='ACTIVATED')
		     THEN
				 IF(p_login_Id = '' OR  p_login_Id IS NULL OR v_insertion_by=p_login_Id OR v_vendor_id=p_login_id OR v_arto_id=p_login_id)
				   THEN
  					v_response:= 'Yes,' ||v_imei;
				 ELSE
  					v_response:= 'You can not print activation certificate, because this VLTD is not activated by this account.';
				   END IF;
		ELSE
    		v_response:= 'You can not print activation certificate, because VLTD not activated.';
		 END IF;
	  END IF;
	   
	  ELSE
     	v_response:= 'Invalid IMEI number or device serial number.';
	  END IF;
	  
	  RETURN v_response;
 END;
$BODY$;

-------------------------------------------------------------------------------------------------------------------

-- Update Function Message

CREATE OR REPLACE FUNCTION public.f_check_vltd_validity_extension_status(
	v_imeiorsrno character varying,
	v_type character varying,
	v_loginid character varying,
	v_roleid smallint)
    RETURNS text
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
AS $BODY$
DECLARE  v_InsertionBy VARCHAR(50):=NULL; v_DeviceActivationStatus VARCHAR(25);v_IMEI VARCHAR(15); v_status text:='';
v_vendorID Varchar(20);v_ARTOID Char(4);v_RTOID Char(4);v_LastValidityUpdationDateTime DATE:=NULL; rec1 record ;
BEGIN
	if exists (select 1 from t_vltd_cum_vehicle_details where (v_Type='IMEI' AND imei=v_IMEIorSrNo) OR (v_Type<>'IMEI' AND device_serial_no=v_IMEIorSrNo) 
				OR(v_Type='VehicleRegNo' AND vehicle_reg_no=v_IMEIorSrNo))	then
				
				select * into  rec1 from t_vltd_activation_details A inner join t_vltd_cum_vehicle_details V on (A.imei=V.imei) left outer join t_esim_cum_vltd_inventory E on V.imei =  E.imei
				where (v_Type='IMEI' AND a.imei=v_IMEIorSrNo) OR (v_Type<>'IMEI' AND a.device_serial_no=v_IMEIorSrNo) 
				OR(v_Type='VehicleRegNo' AND vehicle_reg_no=v_IMEIorSrNo);

				v_vendorID=rec1.vendor_id; v_ARTOID=rec1.arto_id; v_InsertionBy=rec1.created_by;
				v_DeviceActivationStatus=rec1.device_activation_status; v_IMEI = rec1.imei;
				v_LastValidityUpdationDateTime=rec1.last_validity_updation_date_time;
				
				if (v_RoleID = 3) then 
					if (v_DeviceActivationStatus='ACTIVATED') then 
						IF(v_loginId = '' OR v_loginId IS NULL OR v_InsertionBy=v_loginId OR v_vendorID=v_loginId OR v_ARTOID=v_loginId OR v_ARTOID IN(select arto_id from t_arto_master where rto_id=v_loginId))
						then  
							IF(v_LastValidityUpdationDateTime IS NOT NULL) then
							 v_status :=  'Yes,' ||v_IMEI ;
							ELSE
							v_status :='You can not print ESIM validity extension certificate, because no ESIM validity extenison record found for this '||v_Type||'.';
							end if;
						else v_status := 'You can not print ESIM validity extension certificate, because this VLTD is not activated by this account.';
						end if;
					else v_status:='You can not print ESIM validity extension certificate, because VLTD not activated.';	
					end if;
				else	
					if (v_DeviceActivationStatus='ACTIVATED') then 
						IF(v_loginId = '' OR v_loginId IS NULL OR v_InsertionBy=v_loginId OR v_vendorID=v_loginId OR v_ARTOID=v_loginId OR v_ARTOID IN(select arto_id from t_arto_master where rto_id=v_loginId))
						then  
							IF(v_LastValidityUpdationDateTime IS NOT NULL) then
							 v_status :=  'Yes,' ||v_IMEI ;
							ELSE
							v_status :='You can not print ESIM validity extension certificate, because no ESIM validity extenison record found for this '||v_Type||'.';
							end if;
						else v_status := 'You can not print ESIM validity extension certificate, because this VLTD is not activated by this account.';
						end if;
					else v_status:='You can not print ESIM validity extension certificate, because VLTD not activated.';	
					end if;
				end if;
	else v_status:='Invalid IMEI number or device serial no.';	
	end if;
	return v_status;
END;
$BODY$;

------------------------------------------------------------------------------------------------------------

--Date: 2-08-2024

-- Add columns in Table t_send_sms_log

	sms_gateway_request - character varying
	
	created_by - character varying
	
	created_by_ip - character varying
	

---------------------------------------------------------------------------------------------------------


-- Update in Procedure



CREATE OR REPLACE PROCEDURE public.add_send_sms_logs(
	p_mobile_no character,
	p_text_message character varying,
	p_status character,
	p_sms_gateway_response character varying,
	p_sms_gateway_type character,
	p_created_at timestamp without time zone,
	p_created_by character varying,
	p_created_by_ip character varying,
	p_sms_gateway_request character varying)
	
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
Begin

BEGIN

	INSERT INTO t_send_sms_log(mobile_no,text_message,status,sms_gateway_response,
		sms_gateway_type,created_at,sms_gateway_request,created_by,created_by_ip) 
	VALUES (p_mobile_no,p_text_message,p_status,p_sms_gateway_response,
		p_sms_gateway_type,p_created_at,p_sms_gateway_request,p_created_by,p_created_by_ip);
		
		
			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
 				
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(0,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_created_by,p_created_by_ip);	
				END;

End;
$BODY$;

--------------------------------------------------------------------------------


-- Update in Function

CREATE OR REPLACE FUNCTION public.f_list_send_sms_log(
	par_month_id integer DEFAULT NULL::integer,
	par_date timestamp with time zone DEFAULT NULL::timestamp with time zone,
	par_to_date timestamp with time zone DEFAULT NULL::timestamp with time zone,
	par_year character DEFAULT NULL::bpchar,
	par_display_length integer DEFAULT 10,
	par_display_start integer DEFAULT 0,
	par_sort_col integer DEFAULT 0,
	par_sort_dir character varying DEFAULT 'ASC'::character varying,
	par_search character varying DEFAULT ''::character varying)
    RETURNS TABLE(val_row_num bigint, val_total_count bigint, val_mobile_no character varying, val_insertion_date_time text, val_message character varying, val_status text, val_sms_gateway_response character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE
    par_first_rec integer := par_display_start;
    par_last_rec integer := par_display_start + par_display_length;
BEGIN
    RETURN QUERY
    WITH cte_temp AS (
        SELECT 
            ROW_NUMBER() OVER (ORDER BY
                CASE WHEN (par_sort_col = 1 AND UPPER(par_sort_dir) = 'ASC') THEN created_at END ASC,
                CASE WHEN (par_sort_col = 1 AND UPPER(par_sort_dir) = 'DESC') THEN created_at END DESC
            ) AS row_num,
            COUNT(1) OVER() AS total_count,
            mobile_no,
            TO_CHAR(created_at, 'DD/MM/YYYY HH24:MI:SS') AS insertion_date_time,
            text_message,
            CASE WHEN status = 'P' THEN 'Success' WHEN status = 'F' THEN 'Failed' ELSE 'Failed' END AS status,
            sms_gateway_response
        FROM t_send_sms_log
        WHERE 
            ((EXTRACT(YEAR FROM created_at)::char(4) = par_year AND EXTRACT(MONTH FROM created_at) = par_month_id)
            OR (created_at BETWEEN par_date AND par_to_date))
            AND (par_search IS NULL OR text_message ILIKE '%' || par_search || '%' OR mobile_no ILIKE '%' || par_search || '%')
    )
    SELECT 
        row_num,
        total_count,
        mobile_no,
        insertion_date_time,
        text_message,
        status,
        sms_gateway_response
    FROM cte_temp
    WHERE row_num > par_first_rec AND row_num <= par_last_rec;
END;
$BODY$;

--------------------------------------------------------------------------------------------------------------------


-- Date: 06-08-2024

-- Update in Procedure

CREATE OR REPLACE PROCEDURE public.edit_group_name(
	p_group_id integer,
	p_group_name character varying,
	p_email_id character varying,
	p_mobile_no character,
	p_login_id character varying,
	p_state_id smallint,
	p_ip_address character varying,
	p_group_login_id character varying,
	p_is_api_available character,
	p_url character varying,
	p_api_key character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN
	IF NOT EXISTS(Select login_id From t_vehicle_group Where login_id=p_group_login_id and group_id != p_group_id)
	THEN
		INSERT INTO t_vehicle_group_log
		Select group_id,login_id,group_name,email_id,mobile_no,is_api_available,
				url,api_key,created_at,created_by,created_by_ip 
				FROM t_vehicle_group WHERE group_id=p_group_id;
		
		UPDATE t_vehicle_group Set 
			group_name=p_group_name,
			email_id=p_email_id,
			mobile_no=p_mobile_no,
			/* login_id=p_group_login_id, */
			updated_at=now(),
			is_api_available=p_is_api_available,
			url=p_url,
			api_key=p_api_key 
		WHERE group_id=p_group_id;
			
		--UPDATE t_login SET username=p_group_name,email_id=p_email_id,mobile_no=p_mobile_no WHERE login_id=p_group_login_id;
	    UPDATE users SET 
		    name = p_group_name,
			username = p_group_name,
			email = p_email_id,
			mobile_no = p_mobile_no
		    WHERE login_id=p_group_login_id;
		_response := 'SUCCESS#Group has been successfully updated!';
	ELSE
	_response := 'FAIL#A record with this login id already exists.';
	END IF; 
	EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'FAIL#Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_login_id,p_ip_address);	
				END;
 
END;
$BODY$;



-----------------------------------------------------------------------------------------------


-- Create New Procedure


CREATE OR REPLACE PROCEDURE public.delete_group_name(
	p_group_id integer,
	p_login_id character varying,
	p_state_id smallint,
	p_ip_address character varying,
	p_group_login_id character varying,
	INOUT _response text DEFAULT NULL::text
)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN
		
		INSERT INTO t_vehicle_group_log(group_id, login_id, group_name, email_id, 
										mobile_no, is_api_available, url, api_key, 
										created_at, created_by, created_by_ip)
			SELECT group_id, login_id, group_name, email_id, 
					mobile_no, is_api_available, url, api_key, 
					now(), created_by, created_by_ip 
					FROM t_vehicle_group WHERE group_id=p_group_id;

		INSERT INTO t_vehicle_group_mapping_log(group_id, vehicle_reg_no, created_at)
			SELECT group_id, vehicle_reg_no, now() 
					FROM t_vehicle_group_mapping WHERE group_id=p_group_id;
				
		-- Insert into LoginLog	
			INSERT INTO t_login_log(state_id,role_id,login_id,login_password,
					username,mobile_no,email_id,is_first_time_login,last_login_time ,
    				last_login_ip,created_at, created_by, created_by_ip)
            SELECT state_id, role_id, login_id, password, 
					name, mobile_no, email, is_first_time_login, last_login_time, 
					last_login_ip, now(), login_id, last_login_ip
            FROM users WHERE login_id=p_group_login_id;						

		DELETE FROM t_vehicle_group WHERE group_id=p_group_id;
		DELETE FROM t_vehicle_group_mapping WHERE group_id=p_group_id;
		DELETE FROM users WHERE login_id=p_group_login_id AND role_id=13;

		_response := 'SUCCESS#Group deleted successfully!';
			    
	EXCEPTION
			  	WHEN others THEN
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;

				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_login_id,p_ip_address);	
				END;
END;
$BODY$;


-------------------------------------------------------------------------------------------------------------

-- Date: 07-08-2024

-- Update in Procedure


CREATE OR REPLACE PROCEDURE public.update_vehicle_route(
	p_route_mapping_id integer,
	p_route_id integer,
	p_vehicle_registration_number character varying,
	p_trip_days_code character varying,
	p_trip_start_time time without time zone,
	p_trip_duration_in_minute integer,
	p_login_id character varying,
	p_ip_address character varying,
	p_state_id smallint DEFAULT 5,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
  DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN 
	BEGIN 
		--CREATE TEMPORARY TABLE IF NOT EXISTS tmp_Message (Status char(1),StatusMessage varchar(255),ErrorCode varchar(5));

		INSERT INTO t_vehicle_route_mapping_log 
			SELECT route_mapping_id,vehicle_registration_number,route_id,trip_days_code,
					trip_start_time,trip_duration_in_minute,NOW() 
		     FROM t_vehicle_route_mapping WHERE route_mapping_id=p_route_mapping_id;

       	UPDATE t_vehicle_route_mapping SET 
					vehicle_registration_number= p_vehicle_registration_number,
					route_id=p_route_id,
					trip_days_code=p_trip_days_code,
	           		trip_start_time=p_trip_start_time,
					trip_duration_in_minute=p_trip_duration_in_minute 
				WHERE route_mapping_id=p_route_mapping_id; 
				
		_response := 'SUCCESS#Edit Vehicle mapped successfully';

		EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'FAIL#Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_login_id,p_ip_address);	
				END;
		
END;  
$BODY$;


---------------------------------------------------------------------------------------------

-- Date: 08-08-2024

-- Create New Function 


CREATE OR REPLACE FUNCTION public.f_get_device_not_sending_data_vehicle_wise(
	)
    RETURNS TABLE(contractcarriagebus bigint, maxicab bigint, motorcab bigint, schoolbus bigint, citybus bigint, utcbus bigint, stagecarriages bigint, privateservuicebus bigint, goodvehiclenp bigint, goodvehicle bigint, threewheeledvehicles bigint, erickshaw bigint, ambulancevehicle bigint, governmentvehicle bigint, passengercarnt bigint, twowheelervehicle bigint, constructionequipmentvehicle bigint, tractorvehicle bigint) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE
		v_contract_carriage_bus bigint;
		v_maxi_cab bigint;
		v_motor_cab bigint;
		v_school_bus bigint;
		v_city_bus bigint;
		v_utc_bus bigint;
		v_stage_carriages_others bigint;
		v_private_service_bus bigint;
		v_good_vehicles_np bigint;
		v_good_vehicles bigint;
		v_three_wheeled_vehicles bigint;
		v_e_rickshaw bigint;
		v_ambulance bigint;
		v_government_vehicles bigint;
		v_passenger_car_nt bigint;
		v_two_wheeler bigint;
		v_construction_equipment_vehicle bigint;
		v_tractor bigint;
BEGIN
	
	SELECT COUNT(c.vehicle_name) INTO v_contract_carriage_bus FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Contract Carriage(Bus)';
	SELECT COUNT(c.vehicle_name) INTO v_maxi_cab FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Maxi Cab';
	SELECT COUNT(c.vehicle_name) INTO v_motor_cab FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Motor Cab';
	SELECT COUNT(c.vehicle_name) INTO v_school_bus FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'School Bus';
	SELECT COUNT(c.vehicle_name) INTO v_city_bus FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'City Bus';
	SELECT COUNT(c.vehicle_name) INTO v_utc_bus FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'UTC Bus';
	SELECT COUNT(c.vehicle_name) INTO v_stage_carriages_others FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Stage Carriages (others)';
	SELECT COUNT(c.vehicle_name) INTO v_private_service_bus FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Private Service Bus';
	SELECT COUNT(c.vehicle_name) INTO v_good_vehicles_np FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Good Vehicles(NP)';
	SELECT COUNT(c.vehicle_name) INTO v_good_vehicles FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Good Vehicles';
	SELECT COUNT(c.vehicle_name) INTO v_three_wheeled_vehicles FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Three wheeled Vehicles';
	SELECT COUNT(c.vehicle_name) INTO v_e_rickshaw FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'E-Rickshaw';
	SELECT COUNT(c.vehicle_name) INTO v_ambulance FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Ambulance';
	SELECT COUNT(c.vehicle_name) INTO v_government_vehicles FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Government Vehicles';
	SELECT COUNT(c.vehicle_name) INTO v_passenger_car_nt FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Passenger Car(NT)';
	SELECT COUNT(c.vehicle_name) INTO v_two_wheeler FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Two wheeler';
	SELECT COUNT(c.vehicle_name) INTO v_construction_equipment_vehicle FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Construction Equipment Vehicle';
	SELECT COUNT(c.vehicle_name) INTO v_tractor FROM  f_view_vehicle_tracking_status p INNER JOIN t_vehicle_type_master c ON c.vehicle_name = p.vehicle_name WHERE c.vehicle_name = 'Tractor';

	RETURN QUERY
	SELECT 
		v_contract_carriage_bus,
		v_maxi_cab,
		v_motor_cab,
		v_school_bus,
		v_city_bus,
		v_utc_bus,
		v_stage_carriages_others,
		v_private_service_bus,
		v_good_vehicles_np,
		v_good_vehicles,
		v_three_wheeled_vehicles,
		v_e_rickshaw,
		v_ambulance,
		v_government_vehicles,
		v_passenger_car_nt,
		v_two_wheeler,
		v_construction_equipment_vehicle,
		v_tractor;
END
$BODY$;


-----------------------------------------------------------------------------------------------------------


-- Create New FUNCTION


CREATE OR REPLACE FUNCTION public.f_list_last_alert_activated_device2(
	p_device_type integer,
	p_group_id integer DEFAULT 0,
	p_login_id character varying DEFAULT ''::character varying)
    RETURNS TABLE(val_row1 text, val_1 integer, val_2 integer, val_3 integer, val_4 integer, val_5 integer, val_6 integer, val_7 integer, val_8 integer, val_9 integer, val_10 integer, val_11 integer, val_12 integer, val_13 integer, val_14 integer, val_15 integer, val_16 integer) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
		
BEGIN

IF(p_device_type = 2)THEN
RETURN QUERY
SELECT *
FROM   crosstab(
   
	'select ''row1'' as rowid,tm.dt, (case when t1.cnt is null then 0::int else t1.cnt::int end) as cnt 
from (SELECT dt fROM generate_series(1,16) as dt) as tm 
left join
(select ma.alert_id as message_id, count(ma.alert_id) as cnt
from pvt.t_vltd_pvt_pkt_latest v inner join t_message_and_alerts_master ma on (v.alert_id=ma.alert_id) 
	where f_date_diff_in_hour(server_log_date_time,now())>24
	group by ma.alert_id) as t1
	  on (dt = t1.message_id) order by 1,2'
   ) AS ct ("row1" text,"c1" int, "c2" int,"c3" int,"c4" int,"c5" int,"c6" int,"c7" int,"c8" int,"c9" int,"c10" int,"c11" int,"c12" int,"c13" int,
			"c14" int,"c15" int,"c16" int);
ELSE 
RETURN QUERY
SELECT *
FROM   crosstab(
   
	'select ''row1'' as rowid,tm.dt, (case when t1.cnt is null then 0::int else t1.cnt::int end) as cnt 
from (SELECT dt fROM generate_series(1,16) as dt) as tm 
left join
(select ma.alert_id as message_id, count(ma.alert_id) as cnt
from pvt.t_vltd_pvt_pkt_latest v 
	INNER JOIN t_vltd_cum_vehicle_details as vv  ON v.imei=vv.imei
	INNER JOIN t_message_and_alerts_master as ma on (v.alert_id=ma.alert_id) 
    INNER JOIN t_vltd_activation_details  as vad ON v.imei=vad.imei  
	WHERE f_date_diff_in_min(server_log_date_time,now())<=10 
	AND ('''||p_group_id ||''' = 0 OR vv.vehicle_reg_no in(SELECT vehicle_reg_no FROM t_vehicle_group_mapping Where group_id='''|| p_group_id ||''' ) 
    AND('''||p_login_id ||''' = '''' OR arto_id='''||p_login_id ||'''))
	GROUP BY ma.alert_id) as t1
	  on (dt = t1.message_id) order by 1,2'
   ) AS ct ("row1" text,"c1" int, "c2" int,"c3" int,"c4" int,"c5" int,"c6" int,"c7" int,"c8" int,"c9" int,"c10" int,"c11" int,"c12" int,"c13" int,
			"c14" int,"c15" int,"c16" int);
END IF;

END;
$BODY$;


----------------------------------------------------------------------------------------------------


-- Date: 12-08-2024

-- Update in Function 


CREATE OR REPLACE FUNCTION public.f_list_device_manufacturer_cum_vendor(
	)
    RETURNS TABLE(val_vendor_id character varying, val_manufacture_name text, val_approved_device_modal character varying, val_device_model character varying, val_cop_date date, val_device_number text, val_contcat_person_name text, val_mobile_no character, val_email_id character varying, val_is_active character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 				SELECT
				m.vendor_id,
				upper(m.manufacturer_name) as manufacturer_name,
				CASE WHEN d.device_model IS NULL THEN approved_device_modal ELSE d.device_model END,
				d.device_model,
				d.cop_date,
				'' as device_number,
				UPPER(contact_person_name) AS contact_person_name,
				m.mobile_no,
				m.email_id,
				m.is_active 
				FROM t_device_manufacturer_cum_vendor as m 
				LEFT JOIN t_device_model as d ON m.vendor_id=d.vendor_id AND
				m.vendor_id NOT IN(Select vendor_id From t_vltd_model_block_details 
									Where block_type='1' );
									
END;
$BODY$;


-------------------------------------------------------------------------------------------------------------


-- Date: 13-08-2024

-- Update in Procedure

CREATE OR REPLACE PROCEDURE public.add_manufacturer_cum_device_model_block_details(
	p_block_type smallint,
	p_vendor_id character varying,
	p_device_model character varying,
	p_reason integer,
	p_remark character varying,
	p_letter_number character varying,
	p_letter_date character varying,
	p_letter bytea,
	p_state_id smallint,
	p_ip_address character varying,
	p_login_id character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
		   DECLARE 
		   	v_state   TEXT;
			v_msg     TEXT;
			v_detail  TEXT;
			v_hint    TEXT;
			v_context TEXT;
		  	v_vendor_mobile_no char(10)=null;
BEGIN
	BEGIN

   		Select mobile_no Into v_vendor_mobile_no From t_device_manufacturer_cum_vendor 
				Where vendor_id=p_vendor_id;
		
		INSERT INTO t_vltd_model_block_details(block_type,vendor_id,device_model,reason,
											  remark,block_letter_number,block_letter_date,
											   block_letter,created_at,created_by,created_by_ip)
		Values(p_block_type,p_vendor_id,p_device_model,p_reason,
			   	p_remark,p_letter_number,p_letter_date::date,
			   		p_letter,now(),p_login_id,p_ip_address);
 		
		_response:= CASE WHEN p_block_type='2' Then  'VLTD model ('||p_device_model||') has been Blocked Successfully,'||v_vendor_mobile_no When p_block_type='1' THEN 'Manufacture And all Device Models has been Blocked Successfully,'||v_vendor_mobile_no ELSE '' END;
		
		UPDATE t_device_manufacturer_cum_vendor set is_active= CASE WHEN p_block_type='2' Then 'P' ELSE 'N' END Where vendor_id=p_vendor_id;

				EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
 				_response := 'Something went wrong. Please Contact to System Administrator.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_login_id,p_ip_address);	
				END;
				
END;
$BODY$;

-----------------------------------------------------------------------------


-- Update in FUNCTION

CREATE OR REPLACE FUNCTION public.f_get_vendor_list(
	)
    RETURNS TABLE(val_vendor_id character varying, val_manufacturer_name character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY
    SELECT dmcv.vendor_id, dmcv.manufacturer_name
    FROM t_device_manufacturer_cum_vendor dmcv
    WHERE dmcv.vendor_id NOT IN (
        SELECT vendor_id 
        FROM t_vltd_model_block_details 
        WHERE block_type = '1'
    );
END;
$BODY$;

------------------------------------------------------------------

-- Update in FUNCTION


CREATE OR REPLACE FUNCTION public.get_sys_dashboard_count(
	)
    RETURNS TABLE(val_rto bigint, val_arto bigint, val_user_count bigint, val_vehicle_class bigint, val_vehicle_fuel bigint, val_role_count bigint, val_unblocked bigint, val_block_vendor bigint, val_active bigint, val_inactive bigint) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
    RETURN QUERY
    SELECT 
        COALESCE((SELECT COUNT(1) FROM t_rto_master), 0) AS rto,
        COALESCE((SELECT COUNT(1) FROM t_arto_master), 0) AS arto,
        COALESCE((SELECT COUNT(1) FROM users WHERE role_id NOT IN ('4', '5')), 0) AS user_count,
        COALESCE((SELECT COUNT(1) FROM t_vehicle_type_master), 0) AS vehicle_class,
        COALESCE((SELECT COUNT(1) FROM t_vehicle_type_master), 0) AS vehicle_fuel,
        COALESCE((SELECT COUNT(1) FROM t_designation_master), 0) AS role_count,
        COALESCE((SELECT COUNT(1) FROM t_device_manufacturer_cum_vendor WHERE vendor_id NOT IN 
                 (SELECT vendor_id FROM t_vltd_model_block_details WHERE block_type = 1)), 0) AS unblocked,
        COALESCE((SELECT COUNT(1) FROM t_vltd_model_block_details WHERE block_type = 1), 0) AS block_vendor,
        COALESCE((SELECT COUNT(1) FROM users WHERE is_active = 'Y' AND role_id NOT IN ('4', '5')), 0) AS active,
        COALESCE((SELECT COUNT(1) FROM users WHERE is_active = 'N' AND role_id NOT IN ('4', '5')), 0) AS inactive;
END;
$BODY$;

------------------------------------------------------------------------------------------

-- Update in Function 


CREATE OR REPLACE FUNCTION public.f_list_device_manufacturer_cum_vendor(
	)
    RETURNS TABLE(val_vendor_id character varying, val_manufacture_name text, val_approved_device_modal character varying, val_device_model character varying, val_cop_date date, val_device_number text, val_contcat_person_name text, val_mobile_no character, val_email_id character varying, val_is_active character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 				SELECT
				m.vendor_id,
				upper(m.manufacturer_name) as manufacturer_name,
				CASE WHEN d.device_model IS NULL THEN approved_device_modal ELSE d.device_model END,
				d.device_model,
				d.cop_date,
				'' as device_number,
				UPPER(contact_person_name) AS contact_person_name,
				m.mobile_no,
				m.email_id,
				m.is_active 
				FROM t_device_manufacturer_cum_vendor as m 
				LEFT JOIN t_device_model as d ON m.vendor_id=d.vendor_id AND
				m.vendor_id NOT IN(Select vendor_id From t_vltd_model_block_details 
									Where block_type='1' );
									
END;
$BODY$;



-------------------------------------------------------------------------------------------------------------


-- Date: 14-08-2024


-- Create new FUNCTION

CREATE OR REPLACE FUNCTION public.f_device_manufacturer_cum_vendor_by_vendor_id(
	par_vendor_id character varying)
    RETURNS SETOF public.t_device_manufacturer_cum_vendor 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 		
		SELECT * FROM public.t_device_manufacturer_cum_vendor AS tdmcv 
			WHERE tdmcv.vendor_id = par_vendor_id;
END;
$BODY$;

----------------------------------------------------------------------------------


-- Date: 02-09-2024

-- Update Table columns in t_device_model


CREATE TABLE IF NOT EXISTS public.t_device_model
(
    vendor_id character varying(20) COLLATE pg_catalog."default" NOT NULL,
    device_model character varying(100) COLLATE pg_catalog."default" NOT NULL,
    cop_date date,
	
    firmware_verison character varying COLLATE pg_catalog."default",
    firmware_binaries character varying COLLATE pg_catalog."default",
    firmware_binaries_upload_date_time timestamp without time zone,
    check_sum_hash character(32) COLLATE pg_catalog."default",
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    ip_address character varying COLLATE pg_catalog."default",
    is_active character(1) COLLATE pg_catalog."default",
    cop_document bytea,
    cop_certificate_no character varying COLLATE pg_catalog."default",
    cop_document_upload_date_time timestamp without time zone,
    CONSTRAINT pk_devicemodel PRIMARY KEY (vendor_id, device_model)
)


------------------------------------------------------------------------------------------

-- Update Table columns in t_device_model_log


CREATE TABLE IF NOT EXISTS public.t_device_model_log
(
    vendor_id character varying(20) COLLATE pg_catalog."default" NOT NULL,
    device_model character varying(100) COLLATE pg_catalog."default" NOT NULL,
    cop_date date,
    firmware_verison character varying COLLATE pg_catalog."default",
    firmware_binaries character varying COLLATE pg_catalog."default",
    firmware_binaries_upload_date_time timestamp without time zone,
    check_sum_hash character(32) COLLATE pg_catalog."default",
    created_at timestamp without time zone,
    updated_at timestamp without time zone,
    ip_address character varying COLLATE pg_catalog."default",
    is_active character(1) COLLATE pg_catalog."default",
    cop_document bytea,
    cop_certificate_no character varying COLLATE pg_catalog."default",
    cop_document_upload_date_time timestamp without time zone
)
      

-----------------------------------------------------------------------------------

t_vltd_model_unblock_details

-- Update in Procedure

CREATE OR REPLACE PROCEDURE public.add_manufacturer_cum_device_model_unblock_details(
	p_block_type smallint,
	p_vendor_id character varying,
	p_device_model character varying,
	p_remark character varying,
	p_letter_number character varying,
	p_letter_date timestamp without time zone,
	p_letter bytea,
	p_state_id smallint,
	p_ip_address character varying,
	p_login_id character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
 			v_state   TEXT;
			v_msg     TEXT;
			v_detail  TEXT;
			v_hint    TEXT;
			v_context TEXT;
BEGIN
	BEGIN

		   IF(p_block_type='1')
		   THEN
				INSERT INTO t_vltd_model_block_details_log(block_type,vendor_id,device_model,reason,remark,block_letter_number,block_letter_date,block_letter,created_at,created_by,created_by_ip)
				Select block_type,vendor_id,device_model,reason,remark,block_letter_number,block_letter_date,block_letter,NOW(),p_login_id,p_ip_address From t_vltd_model_block_details Where vendor_id=p_vendor_id;
		   		Delete From t_vltd_model_block_details Where vendor_id=p_vendor_id;
				
				INSERT INTO t_device_model_log
				SELECT * FROM t_device_model WHERE vendor_id=p_vendor_id AND device_model IN(SELECT ITEM FROM f_udf_split_string(p_device_model,','));
			    UPDATE t_device_model SET is_active='Y',updated_at=NOW() WHERE vendor_id=p_vendor_id;
				
		   ELSE
				INSERT INTO t_vltd_model_block_details_log(block_type,vendor_id,device_model,reason,remark,block_letter_number,block_letter_date,block_letter,created_at,created_by,created_by_ip)
				Select block_type,vendor_id,device_model,reason,remark,block_letter_number,block_letter_date,block_letter,NOW(),p_login_id,p_ip_address From t_vltd_model_block_details Where vendor_id=p_vendor_id and device_model=p_device_model;
		   		Delete From t_vltd_model_block_details Where vendor_id=p_vendor_id and device_model=p_device_model;
				
				INSERT INTO t_device_model_log
				SELECT * FROM t_device_model WHERE vendor_id=p_vendor_id;
			    UPDATE t_device_model SET is_active='Y',updated_at=NOW() WHERE vendor_id=p_vendor_id AND device_model IN(SELECT ITEM FROM f_udf_split_string(p_device_model,','));
				
				
		   END IF;

			INSERT INTO t_vltd_model_unblock_details(block_type,vendor_id,device_model,remark,unblock_letter_number,unblock_letter_date,unblock_letter,created_at,created_by,created_by_ip)
										Values(p_block_type,p_vendor_id,p_device_model,p_remark,p_letter_number,p_letter_date,p_letter,now(),p_login_id,p_ip_address);
			
			IF NOT EXISTS(Select vendor_id FROM  t_vltd_model_block_details Where vendor_id=p_vendor_id  )
			THEN
				UPDATE t_device_manufacturer_cum_vendor set is_active= 'Y' Where vendor_id=p_vendor_id;
			END IF;
			 
			 _response:= Case When p_block_type='2' Then  'VLTD model ('||p_device_model||') has been Unblocked' When p_block_type='1' THEN 'Manufacture And all Device Models has been Unblocked Successfully' ELSE '' END;
			
			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
				_response := 'Something went wrong. Please Contact to System Administrator.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_login_id,p_ip_address);	
				END;
END;
$BODY$;


-------------------------------------------------------------------------------------------------------

-- Date: 03-09-2024

-- Table t_project_details_master Column Add

	password_life_in_days character varying,
    password_alert_msg_days character varying,


--------------------------------------------------------------------


-- Update in Function f_list_project_details()


CREATE OR REPLACE FUNCTION public.f_list_project_details(
	par_state_id integer)
    RETURNS TABLE(val_department_name character varying, val_goverment character varying, 
	val_project_title character varying, val_logo character varying, 
	val_project_subtitle character varying, val_office_address character varying, 
	val_mail_id character varying, val_contact_number character varying, 
	val_latitude double precision, val_longitude double precision, 
	val_base_url character varying, val_map_key character varying, 
	val_is_permit_login_enable character, val_pull_sms_mobile_no character,
	val_password_life_in_days character varying, val_password_alert_msg_days character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 				select 
				department_name ,
				goverment ,
				project_title ,
				state_logo_path AS logo,
				project_subtitle,
				office_address,
				mail_id,
				contact_number,
				latitude,
				longitude,
				base_url,
				map_key,				
				COALESCE(is_permit_login_enable, 'N') AS is_permit_login_enable,
				pull_sms_mobile_no,
				password_life_in_days,
				password_alert_msg_days
				from t_project_details_master where state_id=par_state_id;
END;
$BODY$;


----------------------------------------------------------------------------------------


-- Update in Procedure add_project_details()


CREATE OR REPLACE PROCEDURE public.add_project_details(
	p_project_title character varying,
	p_project_sub_title character varying,
	p_department_name character varying,
	p_goverment character varying,
	p_state_id smallint,
	p_office_address character varying,
	p_contact_number character,
	p_mail_id character varying,
	p_latitude double precision,
	p_longitude double precision,
	p_base_url character varying,
	p_map_key character varying,
	p_password_life_in_days character varying,
	p_password_alert_msg_days character varying,
	p_state_logo_path character varying DEFAULT NULL::character varying,
	p_is_permit_login_enable character DEFAULT NULL::character(1),
	p_pull_sms_mobile_no character DEFAULT NULL::character(1),		
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
Declare 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN

	IF(p_state_logo_path='') THEN p_state_logo_path= NULL; END IF;

	BEGIN
		IF NOT Exists(Select state_id From t_project_details_master Where state_id=p_state_id)
		THEN
		INSERT into t_project_details_master(project_title,project_subtitle,department_name,
					development_agency,goverment,state_id,office_address,contact_number,
					mail_id,latitude,longitude,base_url,map_key,state_logo_path,
									is_permit_login_enable,pull_sms_mobile_no)
		Values(p_project_title,p_project_sub_title,p_department_name,
			   'NA',p_goverment,p_state_id,p_office_address,p_contact_number,
			   p_mail_id,p_latitude,p_longitude,p_base_url,p_map_key,p_state_logo_path,
			   p_is_permit_login_enable,p_pull_sms_mobile_no);
			_response := 'Added Project Details Successfully';  
		ELSE

		Update t_project_details_master SET project_title=p_project_title,
				project_subtitle=p_project_sub_title, department_name=p_department_name,
				goverment=p_goverment, office_address=p_office_address,
				contact_number=p_contact_number,mail_id=p_mail_id,
				latitude=p_latitude,longitude=p_longitude,
				base_url=p_base_url,map_key=p_map_key,
			state_logo_path=Case When COALESCE(p_state_logo_path,'')='' 
				Then state_logo_path ELSE p_state_logo_path END,
	is_permit_login_enable = p_is_permit_login_enable, 
	pull_sms_mobile_no=p_pull_sms_mobile_no,
	password_life_in_days = p_password_life_in_days,
	password_alert_msg_days = p_password_alert_msg_days	
			Where state_id=p_State_id;
			_response := 'Updated Project Details Successfully';  
		END IF;

			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
				_response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(0,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA','NA');	
				END;
END;
$BODY$;

--------------------------------------------------------


-- Add Column in Table User

	last_password_updated_at timestamp without time zone

----------------------------------------------------------------------

-- Update In Function f_user_authentication()


CREATE OR REPLACE FUNCTION public.f_user_authentication(
	p_login_id character varying,
	p_password character,
	p_salt_value character varying,
	p_ip_address character varying,
	p_state_id smallint)
    RETURNS TABLE(val_flag character varying, val_state_name character varying, val_state_id smallint, val_id integer, val_role_id smallint, val_role_name character varying, val_is_first_time_login character varying, val_mobile_no character varying, val_name character varying, val_login_id character varying, val_manufacturer_name character varying, val_vendor_id character varying, val_approved_device_modal character varying, val_message character varying, val_state_short_name character varying, val_group_id character varying, val_group_name character varying, val_ota_command_set_count character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE 
	v_district varchar(25);
	v_server_password char(64); 
	v_name varchar(50);
	v_mobile_no char(10);
    v_salted_hash_password1 bytea; 
    v_salted_hash_password_server char(64); 
	v_is_first_time_login char(1);
	v_id integer;
	v_role_id smallint;
	v_role_name character varying(100);
	v_state_id smallint;
	v_state_short_name char(2);
	v_state_name varchar(50);
	v_vendor_id varchar(20)=null;
	v_approved_device_modal varchar(500)=null;
	v_manufacturer_name varchar(50)=null;
	v_group_id int=null;
	v_group_name varchar(250)=null;
	v_ota_command_set_count int=null;
	v_password_life integer;
	v_last_password_updated_days integer default 0;
BEGIN

         CREATE TEMPORARY TABLE IF NOT EXISTS temp_auth(
			 flag character varying,
			 state_name character varying,
			 state_id smallint,
			 id integer,
			 role_id smallint,
			 role_name character varying,
			 is_first_time_login character varying,
			 mobile_no character varying,
			 name character varying,
			 login_id character varying,
			 manufacturer_name character varying,
			 vendor_id character varying,
			 approved_device_modal character varying,
			 message character varying,
			 state_short_name character varying,
			 group_id character varying,
			 group_name character varying,
			 ota_command_set_count character varying
		 );
		 DELETE FROM temp_auth;

		 IF EXISTS(SELECT login_id FROM users WHERE UPPER(login_id)=p_login_id )
		  THEN

                        SELECT id,password,role_id,state_id,is_first_time_login,username,mobile_no INTO v_id,v_server_password, v_role_id, v_state_id, v_is_first_time_login, v_name, v_mobile_no FROM users WHERE UPPER(login_id)=p_login_id;
 						SELECT designation_name INTO v_role_name FROM t_designation_master WHERE designation_id = v_role_id::smallint LIMIT 1;
                        --v_SaltedHashPassword1 := Hashbytes('SHA2_256',Cast(v_ServerPassword + p_SaltValue AS TEXT)); 
                        --v_SaltedHashPasswordServer:=Lower(Cast('' AS  XML);.value('xs:hexBinary(sql:variable("@SaltedHashPassword1"))', 'varchar(max)')); 
						-- SaltedHashPasswordServer 
						v_salted_hash_password1 := sha256((v_server_password || $3)::bytea); 
						v_salted_hash_password_server:=SUBSTRING ( v_salted_hash_password1::text ,3  ); 
						IF(p_state_id<>v_state_id)THEN
						
     						INSERT INTO temp_auth
							SELECT 'Fail' AS Flag,'',0::smallint,0,0::smallint,'','','','','','','','','State ID not matched' AS Message,'','','','';
						--ELSIF (p_password=v_salted_hash_password_server)
						ELSIF (p_password=p_salt_value || v_server_password)
						  THEN
						  raise notice 'Valid';
                            UPDATE users set last_login_ip=p_ip_address,last_login_time=now() where UPPER(login_id)=p_login_id;
							    IF(v_role_id=4)
								THEN
								Select  count(1) Into v_ota_command_set_count from t_vltd_ota_commands Where UPPER(vendor_id)=p_login_id;
								END IF;
						    IF(v_role_id=5)
							  THEN
 								Select state_short_name_current,state_name into v_state_short_name,v_state_name from t_state_master where state_id=p_state_id;
     							SELECT vendor_id into v_vendor_id from t_retro_fitment_center_master where UPPER(rfc_id)=p_login_id;
 								SELECT manufacturer_name,approved_device_modal,vendor_id into v_manufacturer_name, v_approved_device_modal, v_vendor_id
								 from t_device_manufacturer_cum_vendor where vendor_id=v_vendor_id; 
							  END IF; 
							  IF(v_role_id=13)
							  THEN
  									Select group_id,group_name into v_group_id, v_group_name from t_vehicle_group where UPPER(login_id)=p_login_id;
							  END IF;
							  
								INSERT INTO temp_auth 
     							SELECT  'Success' AS Flag,v_state_name as state_name,p_state_id as state_id,v_id,v_role_id as role_id,v_role_name,v_is_first_time_login as is_first_time_login,v_mobile_no as mobile_no,v_name as name,p_login_id as login_id,v_manufacturer_name as manufacturer_name,
							 	v_vendor_id as vendor_id,v_approved_device_modal as approved_device_modal,'Successfully Login' AS message,v_state_short_name as state_short_name,v_group_id as group_id,v_group_name as group_name,coalesce(v_ota_command_set_count,0) as ota_command_set_count;
								
								
							
	--cheack last updated password duration
	IF(SELECT COUNT(1) FROM users where id = v_id AND last_password_updated_at is null)THEN
		UPDATE users SET last_password_updated_at = (select created_at from t_password_change_log where login_id = p_login_id order by created_at desc limit 1) where id=v_id;
		IF(SELECT COUNT(1) FROM users where id = v_id AND last_password_updated_at is null)THEN
			 UPDATE users SET last_password_updated_at = created_at where id = v_id;
		END IF;
	END IF;

	SELECT password_life_in_days INTO v_password_life FROM t_project_details_master limit 1;

	SELECT COALESCE(f_date_diff_in_day(current_date,last_password_updated_at::date),0) into v_last_password_updated_days from users where id=v_id;
	IF(v_last_password_updated_days > v_password_life)THEN 
			UPDATE users set is_first_time_login='Y' where id=v_id;
	END IF;
	--end
							
							
							
								
						ELSE
							INSERT INTO temp_auth 
     						SELECT 'Fail' AS Flag,'',0::smallint,0,0::smallint,'','','','','','','','','Invalid Credentials.' AS Message,'','','','';
						 END IF;
					    
	  ELSE
	  	INSERT INTO temp_auth 
     	SELECT 'Fail' AS Flag,'',0::smallint,0,0::smallint,'','','','','','','','','Invalid Credentails. ' AS Message,'','','','';
	  END IF;
	 
	 RETURN QUERY 
	 select * from temp_auth;
END;
$BODY$;

---------------------------------------------------------------------

Hrvlt@?2024

VltHr@2022


---------------------------------------------------------------



-- Date: 04-09-2024

-- Update in Function edit_password()


CREATE OR REPLACE PROCEDURE public.edit_password(
	p_login_id character varying,
	p_current_password character varying,
	p_new_password character varying,
	p_ip_address character varying,
	p_salt_value character varying DEFAULT NULL::character varying,
	INOUT _response text DEFAULT NULL::character varying)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_password text;
BEGIN
	BEGIN
		CREATE TEMPORARY TABLE IF NOT EXISTS tmp_temp (pass char(64));
		DELETE FROM tmp_Temp;

		SELECT password INTO v_password FROM users WHERE UPPER(Login_ID) = UPPER(p_login_id); 

		INSERT INTO tmp_temp
		SELECT password FROM t_password_change_log WHERE UPPER(login_id) = UPPER(p_login_id)   ORDER BY created_at DESC Limit 3;

		IF NOT EXISTS(SELECT pass FROM tmp_temp WHERE pass =p_new_password Limit 3)THEN
		IF(v_password=p_current_password) THEN
		  IF(v_password<>p_new_password)THEN
			  INSERT INTO t_password_change_log
			  SELECT p_login_id,p_current_password,now(),p_login_id,p_ip_address;

			  INSERT  INTO t_login_log
			  SELECT state_id,role_id,login_id,password,username,mobile_no,email,is_first_time_login,last_login_time,last_login_ip,now(),p_login_id,p_ip_address FROM users WHERE UPPER(login_id)=UPPER(p_login_id);

			  UPDATE users SET password=p_new_password,is_first_time_login='N',last_password_updated_at=now() WHERE UPPER(login_id) = UPPER(p_login_id);
				_response := 'SUCCESS#Password has been changed successfully. Please Sign out and Sign in Again.';
			  ELSE
				_response := 'FAIL#This password is alraedy used in previous. Please enter different password.';
			  END IF;
		  ELSE
				_response := 'FAIL#Please enter correct current password.';
		   END IF;
		ELSE
			_response := 'FAIL#This password is alraedy used in previous. Please enter different password.';
		END IF;
	

			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'FAIL#Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(0,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_login_id,p_ip_address);	
				END;

END;
$BODY$;


--------------------------------------------------

-- CREATE New Table t_2fa_questions_master

CREATE TABLE IF NOT EXISTS public.t_2fa_questions_master
(
    id serial PRIMARY KEY,
    questions text NOT NULL,    
    created_by character varying,
    updated_by character varying,    
    created_at timestamp without time zone,
    updated_at timestamp without time zone
)

---------------------------------------------------------

-- Add new Column questions_2fa_status character length 1 in Table master_project_details.

-- Add Column Name two_factor_questions character length 1 in User Table. 


------------------------------------------------------------------

-- Update in Function f_list_project_details()


CREATE OR REPLACE FUNCTION public.f_list_project_details(
	par_state_id integer)
    RETURNS TABLE(val_department_name character varying, val_goverment character varying, val_project_title character varying, val_logo character varying, val_project_subtitle character varying, val_office_address character varying, val_mail_id character varying, val_contact_number character varying, val_latitude double precision, val_longitude double precision, val_base_url character varying, val_map_key character varying, val_is_permit_login_enable character, val_pull_sms_mobile_no character, val_password_life_in_days character varying, val_password_alert_msg_days character varying,val_questions_2fa_status character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 				select 
				department_name ,
				goverment ,
				project_title ,
				state_logo_path AS logo,
				project_subtitle,
				office_address,
				mail_id,
				contact_number,
				latitude,
				longitude,
				base_url,
				map_key,				
				COALESCE(is_permit_login_enable, 'N') AS is_permit_login_enable,
				pull_sms_mobile_no,
				password_life_in_days,
				password_alert_msg_days,
				questions_2fa_status
				from t_project_details_master where state_id=par_state_id;
END;
$BODY$;


---------------------------------------------------------------------------------

-- Update in Procedure add_project_details()


CREATE OR REPLACE PROCEDURE public.add_project_details(
	p_project_title character varying,
	p_project_sub_title character varying,
	p_department_name character varying,
	p_goverment character varying,
	p_state_id smallint,
	p_office_address character varying,
	p_contact_number character,
	p_mail_id character varying,
	p_latitude double precision,
	p_longitude double precision,
	p_base_url character varying,
	p_map_key character varying,
	p_password_life_in_days character varying,
	p_password_alert_msg_days character varying,
	p_questions_2fa_status character,
	p_state_logo_path character varying DEFAULT NULL::character varying,
	p_is_permit_login_enable character DEFAULT NULL::character(1),
	p_pull_sms_mobile_no character DEFAULT NULL::character(1),
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
Declare 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN

	IF(p_state_logo_path='') THEN p_state_logo_path= NULL; END IF;

	BEGIN
		IF NOT Exists(Select state_id From t_project_details_master Where state_id=p_state_id)
		THEN
		INSERT into t_project_details_master(project_title,project_subtitle,department_name,
					development_agency,goverment,state_id,office_address,contact_number,
					mail_id,latitude,longitude,base_url,map_key,state_logo_path,
									is_permit_login_enable,pull_sms_mobile_no)
		Values(p_project_title,p_project_sub_title,p_department_name,
			   'NA',p_goverment,p_state_id,p_office_address,p_contact_number,
			   p_mail_id,p_latitude,p_longitude,p_base_url,p_map_key,p_state_logo_path,
			   p_is_permit_login_enable,p_pull_sms_mobile_no);
			_response := 'Added Project Details Successfully';  
		ELSE

		Update t_project_details_master SET project_title=p_project_title,
				project_subtitle=p_project_sub_title, department_name=p_department_name,
				goverment=p_goverment, office_address=p_office_address,
				contact_number=p_contact_number,mail_id=p_mail_id,
				latitude=p_latitude,longitude=p_longitude,
				base_url=p_base_url,map_key=p_map_key,
			state_logo_path=Case When COALESCE(p_state_logo_path,'')='' 
				Then state_logo_path ELSE p_state_logo_path END,
	is_permit_login_enable = p_is_permit_login_enable, 
	pull_sms_mobile_no=p_pull_sms_mobile_no,
	password_life_in_days = p_password_life_in_days,
	password_alert_msg_days = p_password_alert_msg_days,
	questions_2fa_status = p_questions_2fa_status
			Where state_id=p_State_id;
			_response := 'Updated Project Details Successfully';  
		END IF;

			EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
				_response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(0,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA','NA');	
				END;
END;
$BODY$;


-----------------------------------------------------------------

-- Create New Function f_get_2fa_questions()


CREATE OR REPLACE FUNCTION public.f_get_2fa_questions(
	)
    RETURNS SETOF t_2fa_questions_master 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
BEGIN
 RETURN QUERY 
 		
		SELECT * FROM public.t_2fa_questions_master ORDER BY id ASC;
END;
$BODY$;

--------------------------------------------------------------------------------

-- Create New Table t_2fa_questions_answer_master

CREATE TABLE IF NOT EXISTS public.t_2fa_questions_answer_master
(
    id BIGSERIAL PRIMARY KEY,
    question_id integer NOT NULL, 
	answer text NOT NULL,	
	login_id character varying NOT NULL,
    created_by character varying,    
    created_at timestamp without time zone,
    ip_address character varying NOT NULL
)

--------------------------------------------------------------------------------------------------------------------------

-- Date: 05-09-2024

-- Update in Function f_user_authentication()


CREATE OR REPLACE FUNCTION public.f_user_authentication(
	p_login_id character varying,
	p_password character,
	p_salt_value character varying,
	p_ip_address character varying,
	p_state_id smallint)
    RETURNS TABLE(val_flag character varying, val_state_name character varying, val_state_id smallint, val_id integer, val_role_id smallint, val_role_name character varying, val_is_first_time_login character varying, val_mobile_no character varying, val_name character varying, val_login_id character varying, val_manufacturer_name character varying, val_vendor_id character varying, val_approved_device_modal character varying, val_message character varying, val_state_short_name character varying, val_group_id character varying, val_group_name character varying, val_ota_command_set_count character varying, val_two_factor_questions  character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE 
	v_district varchar(25);
	v_server_password char(64); 
	v_name varchar(50);
	v_mobile_no char(10);
    v_salted_hash_password1 bytea; 
    v_salted_hash_password_server char(64); 
	v_is_first_time_login char(1);
	v_id integer;
	v_role_id smallint;
	v_role_name character varying(100);
	v_state_id smallint;
	v_state_short_name char(2);
	v_state_name varchar(50);
	v_vendor_id varchar(20)=null;
	v_approved_device_modal varchar(500)=null;
	v_manufacturer_name varchar(50)=null;
	v_group_id int=null;
	v_group_name varchar(250)=null;
	v_ota_command_set_count int=null;
	v_password_life integer;
	v_last_password_updated_days integer default 0;
BEGIN

         CREATE TEMPORARY TABLE IF NOT EXISTS temp_auth(
			 flag character varying,
			 state_name character varying,
			 state_id smallint,
			 id integer,
			 role_id smallint,
			 role_name character varying,
			 is_first_time_login character varying,
			 mobile_no character varying,
			 name character varying,
			 login_id character varying,
			 manufacturer_name character varying,
			 vendor_id character varying,
			 approved_device_modal character varying,
			 message character varying,
			 state_short_name character varying,
			 group_id character varying,
			 group_name character varying,
			 ota_command_set_count character varying,
			 two_factor_questions  character
		 );
		 DELETE FROM temp_auth;

		 IF EXISTS(SELECT login_id FROM users WHERE UPPER(login_id)=p_login_id )
		  THEN

                        SELECT id,password,role_id,state_id,is_first_time_login,username,mobile_no INTO v_id,v_server_password, v_role_id, v_state_id, v_is_first_time_login, v_name, v_mobile_no FROM users WHERE UPPER(login_id)=p_login_id;
 						SELECT designation_name INTO v_role_name FROM t_designation_master WHERE designation_id = v_role_id::smallint LIMIT 1;
                        --v_SaltedHashPassword1 := Hashbytes('SHA2_256',Cast(v_ServerPassword + p_SaltValue AS TEXT)); 
                        --v_SaltedHashPasswordServer:=Lower(Cast('' AS  XML);.value('xs:hexBinary(sql:variable("@SaltedHashPassword1"))', 'varchar(max)')); 
						-- SaltedHashPasswordServer 
						v_salted_hash_password1 := sha256((v_server_password || $3)::bytea); 
						v_salted_hash_password_server:=SUBSTRING ( v_salted_hash_password1::text ,3  ); 
						IF(p_state_id<>v_state_id)THEN
						
     						INSERT INTO temp_auth
							SELECT 'Fail' AS Flag,'',0::smallint,0,0::smallint,'','','','','','','','','State ID not matched' AS Message,'','','','';
						--ELSIF (p_password=v_salted_hash_password_server)
						ELSIF (p_password=p_salt_value || v_server_password)
						  THEN
						  raise notice 'Valid';
                            UPDATE users set last_login_ip=p_ip_address,last_login_time=now() where UPPER(login_id)=p_login_id;
							    IF(v_role_id=4)
								THEN
								Select  count(1) Into v_ota_command_set_count from t_vltd_ota_commands Where UPPER(vendor_id)=p_login_id;
								END IF;
						    IF(v_role_id=5)
							  THEN
 								Select state_short_name_current,state_name into v_state_short_name,v_state_name from t_state_master where state_id=p_state_id;
     							SELECT vendor_id into v_vendor_id from t_retro_fitment_center_master where UPPER(rfc_id)=p_login_id;
 								SELECT manufacturer_name,approved_device_modal,vendor_id into v_manufacturer_name, v_approved_device_modal, v_vendor_id
								 from t_device_manufacturer_cum_vendor where vendor_id=v_vendor_id; 
							  END IF; 
							  IF(v_role_id=13)
							  THEN
  									Select group_id,group_name into v_group_id, v_group_name from t_vehicle_group where UPPER(login_id)=p_login_id;
							  END IF;
							  
								INSERT INTO temp_auth 
     							SELECT  'Success' AS Flag,v_state_name as state_name,p_state_id as state_id,v_id,v_role_id as role_id,v_role_name,v_is_first_time_login as is_first_time_login,v_mobile_no as mobile_no,v_name as name,p_login_id as login_id,v_manufacturer_name as manufacturer_name,
							 	v_vendor_id as vendor_id,v_approved_device_modal as approved_device_modal,'Successfully Login' AS message,v_state_short_name as state_short_name,v_group_id as group_id,v_group_name as group_name,coalesce(v_ota_command_set_count,0) as ota_command_set_count;
								
								
							
	--cheack last updated password duration
	IF(SELECT COUNT(1) FROM users where id = v_id AND last_password_updated_at is null)THEN
		UPDATE users SET last_password_updated_at = (select created_at from t_password_change_log where login_id = p_login_id order by created_at desc limit 1) where id=v_id;
		IF(SELECT COUNT(1) FROM users where id = v_id AND last_password_updated_at is null)THEN
			 UPDATE users SET last_password_updated_at = created_at where id = v_id;
		END IF;
	END IF;

	SELECT password_life_in_days INTO v_password_life FROM t_project_details_master limit 1;

	SELECT COALESCE(f_date_diff_in_day(current_date,last_password_updated_at::date),0) into v_last_password_updated_days from users where id=v_id;
	IF(v_last_password_updated_days > v_password_life)THEN 
			UPDATE users set is_first_time_login='Y' where id=v_id;
	END IF;
	--end
							
							
							
								
						ELSE
							INSERT INTO temp_auth 
     						SELECT 'Fail' AS Flag,'',0::smallint,0,0::smallint,'','','','','','','','','Invalid Credentials.' AS Message,'','','','';
						 END IF;
					    
	  ELSE
	  	INSERT INTO temp_auth 
     	SELECT 'Fail' AS Flag,'',0::smallint,0,0::smallint,'','','','','','','','','Invalid Credentails. ' AS Message,'','','','';
	  END IF;
	 
	 RETURN QUERY 
	 select * from temp_auth;
END;
$BODY$;


------------------------------------------------------------------


-- Create New Procedure add_2fa_questions_answer()


CREATE OR REPLACE PROCEDURE public.add_2fa_questions_answer(
	p_question_id integer,
	p_answer text,
	p_login_id character varying,
	p_created_by character varying,
	p_ip_address character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE 
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	v_statename TEXT;
	v_rto_name TEXT;
Begin

BEGIN
					
	IF NOT EXISTS(Select 1 From t_2fa_questions_answer_master Where login_id=UPPER(p_login_id) HAVING COUNT(*) > 5)
	THEN
		
		INSERT INTO public.t_2fa_questions_answer_master(
			question_id, answer, login_id, created_by, created_at, ip_address)
		VALUES (p_question_id, UPPER(p_answer), p_login_id, p_created_by, NOW(), p_ip_address);
			   
		_response := '2FA Questions answer added successfully';
	ELSE
		_response := 'Already Exists';
	END IF;
	
						
	EXCEPTION
			  	WHEN others THEN 
				ROLLBACK;
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
				_response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(0,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),'NA','NA');	
				END;

End;
$BODY$;


----------------------------------------------------------------------------------------------


-- Create New Function f_get_2fa_questions_answer_login_id()

CREATE OR REPLACE FUNCTION public.f_get_2fa_questions_answer_login_id(p_login_id character varying)
    RETURNS SETOF t_2fa_questions_answer_master 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
	
BEGIN
 RETURN QUERY 
 	SELECT * FROM t_2fa_questions_answer_master WHERE login_id = p_login_id;							
END;
$BODY$;


-----------------------------------------------------------

-- Create New Function f_get_2fa_questions_answer_match_by_id()

CREATE OR REPLACE FUNCTION public.f_get_2fa_questions_answer_match_by_id(
	p_login_id character varying,
	p_question_id integer,
	p_answer text)
    RETURNS SETOF t_2fa_questions_answer_master 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
	
BEGIN
 RETURN QUERY 
 
 	SELECT * FROM t_2fa_questions_answer_master WHERE login_id = p_login_id 
		AND question_id = p_question_id AND answer = p_answer;							
		
END;
$BODY$;


--------------------------------------------------------------------------------

-- Date: 06-09-2024

-- Update in Function f_user_authentication()

CREATE OR REPLACE FUNCTION public.f_user_authentication(
	p_login_id character varying,
	p_password character,
	p_salt_value character varying,
	p_ip_address character varying,
	p_state_id smallint)
    RETURNS TABLE(val_flag character varying, val_state_name character varying, val_state_id smallint, val_id integer, val_role_id smallint, val_role_name character varying, val_is_first_time_login character varying, val_mobile_no character varying, val_name character varying, val_login_id character varying, val_manufacturer_name character varying, val_vendor_id character varying, val_approved_device_modal character varying, val_message character varying, val_state_short_name character varying, val_group_id character varying, val_group_name character varying, val_ota_command_set_count character varying, val_two_factor_questions character) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE 
	v_district varchar(25);
	v_server_password char(64); 
	v_name varchar(50);
	v_mobile_no char(10);
    v_salted_hash_password1 bytea; 
    v_salted_hash_password_server char(64); 
	v_is_first_time_login char(1);
	v_id integer;
	v_role_id smallint;
	v_role_name character varying(100);
	v_state_id smallint;
	v_state_short_name char(2);
	v_state_name varchar(50);
	v_vendor_id varchar(20)=null;
	v_approved_device_modal varchar(500)=null;
	v_manufacturer_name varchar(50)=null;
	v_group_id int=null;
	v_group_name varchar(250)=null;
	v_ota_command_set_count int=null;
	v_password_life integer;
	v_last_password_updated_days integer default 0;
BEGIN

         CREATE TEMPORARY TABLE IF NOT EXISTS temp_auth(
			 flag character varying,
			 state_name character varying,
			 state_id smallint,
			 id integer,
			 role_id smallint,
			 role_name character varying,
			 is_first_time_login character varying,
			 mobile_no character varying,
			 name character varying,
			 login_id character varying,
			 manufacturer_name character varying,
			 vendor_id character varying,
			 approved_device_modal character varying,
			 message character varying,
			 state_short_name character varying,
			 group_id character varying,
			 group_name character varying,
			 ota_command_set_count character varying,
			 two_factor_questions  character
		 );
		 DELETE FROM temp_auth;

		 IF EXISTS(SELECT login_id FROM users WHERE UPPER(login_id)=p_login_id )
		  THEN

                        SELECT id,password,role_id,state_id,is_first_time_login,username,mobile_no INTO v_id,v_server_password, v_role_id, v_state_id, v_is_first_time_login, v_name, v_mobile_no FROM users WHERE UPPER(login_id)=p_login_id;
 						SELECT designation_name INTO v_role_name FROM t_designation_master WHERE designation_id = v_role_id::smallint LIMIT 1;
                        --v_SaltedHashPassword1 := Hashbytes('SHA2_256',Cast(v_ServerPassword + p_SaltValue AS TEXT)); 
                        --v_SaltedHashPasswordServer:=Lower(Cast('' AS  XML);.value('xs:hexBinary(sql:variable("@SaltedHashPassword1"))', 'varchar(max)')); 
						-- SaltedHashPasswordServer 
						v_salted_hash_password1 := sha256((v_server_password || $3)::bytea); 
						v_salted_hash_password_server:=SUBSTRING ( v_salted_hash_password1::text ,3  ); 
						IF(p_state_id<>v_state_id)THEN
						
     						INSERT INTO temp_auth
							SELECT 'Fail' AS Flag,'',0::smallint,0,0::smallint,'','','','','','','','','State ID not matched' AS Message,'','','','';
						--ELSIF (p_password=v_salted_hash_password_server)
						ELSIF (p_password=p_salt_value || v_server_password)
						  THEN
						  raise notice 'Valid';
                            UPDATE users set last_login_ip=p_ip_address,last_login_time=now() where UPPER(login_id)=p_login_id;
							    IF(v_role_id=4)
								THEN
								Select  count(1) Into v_ota_command_set_count from t_vltd_ota_commands Where UPPER(vendor_id)=p_login_id;
								END IF;
						    IF(v_role_id=5)
							  THEN
 								Select state_short_name_current,state_name into v_state_short_name,v_state_name from t_state_master where state_id=p_state_id;
     							SELECT vendor_id into v_vendor_id from t_retro_fitment_center_master where UPPER(rfc_id)=p_login_id;
 								SELECT manufacturer_name,approved_device_modal,vendor_id into v_manufacturer_name, v_approved_device_modal, v_vendor_id
								 from t_device_manufacturer_cum_vendor where vendor_id=v_vendor_id; 
							  END IF; 
							  IF(v_role_id=13)
							  THEN
  									Select group_id,group_name into v_group_id, v_group_name from t_vehicle_group where UPPER(login_id)=p_login_id;
							  END IF;
							  
								INSERT INTO temp_auth 
     							SELECT  'Success' AS Flag,v_state_name as state_name,p_state_id as state_id,v_id,v_role_id as role_id,v_role_name,v_is_first_time_login as is_first_time_login,v_mobile_no as mobile_no,v_name as name,p_login_id as login_id,v_manufacturer_name as manufacturer_name,
							 	v_vendor_id as vendor_id,v_approved_device_modal as approved_device_modal,'Successfully Login' AS message,v_state_short_name as state_short_name,v_group_id as group_id,v_group_name as group_name,coalesce(v_ota_command_set_count,0) as ota_command_set_count;
								
								
			--DELETE FROM public.v_last_password_updated_days;				
	--cheack last updated password duration
	IF(SELECT COUNT(1) FROM users where id = v_id AND last_password_updated_at is null)THEN
		UPDATE users SET last_password_updated_at = (select created_at from t_password_change_log where login_id = p_login_id order by created_at desc limit 1) where id=v_id;
		IF(SELECT COUNT(1) FROM users where id = v_id AND last_password_updated_at is null)THEN
			 UPDATE users SET last_password_updated_at = created_at where id = v_id;
		END IF;
	END IF;

	v_password_life := (SELECT password_life_in_days FROM t_project_details_master limit 1);	
	v_last_password_updated_days := (SELECT COALESCE(f_date_diff_in_day(current_date,last_password_updated_at::date),0) from users where id=v_id);	
	IF(v_last_password_updated_days > v_password_life)THEN 
			UPDATE users set is_first_time_login='Y' where id=v_id;
	END IF;
	--end
							
							
							
								
						ELSE
							INSERT INTO temp_auth 
     						SELECT 'Fail' AS Flag,'',0::smallint,0,0::smallint,'','','','','','','','','Invalid Credentials.' AS Message,'','','','';
						 END IF;
					    
	  ELSE
	  	INSERT INTO temp_auth 
     	SELECT 'Fail' AS Flag,'',0::smallint,0,0::smallint,'','','','','','','','','Invalid Credentails. ' AS Message,'','','','';
	  END IF;
	 
	 RETURN QUERY 
	 select * from temp_auth;
END;
$BODY$;


------------------------------------------------------

-- Date: 12-09-2024


-- Create New Function enlistment.f_check_valid_uid_and_mobile_no


CREATE OR REPLACE FUNCTION enlistment.f_check_valid_uid_and_mobile_no(
    p_uid varchar(50),
    p_mobile_no char(10)
)
RETURNS text
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    result text;
BEGIN
    -- Check if UID exists and IsAllowed is 'Y'
    IF EXISTS (
        SELECT 1 FROM enlistment.t_morth_approved_device_manufacturer
        WHERE uid = p_uid AND is_allowed = 'Y'
    ) THEN
        -- Check if MobileNo matches
        IF EXISTS (
            SELECT 1 FROM enlistment.t_morth_approved_device_manufacturer
            WHERE uid = p_uid AND is_allowed = 'Y' AND mobile_no = p_mobile_no
        ) THEN
            -- Fetch the required details if both UID and MobileNo are valid
            SELECT 'Record Fetched Successfully, ' || manufacturer_name || ',' || 
                   COALESCE(manufacturer_name_old, '') || ',' || mobile_no
            INTO result
            FROM enlistment.t_morth_approved_device_manufacturer
            WHERE uid = p_uid AND is_allowed = 'Y' AND mobile_no = p_mobile_no;
        ELSE
            -- Return message for invalid MobileNo
            result := 'Please Enter Valid Registered Mobile No';
        END IF;
    ELSE
        -- Return message for invalid UID
        result := 'Please Enter Valid UID';
    END IF;

    -- Return the result
    RETURN result;
END;
$BODY$;


---------------------------------------------------------------------------

-- Date: 13-09-2024

-- Create New Table enlistment.t_device_manufacturer_cum_vendor_draft_table


CREATE TABLE enlistment.t_device_manufacturer_cum_vendor_draft_table (
    state_id INTEGER NOT NULL, 
    uid VARCHAR(32) NULL,
    cin CHAR(21) NULL,
    vendor_id VARCHAR(20) NOT NULL,
    manufacturer_name VARCHAR(200) NOT NULL,
    building_no VARCHAR(100) NULL,
    street VARCHAR(100) NULL,
    city VARCHAR(50) NOT NULL,
    pin CHAR(6) NOT NULL,
    manufacturer_state_id INTEGER NOT NULL, 
    manufacturer_district_id INTEGER NOT NULL,
    landline VARCHAR(12) NOT NULL,
    fax_no VARCHAR(12) NOT NULL,
    mobileno1 CHAR(10) NOT NULL,
    mobileno2 CHAR(10) NOT NULL,
    emailid1 VARCHAR(100) NULL,
    emailid2 VARCHAR(100) NULL,
    testingagency_id CHAR(1) NOT NULL,
    contact_person_name VARCHAR(50) NOT NULL,
    device_modal VARCHAR(50) NOT NULL,
    imei CHAR(15) NOT NULL,
    vehicle_reg_no VARCHAR(11) NOT NULL,
    primary_misdn VARCHAR(13) NULL,
    fallback_misdn VARCHAR(13) NULL,
    esim_provider CHAR(1) NULL,
    iccid VARCHAR(32) NULL,
    tac_documents BYTEA NULL, -- 'varbinary(max)' is equivalent to 'BYTEA' in PostgreSQL
    signed_reg_document BYTEA NULL, -- 'varbinary(max)' equivalent
    registration_date TIMESTAMP NULL, -- 'datetime' is 'TIMESTAMP' in PostgreSQL
    approval_letter BYTEA NULL, -- 'varbinary(max)' equivalent
    approval_letter_no VARCHAR(50) NULL,
    approval_date DATE NULL,
    is_approved CHAR(1) NOT NULL,
    updation_date TIMESTAMP NULL,
    insert_or_update_by VARCHAR(20) NULL,
    ip_address VARCHAR(15) NULL,
    cop_date DATE NULL,
    final_submit CHAR(1) NULL,
    PRIMARY KEY (vendor_id, device_modal) -- Primary key on VendorID and DeviceModal
);


---------------------------------------------------------------------------------------------

-- Create New Table enlistment.t_device_manufacturer_cum_vendor_draft_table_log


CREATE TABLE enlistment.t_device_manufacturer_cum_vendor_draft_table_log (
    state_id INTEGER NOT NULL, 
    uid VARCHAR(32) NULL,
    cin CHAR(21) NULL,
    vendor_id VARCHAR(20) NOT NULL,
    manufacturer_name VARCHAR(200) NOT NULL,
    building_no VARCHAR(100) NULL,
    street VARCHAR(100) NULL,
    city VARCHAR(50) NOT NULL,
    pin CHAR(6) NOT NULL,
    manufacturer_state_id INTEGER NOT NULL, 
    manufacturer_district_id INTEGER NOT NULL,
    landline VARCHAR(12) NOT NULL,
    fax_no VARCHAR(12) NOT NULL,
    mobileno1 CHAR(10) NOT NULL,
    mobileno2 CHAR(10) NOT NULL,
    emailid1 VARCHAR(100) NULL,
    emailid2 VARCHAR(100) NULL,
    testingagency_id CHAR(1) NOT NULL,
    contact_person_name VARCHAR(50) NOT NULL,
    device_modal VARCHAR(50) NOT NULL,
    imei CHAR(15) NOT NULL,
    vehicle_reg_no VARCHAR(11) NOT NULL,
    primary_misdn VARCHAR(13) NULL,
    fallback_misdn VARCHAR(13) NULL,
    esim_provider CHAR(1) NULL,
    iccid VARCHAR(32) NULL,
    tac_documents BYTEA NULL, -- 'varbinary(max)' is equivalent to 'BYTEA' in PostgreSQL
    signed_reg_document BYTEA NULL, -- 'varbinary(max)' equivalent
    registration_date TIMESTAMP NULL, -- 'datetime' is 'TIMESTAMP' in PostgreSQL
    approval_letter BYTEA NULL, -- 'varbinary(max)' equivalent
    approval_letter_no VARCHAR(50) NULL,
    approval_date DATE NULL,
    is_approved CHAR(1) NOT NULL,
    updation_date TIMESTAMP NULL,
    insert_or_update_by VARCHAR(20) NULL,
    ip_address VARCHAR(15) NULL,
    cop_date DATE NULL,
    final_submit CHAR(1) NULL
    
);



---------------------------------------------------------------------------------------------

-- Create New Function enlistment.f_get_vendor_detail()


CREATE OR REPLACE FUNCTION enlistment.f_get_vendor_detail(
    p_uid VARCHAR(50) DEFAULT NULL
)
RETURNS TABLE (
    val_manufacture_name VARCHAR,
    val_building_no VARCHAR,
    val_street VARCHAR,
    val_cin CHAR,
    val_city VARCHAR,
    val_pin CHAR,
    val_district_id INTEGER,
    val_state_id INTEGER,
    val_contact_person_name VARCHAR,
    val_landline VARCHAR,
    val_fax_no VARCHAR,
    val_mobileno1 CHAR,
    val_mobileno2 CHAR,
    val_emailid1 VARCHAR,
    val_emailid2 VARCHAR,
    val_vendor_id VARCHAR,
    val_testingagency_id CHAR,
    val_device_modal VARCHAR,
    val_imei CHAR,
    val_vehicle_reg_no VARCHAR,
    val_tac_documents bytea,
    val_approval_letter_no VARCHAR,
    val_approval_date DATE,
    val_approval_letter bytea,
    val_signed_reg_document bytea,
    val_is_active char,
    val_date_of_registration timestamp without time zone,
    val_primary_misdn VARCHAR,
    val_fallback_misdn VARCHAR,
    val_esim_provider CHAR,
    val_iccid VARCHAR,
    val_cop_date text
)
LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    RETURN QUERY 
    SELECT
        manufacturer_name,
        building_no,
        street,
        cin,
        city,
        pin,
        manufacturer_district_id AS district_id,
        manufacturer_state_id AS state_id,
        contact_person_name,
        landline,
        fax_no,
        mobileno1,
        mobileno2,
        emailid1,
        emailid2,
        vendor_id,
        testingagency_id,
        device_modal,
        imei,
        vehicle_reg_no,
        tac_documents,
        approval_letter_no,
        approval_date,
        approval_letter,
        signed_reg_document,
        is_approved AS is_active,
        registration_date AS date_of_registration,
        primary_misdn,
        fallback_misdn,
        esim_provider,
        iccid,
        TO_CHAR(cop_date, 'DD-MM-YYYY') AS cop_date
    FROM
        enlistment.t_device_manufacturer_cum_vendor_draft_table
    WHERE
        uid = p_uid
        AND final_submit = 'N';
END;
$BODY$;


---------------------------------------------------------------------------------------------------------

-- Date: 17-09-2024

-- Create New Procedure enlistment.add_temp_table_manufacture_data_for_enlistment()


CREATE OR REPLACE PROCEDURE enlistment.add_temp_table_manufacture_data_for_enlistment(
    p_stateid SMALLINT,
    p_uid VARCHAR(50),
    p_manufacturername VARCHAR(50),
    p_buildingno VARCHAR(100),
    p_street VARCHAR(100),
    p_city VARCHAR(100),
    p_pin VARCHAR(6),
    p_state SMALLINT,
    p_district SMALLINT,
    p_nameofcontactperson VARCHAR(50),
    p_landline VARCHAR(12),
    p_faxno VARCHAR(12),
    p_mobileno1 CHAR(10),
    p_mobileno2 CHAR(10),
    p_emailid1 VARCHAR(100),
    p_emailid2 VARCHAR(100),
    p_vendorid VARCHAR(20),
    p_devicemodal VARCHAR(300),
    p_imei VARCHAR(15),
    p_vehicleregno VARCHAR(20),
    p_testingagency CHAR(1),    
    p_copdate DATE,
    p_insertorupdateby VARCHAR(20),
    p_primarymisdn VARCHAR(13),
    p_fallbackmisdn VARCHAR(13),
    p_esimprovider CHAR(1),
    p_cin CHAR(21),
    p_iccid VARCHAR(32),
    p_finalsubmit CHAR(1) DEFAULT 'N',
	p_tacdocuments BYTEA DEFAULT NULL,
    p_signedregdocument BYTEA DEFAULT NULL,
    p_ipaddress VARCHAR(15) DEFAULT '',
	INOUT _response text DEFAULT NULL::text
)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_applicationsubmissiondate TIMESTAMP;   
	
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	
BEGIN
    -- Begin transaction
    BEGIN
        -- Check if UID exists in MorthApprovedDeviceManufacturer
        IF EXISTS (SELECT 1 FROM enlistment.t_morth_approved_device_manufacturer WHERE uid = p_uid) THEN
            
            -- Check if the DeviceModal exists in DeviceManufacturerCumVendor
            IF NOT EXISTS (SELECT 1 FROM enlistment.t_device_manufacturer_cum_vendor WHERE device_modal = p_devicemodal) THEN
                
                -- Check if the DeviceModal exists in DeviceManufacturerCumVendorDraftTable
                IF NOT EXISTS (SELECT 1 FROM enlistment.t_device_manufacturer_cum_vendor_draft_table WHERE device_modal = p_devicemodal) THEN
                    -- Insert a new draft record
                    INSERT INTO enlistment.t_device_manufacturer_cum_vendor_draft_table(
                        uid, cin, stateid, manufacturername, buildingno, street, city, pin, manufacturerstateid, 
                        manufacturerdistrictid, contactpersonname, landline, faxno, mobileno1, mobileno2, emailid1, 
                        emailid2, vendorid, devicemodal, imei, vehicleregno, testingagencyid, tacdocuments, 
                        copdate, signedregdocument, isapproved, registrationdate, ipaddress, insertorupdateby, 
                        primarymisdn, fallbackmisdn, esimprovider, iccid
                    )
                    VALUES (
                        p_uid, UPPER(p_cin), p_stateid, UPPER(p_manufacturername), UPPER(p_buildingno), 
                        UPPER(p_street), UPPER(p_city), p_pin, p_state, p_district, 
                        UPPER(p_nameofcontactperson), p_landline, p_faxno, p_mobileno1, p_mobileno2, LOWER(p_emailid1), 
                        LOWER(p_emailid2), UPPER(p_vendorid), UPPER(p_devicemodal), p_imei, UPPER(p_vehicleregno), 
                        p_testingagency, p_tacdocuments, p_copdate, p_signedregdocument, 'N', CURRENT_TIMESTAMP, 
                        p_ipaddress, p_insertorupdateby, p_primarymisdn, p_fallbackmisdn, p_esimprovider, p_iccid
                    );
                    _response := 'Record Updated successfully.';

                ELSE
                    -- Log the current draft table and update
                    INSERT INTO enlistment.t_device_manufacturer_cum_vendor_draft_table_log
                    SELECT * FROM enlistment.t_device_manufacturer_cum_vendor_draft_table WHERE device_modal = p_devicemodal;

                    UPDATE enlistment.t_device_manufacturer_cum_vendor_draft_table
                    SET 
                        cin = UPPER(p_cin), 
                        manufacturername = UPPER(p_manufacturername),
                        buildingno = UPPER(p_buildingno),
                        street = UPPER(p_street),
                        city = UPPER(p_city),
                        pin = p_pin,
                        manufacturerstateid = p_state,
                        manufacturerdistrictid = p_district,
                        contactpersonname = UPPER(p_nameofcontactperson),
                        landline = p_landline,
                        faxno = p_faxno,
                        mobileno1 = p_mobileno1,
                        mobileno2 = p_mobileno2,
                        emailid1 = LOWER(p_emailid1),
                        emailid2 = LOWER(p_emailid2),
                        vendorid = UPPER(p_vendorid),
                        devicemodal = UPPER(p_devicemodal),
                        imei = p_imei,
                        vehicleregno = UPPER(p_vehicleregno),
                        testingagencyid = p_testingagency,
                        tacdocuments = COALESCE(p_tacdocuments, tacdocuments),
                        signedregdocument = COALESCE(p_signedregdocument, signedregdocument),
                        isapproved = 'N',
                        primarymisdn = p_primarymisdn,
                        fallbackmisdn = p_fallbackmisdn,
                        esimprovider = p_esimprovider,
                        updationdate = CURRENT_TIMESTAMP,
                        ipaddress = p_ipaddress,
                        insertorupdateby = p_insertorupdateby,
                        iccid = p_iccid,
                        finalsubmit = p_finalsubmit,
                        copdate = p_copdate
                    WHERE devicemodal = p_devicemodal;

                    -- If final submit is 'Y', move the data to the main table
                    IF p_finalsubmit = 'Y' THEN
                        INSERT INTO enlistment.t_device_manufacturer_cum_vendor(
                            cin, stateid, manufacturername, buildingno, street, city, pin, manufacturerstateid, 
                            manufacturerdistrictid, contactpersonname, landline, faxno, mobileno1, mobileno2, emailid1, 
                            emailid2, vendorid, devicemodal, imei, vehicleregno, testingagencyid, tacdocuments, 
                            copdate, signedregdocument, isapproved, registrationdate, ipaddress, insertorupdateby, 
                            primarymisdn, fallbackmisdn, esimprovider, iccid, formsubmitmode
                        )
                        SELECT 
                            UPPER(cin), stateid, UPPER(manufacturername), UPPER(buildingno), UPPER(street), 
                            UPPER(city), pin, manufacturerstateid, manufacturerdistrictid, UPPER(contactpersonname), 
                            landline, faxno, mobileno1, mobileno2, LOWER(emailid1), LOWER(emailid2), 
                            UPPER(vendorid), UPPER(devicemodal), imei, UPPER(vehicleregno), testingagencyid, 
                            tacdocuments, copdate, signedregdocument, 'N', CURRENT_TIMESTAMP, p_ipaddress, 
                            p_insertorupdateby, primarymisdn, fallbackmisdn, esimprovider, iccid, 'Online'
                        FROM devicemanufacturercumvendordrafttable
                        WHERE uid = p_uid AND imei = p_imei;
                    END IF;

                    _response := 'Record Updated successfully.';
                END IF;

            ELSE
                -- Retrieve the previous submission date
                SELECT registrationdate INTO v_applicationsubmissiondate
                FROM enlistment.t_device_manufacturer_cum_vendor
                WHERE device_modal = p_devicemodal;

                _response := 'Your enlistment application for VLTD Model(' || p_devicemodal || ') already submitted on ' || TO_CHAR(v_applicationsubmissiondate, 'DD-MM-YYYY') || '. You can check enlistment status using link on home page.';
            END IF;

        ELSE
            _response := 'Invalid UID or UID not generate/enable for this manufacturer';
        END IF;

        -- Commit transaction
        --RETURN _response;
    EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_state_id,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insert_or_update_by,p_ip_address);	
				END;
END;
$BODY$;


-----------------------------------------------------------------------------

-- Date: 18-09-2024

-- Add Column in Table - enlistment.t_device_manufacturer_cum_vendor - form_submit_mode(character varying)


-------------------------------------------------------------------



-- Update in function enlistment.add_temp_table_manufacture_data_for_enlistment()

CREATE OR REPLACE PROCEDURE enlistment.add_temp_table_manufacture_data_for_enlistment(
	p_stateid smallint,
	p_uid character varying,
	p_manufacturername character varying,
	p_buildingno character varying,
	p_street character varying,
	p_city character varying,
	p_pin character varying,
	p_state smallint,
	p_district smallint,
	p_nameofcontactperson character varying,
	p_landline character varying,
	p_faxno character varying,
	p_mobileno1 character,
	p_mobileno2 character,
	p_emailid1 character varying,
	p_emailid2 character varying,
	p_vendorid character varying,
	p_devicemodal character varying,
	p_imei character varying,
	p_vehicleregno character varying,
	p_testingagency character,
	p_copdate date,
	p_insertorupdateby character varying,
	p_primarymisdn character varying,
	p_fallbackmisdn character varying,
	p_esimprovider character,
	p_cin character,
	p_iccid character varying,
	p_finalsubmit character DEFAULT 'N'::bpchar,
	p_tacdocuments bytea DEFAULT NULL::bytea,
	p_signedregdocument bytea DEFAULT NULL::bytea,
	p_ipaddress character varying DEFAULT ''::character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_applicationsubmissiondate TIMESTAMP;   
	
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	
BEGIN
    -- Begin transaction
    BEGIN
        -- Check if UID exists in MorthApprovedDeviceManufacturer
        IF EXISTS (SELECT 1 FROM enlistment.t_morth_approved_device_manufacturer WHERE uid = p_uid) THEN
            
            -- Check if the DeviceModal exists in DeviceManufacturerCumVendor
            IF NOT EXISTS (SELECT 1 FROM enlistment.t_device_manufacturer_cum_vendor WHERE device_modal = p_devicemodal) THEN
                
                -- Check if the DeviceModal exists in DeviceManufacturerCumVendorDraftTable
                IF NOT EXISTS (SELECT 1 FROM enlistment.t_device_manufacturer_cum_vendor_draft_table WHERE device_modal = p_devicemodal) THEN
                    -- Insert a new draft record
                    INSERT INTO enlistment.t_device_manufacturer_cum_vendor_draft_table(
                        uid, cin, state_id, manufacturer_name, building_no, street, city, pin, manufacturer_state_id, 
                        manufacturer_district_id, contact_person_name, landline, fax_no, mobileno1, mobileno2, emailid1, 
                        emailid2, vendor_id, device_modal, imei, vehicle_reg_no, testingagency_id, tac_documents, 
                        cop_date, signed_reg_document, is_approved, registration_date, ip_address, insert_or_update_by, 
                        primary_misdn, fallback_misdn, esim_provider, iccid
                    )
                    VALUES (
                        p_uid, UPPER(p_cin), p_stateid, UPPER(p_manufacturername), UPPER(p_buildingno), 
                        UPPER(p_street), UPPER(p_city), p_pin, p_state, p_district, 
                        UPPER(p_nameofcontactperson), p_landline, p_faxno, p_mobileno1, p_mobileno2, LOWER(p_emailid1), 
                        LOWER(p_emailid2), UPPER(p_vendorid), UPPER(p_devicemodal), p_imei, UPPER(p_vehicleregno), 
                        p_testingagency, p_tacdocuments, p_copdate, p_signedregdocument, 'N', CURRENT_TIMESTAMP, 
                        p_ipaddress, p_insertorupdateby, p_primarymisdn, p_fallbackmisdn, p_esimprovider, p_iccid
                    );
                    _response := 'Record Updated successfully.';

                ELSE
                    -- Log the current draft table and update
                    INSERT INTO enlistment.t_device_manufacturer_cum_vendor_draft_table_log
                    SELECT * FROM enlistment.t_device_manufacturer_cum_vendor_draft_table WHERE device_modal = p_devicemodal;

                    UPDATE enlistment.t_device_manufacturer_cum_vendor_draft_table
                    SET 
                        cin = UPPER(p_cin), 
                        manufacturer_name = UPPER(p_manufacturername),
                        building_no = UPPER(p_buildingno),
                        street = UPPER(p_street),
                        city = UPPER(p_city),
                        pin = p_pin,
                        manufacturer_state_id = p_state,
                        manufacturer_district_id = p_district,
                        contact_person_name = UPPER(p_nameofcontactperson),
                        landline = p_landline,
                        fax_no = p_faxno,
                        mobileno1 = p_mobileno1,
                        mobileno2 = p_mobileno2,
                        emailid1 = LOWER(p_emailid1),
                        emailid2 = LOWER(p_emailid2),
                        vendor_id = UPPER(p_vendorid),
                        device_modal = UPPER(p_devicemodal),
                        imei = p_imei,
                        vehicle_reg_no = UPPER(p_vehicleregno),
                        testingagency_id = p_testingagency,
                        tac_documents = COALESCE(p_tacdocuments, tacdocuments),
                        signed_reg_document = COALESCE(p_signedregdocument, signedregdocument),
                        is_approved = 'N',
                        primary_misdn = p_primarymisdn,
                        fallback_misdn = p_fallbackmisdn,
                        esim_provider = p_esimprovider,
                        updation_date = CURRENT_TIMESTAMP,
                        ip_address = p_ipaddress,
                        insert_or_update_by = p_insertorupdateby,
                        iccid = p_iccid,
                        final_submit = p_finalsubmit,
                        cop_date = p_copdate
                    WHERE device_modal = p_devicemodal;

                    -- If final submit is 'Y', move the data to the main table
                    IF p_finalsubmit = 'Y' THEN
                        INSERT INTO enlistment.t_device_manufacturer_cum_vendor(
                            cin, state_id, manufacturer_name, building_no, street, city, pin, manufacturer_state_id, 
                            manufacturer_district_id, contact_person_name, landline, fax_no, mobileno1, mobileno2, emailid1, 
                            emailid2, vendorid, device_modal, imei, vehicle_reg_no, testing_agency_id, tac_documents, 
                            cop_date, signed_reg_document, is_approved, registration_date, ip_address, insert_or_update_by, 
                            primary_misdn, fallback_misdn, esim_provider, icc_id, form_submit_mode
                        )
                        SELECT 
                            UPPER(cin), state_id, UPPER(manufacturer_name), UPPER(building_no), UPPER(street), 
                            UPPER(city), pin, manufacturer_state_id, manufacturer_district_id, UPPER(contact_person_name), 
                            landline, faxno, mobileno1, mobileno2, LOWER(emailid1), LOWER(emailid2), 
                            UPPER(vendor_id), UPPER(device_modal), imei, UPPER(vehicle_reg_no), testingagency_id, 
                            tac_documents, cop_date, signed_reg_document, 'N', CURRENT_TIMESTAMP, p_ipaddress, 
                            p_insertorupdateby, primary_misdn, fallback_misdn, esim_provider, iccid, 'Online'
                        FROM enlistment.t_device_manufacturer_cum_vendor_draft_table
                        WHERE uid = p_uid AND imei = p_imei;
                    END IF;

                    _response := 'Record Updated successfully.';
                END IF;

            ELSE
                -- Retrieve the previous submission date
                SELECT registration_date INTO v_applicationsubmissiondate
                FROM enlistment.t_device_manufacturer_cum_vendor
                WHERE device_modal = p_devicemodal;

                _response := 'Your enlistment application for VLTD Model(' || p_devicemodal || ') already submitted on ' || TO_CHAR(v_applicationsubmissiondate, 'DD-MM-YYYY') || '. You can check enlistment status using link on home page.';
            END IF;

        ELSE
            _response := 'Invalid UID or UID not generate/enable for this manufacturer';
        END IF;

        -- Commit transaction
        --RETURN _response;
    EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_stateid,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insertorupdateby,p_ipaddress);	
				END;
END;
$BODY$;

------------------------------------------------------------------------------------------

-- Date: 19-09-2024


-- Create New Function enlistment.f_get_device_manufacturer_cum_vendor_draft_table()

CREATE OR REPLACE FUNCTION enlistment.f_get_device_manufacturer_cum_vendor_draft_table(
	p_vendor_id character varying,
	p_device_modal character varying,
	p_uid character varying)
    RETURNS SETOF enlistment.t_device_manufacturer_cum_vendor_draft_table 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
	
BEGIN
 RETURN QUERY 
 
 	SELECT * FROM enlistment.t_device_manufacturer_cum_vendor_draft_table WHERE vendor_id = p_vendor_id 
		AND device_modal = p_device_modal AND uid = p_uid;							
		
END;
$BODY$;

-----------------------------------------------------------------------------------------------------------

-- Date: 20-9-2024

-- Update in Procedure


CREATE OR REPLACE PROCEDURE enlistment.add_temp_table_manufacture_data_for_enlistment(
	p_stateid smallint,
	p_uid character varying,
	p_manufacturername character varying,
	p_buildingno character varying,
	p_street character varying,
	p_city character varying,
	p_pin character varying,
	p_state smallint,
	p_district smallint,
	p_nameofcontactperson character varying,
	p_landline character varying,
	p_faxno character varying,
	p_mobileno1 character,
	p_mobileno2 character,
	p_emailid1 character varying,
	p_emailid2 character varying,
	p_vendorid character varying,
	p_devicemodal character varying,
	p_imei character varying,
	p_vehicleregno character varying,
	p_testingagency character,
	p_copdate date,
	p_insertorupdateby character varying,
	p_primarymisdn character varying,
	p_fallbackmisdn character varying,
	p_esimprovider character,
	p_cin character,
	p_iccid character varying,
	p_finalsubmit character DEFAULT 'N'::bpchar,
	p_tacdocuments bytea DEFAULT NULL::bytea,
	p_signedregdocument bytea DEFAULT NULL::bytea,
	p_ipaddress character varying DEFAULT ''::character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_applicationsubmissiondate TIMESTAMP;   
	
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	
BEGIN
    -- Begin transaction
    BEGIN
        -- Check if UID exists in MorthApprovedDeviceManufacturer
        IF EXISTS (SELECT 1 FROM enlistment.t_morth_approved_device_manufacturer WHERE uid = p_uid) THEN
            
            -- Check if the DeviceModal exists in DeviceManufacturerCumVendor
            IF NOT EXISTS (SELECT 1 FROM enlistment.t_device_manufacturer_cum_vendor WHERE device_modal = p_devicemodal) THEN
                
                -- Check if the DeviceModal exists in DeviceManufacturerCumVendorDraftTable
                IF NOT EXISTS (SELECT 1 FROM enlistment.t_device_manufacturer_cum_vendor_draft_table WHERE device_modal = p_devicemodal) THEN
                    -- Insert a new draft record
                    INSERT INTO enlistment.t_device_manufacturer_cum_vendor_draft_table(
                        uid, cin, state_id, manufacturer_name, building_no, street, city, pin, manufacturer_state_id, 
                        manufacturer_district_id, contact_person_name, landline, fax_no, mobileno1, mobileno2, emailid1, 
                        emailid2, vendor_id, device_modal, imei, vehicle_reg_no, testingagency_id, tac_documents, 
                        cop_date, signed_reg_document, is_approved, registration_date, ip_address, insert_or_update_by, 
                        primary_misdn, fallback_misdn, esim_provider, iccid, final_submit
                    )
                    VALUES (
                        p_uid, UPPER(p_cin), p_stateid, UPPER(p_manufacturername), UPPER(p_buildingno), 
                        UPPER(p_street), UPPER(p_city), p_pin, p_state, p_district, 
                        UPPER(p_nameofcontactperson), p_landline, p_faxno, p_mobileno1, p_mobileno2, LOWER(p_emailid1), 
                        LOWER(p_emailid2), UPPER(p_vendorid), UPPER(p_devicemodal), p_imei, UPPER(p_vehicleregno), 
                        p_testingagency, p_tacdocuments, p_copdate, p_signedregdocument, 'N', CURRENT_TIMESTAMP, 
                        p_ipaddress, p_insertorupdateby, p_primarymisdn, p_fallbackmisdn, p_esimprovider, p_iccid, p_finalsubmit
                    );
                    _response := 'Record Updated successfully.';

                ELSE
                    -- Log the current draft table and update
                    INSERT INTO enlistment.t_device_manufacturer_cum_vendor_draft_table_log
                    SELECT * FROM enlistment.t_device_manufacturer_cum_vendor_draft_table WHERE device_modal = p_devicemodal;

                    UPDATE enlistment.t_device_manufacturer_cum_vendor_draft_table
                    SET 
                        cin = UPPER(p_cin), 
                        manufacturer_name = UPPER(p_manufacturername),
                        building_no = UPPER(p_buildingno),
                        street = UPPER(p_street),
                        city = UPPER(p_city),
                        pin = p_pin,
                        manufacturer_state_id = p_state,
                        manufacturer_district_id = p_district,
                        contact_person_name = UPPER(p_nameofcontactperson),
                        landline = p_landline,
                        fax_no = p_faxno,
                        mobileno1 = p_mobileno1,
                        mobileno2 = p_mobileno2,
                        emailid1 = LOWER(p_emailid1),
                        emailid2 = LOWER(p_emailid2),
                        vendor_id = UPPER(p_vendorid),
                        device_modal = UPPER(p_devicemodal),
                        imei = p_imei,
                        vehicle_reg_no = UPPER(p_vehicleregno),
                        testingagency_id = p_testingagency,
                        tac_documents = COALESCE(p_tacdocuments, tac_documents),
                        signed_reg_document = COALESCE(p_signedregdocument, signed_reg_document),
                        is_approved = 'N',
                        primary_misdn = p_primarymisdn,
                        fallback_misdn = p_fallbackmisdn,
                        esim_provider = p_esimprovider,
                        updation_date = CURRENT_TIMESTAMP,
                        ip_address = p_ipaddress,
                        insert_or_update_by = p_insertorupdateby,
                        iccid = p_iccid,
                        final_submit = p_finalsubmit,
                        cop_date = p_copdate
                    WHERE device_modal = p_devicemodal;

                    -- If final submit is 'Y', move the data to the main table
                    IF p_finalsubmit = 'Y' THEN
                        INSERT INTO enlistment.t_device_manufacturer_cum_vendor(
                            cin, state_id, manufacturer_name, building_no, street, city, pin, manufacturer_state_id, 
                            manufacturer_district_id, contact_person_name, landline, fax_no, mobileno1, mobileno2, emailid1, 
                            emailid2, vendorid, device_modal, imei, vehicle_reg_no, testing_agency_id, tac_documents, 
                            cop_date, signed_reg_document, is_approved, registration_date, ip_address, insert_or_update_by, 
                            primary_misdn, fallback_misdn, esim_provider, icc_id, form_submit_mode
                        )
                        SELECT 
                            UPPER(cin), state_id, UPPER(manufacturer_name), UPPER(building_no), UPPER(street), 
                            UPPER(city), pin, manufacturer_state_id, manufacturer_district_id, UPPER(contact_person_name), 
                            landline, faxno, mobileno1, mobileno2, LOWER(emailid1), LOWER(emailid2), 
                            UPPER(vendor_id), UPPER(device_modal), imei, UPPER(vehicle_reg_no), testingagency_id, 
                            tac_documents, cop_date, signed_reg_document, 'N', CURRENT_TIMESTAMP, p_ipaddress, 
                            p_insertorupdateby, primary_misdn, fallback_misdn, esim_provider, iccid, 'Online'
                        FROM enlistment.t_device_manufacturer_cum_vendor_draft_table
                        WHERE uid = p_uid AND imei = p_imei;
                    END IF;

                    _response := 'Record Updated successfully.';
                END IF;

            ELSE
                -- Retrieve the previous submission date
                SELECT registration_date INTO v_applicationsubmissiondate
                FROM enlistment.t_device_manufacturer_cum_vendor
                WHERE device_modal = p_devicemodal;

                _response := 'Your enlistment application for VLTD Model(' || p_devicemodal || ') already submitted on ' || TO_CHAR(v_applicationsubmissiondate, 'DD-MM-YYYY') || '. You can check enlistment status using link on home page.';
            END IF;

        ELSE
            _response := 'Invalid UID or UID not generate/enable for this manufacturer';
        END IF;

        -- Commit transaction
        --RETURN _response;
    EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_stateid,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insertorupdateby,p_ipaddress);	
				END;
END;
$BODY$;


------------------------------------------------------------------------------

-- New Function created

CREATE OR REPLACE FUNCTION public.f_list_ota_command_type(p_vendorid VARCHAR(20))
RETURNS TABLE (
    val_ota_command_type_id INTEGER,
    val_ota_command_type VARCHAR,
    val_ota_command VARCHAR,
    val_gprs_ota_command VARCHAR,
    val_vmn VARCHAR
) AS $$

DECLARE    
	v_vmn varchar;
BEGIN
	v_vmn := (SELECT vmn FROM public.t_m2m_vmn_gatway_details);
    -- First SELECT query
    RETURN QUERY
    SELECT 
        m.ota_command_type_id,
        m.ota_command_type,
        v.ota_command,
        v.gprs_ota_command,
		v_vmn
    FROM public.t_ota_command_type_master m
    LEFT JOIN (
        SELECT * FROM public.t_vltd_ota_commands WHERE vendor_id = p_vendorid
    ) v
    ON m.ota_command_type_id = v.ota_command_type_id;

    -- Second SELECT query
    --RETURN QUERY
    --SELECT vmn FROM public.t_m2m_vmn_gatway_details;

END;
$$ LANGUAGE plpgsql;

--------------------------------------------------------------------------------------

-- Date: 23-09-2024

-- Create New Function get_blacklist_command()

CREATE OR REPLACE FUNCTION public.get_blacklist_command()
RETURNS TABLE (val_command TEXT) AS $$
BEGIN
    RETURN QUERY
    SELECT UPPER(command) AS val_command
    FROM t_black_list_command_master;
END;
$$ LANGUAGE plpgsql;


------------------------------------------------------

-- Update in ref Curser Function f_list_ota_command_type()


CREATE OR REPLACE FUNCTION public.f_list_ota_command_type(
	par_state_id integer,
	par_vendor_id character varying)
    RETURNS SETOF refcursor 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE 
	c_vltd_ota_command refcursor;
	c_m2m_vmn_gatway_details refcursor;
	
BEGIN
           
     
	OPEN c_vltd_ota_command FOR
    	Select M.ota_command_type_id,M.ota_command_type, M.mandatory_yn,ota_command from t_ota_command_type_master AS 
		M Left JOIN
		(Select * from t_vltd_ota_commands Where vendor_id=par_vendor_id) AS V 
		ON M.ota_command_type_id=V.ota_command_type_id  where M.ota_command_type_id not in (3,4);
			   
	RETURN NEXT c_vltd_ota_command; 		   
	
	
	
	OPEN c_m2m_vmn_gatway_details FOR
    	
		Select vmn From t_m2m_vmn_gatway_details;
			
 	RETURN NEXT c_m2m_vmn_gatway_details; 	
	
 
END;
$BODY$;

--------------------------------------------------------------------------------------------

-- Date: 24-09-2024

-- Update in Function f_list_ota_command_type()


CREATE OR REPLACE FUNCTION public.f_list_ota_command_type(
	par_state_id integer,
	par_vendor_id character varying)
    RETURNS SETOF refcursor 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE 
	c_vltd_ota_command refcursor;
	c_m2m_vmn_gatway_details refcursor;
	
BEGIN
           
     
	OPEN c_vltd_ota_command FOR
    	Select M.ota_command_type_id,M.ota_command_type, M.mandatory_yn,ota_command,V.gprs_ota_command from t_ota_command_type_master AS 
		M Left JOIN
		(Select * from t_vltd_ota_commands Where vendor_id=par_vendor_id) AS V 
		ON M.ota_command_type_id=V.ota_command_type_id  where M.ota_command_type_id not in (3,4);
			   
	RETURN NEXT c_vltd_ota_command; 		   
	
	
	
	OPEN c_m2m_vmn_gatway_details FOR
    	
		Select vmn From t_m2m_vmn_gatway_details;
			
 	RETURN NEXT c_m2m_vmn_gatway_details; 	
	
 
END;
$BODY$;

-----------------------------------------------------

-- Create New Procedure enlistment.add_tac_document()


CREATE OR REPLACE PROCEDURE enlistment.add_tac_document(
	p_stateid integer,
	p_uid character varying,
	p_device_modal character varying,
	p_full_tac_document bytea,	
	p_ipaddress character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
Declare 
	v_roleid int;
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
BEGIN
	BEGIN	
		Update enlistment.t_device_manufacturer_cum_vendor_draft_table 
				SET tac_documents = p_full_tac_document,
					updation_date = NOW(),    
    				ip_address = p_ipaddress
    		WHERE uid=p_uid AND final_submit='N' and device_modal =UPPER(p_device_modal);
			_response := 'File uploaded successfully';	
			
			
		EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;

				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_stateid,0,v_state,v_msg || ' ' || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,1,now(),'NA',p_ipaddress);	
				END;
	
END;
$BODY$;

------------------------------------------------------------------------------------

-- Date: 25-09-2024

-- Update in Function enlistment.add_temp_table_manufacture_data_for_enlistment()


CREATE OR REPLACE PROCEDURE enlistment.add_temp_table_manufacture_data_for_enlistment(
	p_stateid smallint,
	p_uid character varying,
	p_manufacturername character varying,
	p_buildingno character varying,
	p_street character varying,
	p_city character varying,
	p_pin character varying,
	p_state smallint,
	p_district smallint,
	p_nameofcontactperson character varying,
	p_landline character varying,
	p_faxno character varying,
	p_mobileno1 character,
	p_mobileno2 character,
	p_emailid1 character varying,
	p_emailid2 character varying,
	p_vendorid character varying,
	p_devicemodal character varying,
	p_imei character varying,
	p_vehicleregno character varying,
	p_testingagency character,
	p_copdate date,
	p_insertorupdateby character varying,
	p_primarymisdn character varying,
	p_fallbackmisdn character varying,
	p_esimprovider character,
	p_cin character,
	p_iccid character varying,
	p_finalsubmit character DEFAULT 'N'::bpchar,
	p_tacdocuments bytea DEFAULT NULL::bytea,
	p_signedregdocument bytea DEFAULT NULL::bytea,
	p_ipaddress character varying DEFAULT ''::character varying,
	INOUT _response text DEFAULT NULL::text)
LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_applicationsubmissiondate TIMESTAMP;   
	
	v_state   TEXT;
    v_msg     TEXT;
    v_detail  TEXT;
    v_hint    TEXT;
    v_context TEXT;
	
BEGIN
    -- Begin transaction
    BEGIN
        -- Check if UID exists in MorthApprovedDeviceManufacturer
        IF EXISTS (SELECT 1 FROM enlistment.t_morth_approved_device_manufacturer WHERE uid = p_uid) THEN
            
            -- Check if the DeviceModal exists in DeviceManufacturerCumVendor
            IF NOT EXISTS (SELECT 1 FROM enlistment.t_device_manufacturer_cum_vendor WHERE device_modal = p_devicemodal) THEN
                
                -- Check if the DeviceModal exists in DeviceManufacturerCumVendorDraftTable
                IF NOT EXISTS (SELECT 1 FROM enlistment.t_device_manufacturer_cum_vendor_draft_table WHERE device_modal = p_devicemodal) THEN
                    -- Insert a new draft record
                    INSERT INTO enlistment.t_device_manufacturer_cum_vendor_draft_table(
                        uid, cin, state_id, manufacturer_name, building_no, street, city, pin, manufacturer_state_id, 
                        manufacturer_district_id, contact_person_name, landline, faxno, mobileno1, mobileno2, emailid1, 
                        emailid2, vendor_id, device_modal, imei, vehicle_reg_no, testingagency_id, tac_documents, 
                        cop_date, signed_reg_document, is_approved, registration_date, ip_address, insert_or_update_by, 
                        primary_misdn, fallback_misdn, esim_provider, iccid, final_submit
                    )
                    VALUES (
                        p_uid, UPPER(p_cin), p_stateid, UPPER(p_manufacturername), UPPER(p_buildingno), 
                        UPPER(p_street), UPPER(p_city), p_pin, p_state, p_district, 
                        UPPER(p_nameofcontactperson), p_landline, p_faxno, p_mobileno1, p_mobileno2, LOWER(p_emailid1), 
                        LOWER(p_emailid2), UPPER(p_vendorid), UPPER(p_devicemodal), p_imei, UPPER(p_vehicleregno), 
                        p_testingagency, p_tacdocuments, p_copdate, p_signedregdocument, 'N', CURRENT_TIMESTAMP, 
                        p_ipaddress, p_insertorupdateby, p_primarymisdn, p_fallbackmisdn, p_esimprovider, p_iccid, p_finalsubmit
                    );
                    _response := 'Record Updated successfully.';

                ELSE
                    -- Log the current draft table and update
                    INSERT INTO enlistment.t_device_manufacturer_cum_vendor_draft_table_log
                    SELECT * FROM enlistment.t_device_manufacturer_cum_vendor_draft_table WHERE device_modal = p_devicemodal;

                    UPDATE enlistment.t_device_manufacturer_cum_vendor_draft_table
                    SET 
                        cin = UPPER(p_cin), 
                        manufacturer_name = UPPER(p_manufacturername),
                        building_no = UPPER(p_buildingno),
                        street = UPPER(p_street),
                        city = UPPER(p_city),
                        pin = p_pin,
                        manufacturer_state_id = p_state,
                        manufacturer_district_id = p_district,
                        contact_person_name = UPPER(p_nameofcontactperson),
                        landline = p_landline,
                        fax_no = p_faxno,
                        mobileno1 = p_mobileno1,
                        mobileno2 = p_mobileno2,
                        emailid1 = LOWER(p_emailid1),
                        emailid2 = LOWER(p_emailid2),
                        vendor_id = UPPER(p_vendorid),
                        device_modal = UPPER(p_devicemodal),
                        imei = p_imei,
                        vehicle_reg_no = UPPER(p_vehicleregno),
                        testingagency_id = p_testingagency,
                        tac_documents = COALESCE(p_tacdocuments, tac_documents),
                        signed_reg_document = COALESCE(p_signedregdocument, signed_reg_document),
                        is_approved = 'N',
                        primary_misdn = p_primarymisdn,
                        fallback_misdn = p_fallbackmisdn,
                        esim_provider = p_esimprovider,
                        updation_date = CURRENT_TIMESTAMP,
                        ip_address = p_ipaddress,
                        insert_or_update_by = p_insertorupdateby,
                        iccid = p_iccid,
                        final_submit = p_finalsubmit,
                        cop_date = p_copdate
                    WHERE device_modal = p_devicemodal;

                    -- If final submit is 'Y', move the data to the main table
                    IF p_finalsubmit = 'Y' THEN
                        INSERT INTO enlistment.t_device_manufacturer_cum_vendor(
                            cin, state_id, manufacturer_name, building_no, street, city, pin, manufacturer_state_id, 
                            manufacturer_district_id, contact_person_name, landline, faxno, mobile_no_1, mobile_no_2, email_id_1, 
                            email_id_2, vendor_id, device_modal, imei, vehicle_reg_no, testing_agency_id, tac_documents, 
                            cop_date, signed_reg_document, is_approved, registration_date, ip_address, insert_or_update_by, 
                            primary_misdn, fallback_misdn, esim_provider, icc_id, form_submit_mode
                        )
                        SELECT 
                            UPPER(cin), state_id, UPPER(manufacturer_name), UPPER(building_no), UPPER(street), 
                            UPPER(city), pin, manufacturer_state_id, manufacturer_district_id, UPPER(contact_person_name), 
                            landline, fax_no, mobileno1, mobileno2, LOWER(emailid1), LOWER(emailid2), 
                            UPPER(vendor_id), UPPER(device_modal), imei, UPPER(vehicle_reg_no), testingagency_id, 
                            tac_documents, cop_date, signed_reg_document, 'N', CURRENT_TIMESTAMP, p_ipaddress, 
                            p_insertorupdateby, primary_misdn, fallback_misdn, esim_provider, iccid, 'Online'
                        FROM enlistment.t_device_manufacturer_cum_vendor_draft_table
                        WHERE uid = p_uid AND imei = p_imei;
                    END IF;

                    _response := 'Record Updated successfully.';
                END IF;

            ELSE
                -- Retrieve the previous submission date
                SELECT registration_date INTO v_applicationsubmissiondate
                FROM enlistment.t_device_manufacturer_cum_vendor
                WHERE device_modal = p_devicemodal;

                _response := 'Your enlistment application for VLTD Model(' || p_devicemodal || ') already submitted on ' || TO_CHAR(v_applicationsubmissiondate, 'DD-MM-YYYY') || '. You can check enlistment status using link on home page.';
            END IF;

        ELSE
            _response := 'Invalid UID or UID not generate/enable for this manufacturer';
        END IF;

        -- Commit transaction
        --RETURN _response;
    EXCEPTION
			  	WHEN others THEN 
				get stacked diagnostics
				v_state   = returned_sqlstate,
				v_msg     = message_text,
				v_detail  = pg_exception_detail,
				v_hint    = pg_exception_hint,
				v_context = pg_exception_context;
                _response := 'Something went to wrong.'||v_msg;
				raise notice E'Got exception:
				state  : %
				message: %
				detail : %
				hint   : %
				context: %', v_state, v_msg, v_detail, v_hint, v_context;
				INSERT INTO public.t_exception_log(state_id,logging_id,exception_code,exception_message,module_type,created_at,created_by,created_by_ip) values(p_stateid,0,v_state,v_msg || ' ' || v_detail || ' ' || v_hint || ' ' || v_context,2,now(),p_insertorupdateby,p_ipaddress);	
				END;
END;
$BODY$;


-----------------------------------------------------------------------------------------------------

-- Date: 1-10-2024

-- Update in Function f_list_send_sms_log()


CREATE OR REPLACE FUNCTION public.f_list_send_sms_log(
	par_month_id integer DEFAULT NULL::integer,
	par_date timestamp with time zone DEFAULT NULL::timestamp with time zone,
	par_to_date timestamp with time zone DEFAULT NULL::timestamp with time zone,
	par_year character DEFAULT NULL::bpchar,
	par_display_length integer DEFAULT 10,
	par_display_start integer DEFAULT 0,
	par_sort_col integer DEFAULT 0,
	par_sort_dir character varying DEFAULT 'ASC'::character varying,
	par_search character varying DEFAULT ''::character varying)
    RETURNS TABLE(val_row_num bigint, val_total_count bigint, val_mobile_no character varying, val_insertion_date_time text, val_message character varying, val_status text, val_sms_gateway_response character varying) 
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE PARALLEL UNSAFE
    ROWS 1000

AS $BODY$
DECLARE
    par_first_rec integer := par_display_start;
    par_last_rec integer := par_display_start + par_display_length;
BEGIN
	-- Conditional logic
    IF par_year IS NULL THEN
        -- Query when par_year is NULL
        RETURN QUERY
        WITH cte_temp AS (
            SELECT 
                ROW_NUMBER() OVER (ORDER BY
					CASE WHEN (par_sort_col = 1 AND UPPER(par_sort_dir) = 'ASC') THEN created_at END ASC,
					CASE WHEN (par_sort_col = 1 AND UPPER(par_sort_dir) = 'DESC') THEN created_at END DESC
				) AS row_num,
                COUNT(1) OVER() AS total_count,
                mobile_no,
                TO_CHAR(created_at, 'DD/MM/YYYY HH24:MI:SS') AS insertion_date_time,
                text_message,
                CASE WHEN status = 'P' THEN 'Success' WHEN status = 'F' THEN 'Failed' ELSE 'Failed' END AS status,
                sms_gateway_response
            FROM t_send_sms_log
            WHERE 
                (created_at BETWEEN par_date AND par_to_date) 
                AND (par_search IS NULL OR text_message ILIKE '%' || par_search || '%' OR mobile_no ILIKE '%' || par_search || '%')
        )
        SELECT 
            row_num,
            total_count,
            mobile_no,
            insertion_date_time,
            text_message,
            status,
            sms_gateway_response
        FROM cte_temp
        WHERE row_num > par_first_rec AND row_num <= par_last_rec;

    ELSE
        -- Query when par_year is NOT NULL
        RETURN QUERY
        WITH cte_temp AS (
            SELECT 
                ROW_NUMBER() OVER (ORDER BY
					CASE WHEN (par_sort_col = 1 AND UPPER(par_sort_dir) = 'ASC') THEN created_at END ASC,
					CASE WHEN (par_sort_col = 1 AND UPPER(par_sort_dir) = 'DESC') THEN created_at END DESC
				) AS row_num,
                COUNT(1) OVER() AS total_count,
                mobile_no,
                TO_CHAR(created_at, 'DD/MM/YYYY HH24:MI:SS') AS insertion_date_time,
                text_message,
                CASE WHEN status = 'P' THEN 'Success' WHEN status = 'F' THEN 'Failed' ELSE 'Failed' END AS status,
                sms_gateway_response
            FROM t_send_sms_log
            WHERE 
                ((EXTRACT(YEAR FROM created_at)::char(4) = par_year AND EXTRACT(MONTH FROM created_at) = par_month_id)
                OR (created_at BETWEEN par_date AND par_to_date)) 
                AND (par_search IS NULL OR text_message ILIKE '%' || par_search || '%' OR mobile_no ILIKE '%' || par_search || '%')
        )
        SELECT 
            row_num,
            total_count,
            mobile_no,
            insertion_date_time,
            text_message,
            status,
            sms_gateway_response
        FROM cte_temp
        WHERE row_num > par_first_rec AND row_num <= par_last_rec;
    END IF;
	
END;
$BODY$;














